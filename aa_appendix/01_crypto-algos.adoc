[#sect-hash-functions]
=== Hash Functions

[#sect-blake2]
=== BLAKE2

BLAKE2 is a collection of cryptographic hash functions known for their high
speed. Their design closely resembles BLAKE which has been a finalist in the
SHA-3 competition.

Polkadot is using the Blake2b variant which is optimized for 64-bit platforms.
Unless otherwise specified, the Blake2b hash function with a 256-bit output is
used whenever Blake2b is invoked in this document. The detailed specification
and sample implementations of all variants of Blake2 hash functions can be found
in RFC 7693.

[#sect-randomness]
=== Randomness

NOTE: TBH

[#sect-vrf]
=== VRF

A Verifiable Random Function (VRF) is a mathematical operation that takes some
input and produces a random number using a secret key along with a proof of
authenticity that this random number was generated using the submitter's secret
key and the given input. The proof can be verified by any challenger to ensure
the random number generation is valid and has not been tampered with (for
example to the benfit of submitter).

In Polkadot, VRFs are used for the BABE block production lottery by the
Algorithm as defined in <<algo-block-production-lottery>>  and the parachain
approval voting mechanism (<<sect-approval-voting>>). The VRF uses mechanism
similar to algorithms introduced in the following papers:

* https://eprint.iacr.org/2017/099.pdf[Making NSEC5 Practical for DNSSEC].
* https://blog.cloudflare.com/privacy-pass-the-math/#dleqproofs[DLEQ Proofs].
* https://tools.ietf.org/id/draft-goldbe-vrf-01.html[Verifiable Random Functions (VRFs)].

It essentially generates a deterministic elliptic curve based Schnorr
signature as a verifiable random value. The elliptic curve group used in the VRF
function is the Ristretto group specified in:

* https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448-01[The Ristretto255 and Decaf448 Groups].

[#defn-vrf-context]
.<<defn-vrf-context, VRF Context>>
====
*VRF context* (simply referred to as context when there is no ambiguity)
represented as stem:[c] is a [TODO: define context here]
====

[#defn-vrf-pair]
.<<defn-vrf-pair, VRF Pair>>
====
The *VRF Pair* is an ordered pair stem:[(I,O)] where stem:[I] represents the VRF
input and stem:[O] represents the VRF output. stem:[I] is of the following
format:

[stem]
++++
I = (C,P)\
C = (b_0, ... b_31)\
P = (x,y,z,t)\
x = (b_0, ... b_4)
++++

where:

* stem:[C] is the Ristretto point in compressed wire format, exactly 32 bytes.
* stem:[P] is the Ristretto point in the Ristretto group for Cruve25519.
* stem:[x] is the element of the field, exactly 5 bytes.

 [TODO: we need to specify where does C and x is coming from]
====

[#defn-vrf-proof]
.<<defn-vrf-proof, VRF Proof>>
====
The *VRF proof* proves the correctness for an associated VRF output. The VRF
proof, stem:[P], is a datastructure of the following format:

[stem]
++++
P = (C,S)\
S = (b_0, ... b_31)
++++

where stem:[C] is the challenge and stem:[S] is the 32-byte Schnorr poof. Both
are expressed as Curve25519 scalars.
====

[#defn-vrf-transcript]
.<<defn-vrf-transcript, VRF Transcript>>
====
The *VRF transcript* is a “public-coin” argument [TODO: I'd not introduced
obsecure scary words like these in the definition without defining them]
containing a mathematical object [TODO: what is a mathematical object?] combined
with a context and is more closely described in the Merlin documentation [we
agreed to remove merlin and speccing it], which is a STROBE-based transcript
[TODO: why the fact that marlin strobe based is relevant in the middle of the
definition] construction for zero-knowledge proofs [TODO: maybe define marlin
transcript separately and refer to it.]. The transcript, stem:[T], is a STROBE
object for the 128-bit security level as defined in the STROBE specification in
Section 5:

[stem]
++++
T = (s,p,b,f)\
s = (b_0, ... b_199)
++++

where:

* stem:[s] is the duplex state consisting of a 200-byte array that is always
8-byte aligned.
* stem:[p] is an unsigned 8-bit integer and indicates the position in the duplex
state where the next byte will be processed.
* stem:[b] is an unsigned 8-bit integer and indicates the position in the duplex
state which is _1_ after the beginning of the current operation. stem:[b] is
equal to _0_ if no operation began in this block.
* stem:[f] is an unsigned 8-bit integer and can be _0_, _1_ or _None_. It
indicates whether the party sends or receives a message on the transport.
====

[#defn-vrf-meta-ad]
.<<defn-vrf-meta-ad, `Meta-Ad`>>
====
The stem:["Meta-Ad"] function takes a transcript (<<defn-vrf-transcript>>),
stem:[t], a UTF-8 encoded label, stem:[l], and a byte array, stem:[b], and
returns an updated transcript.

[stem]
++++
t larr "Meta-Ad"(t,l,b)
++++

The stem:["Meta-Ad"] operation adds the label and the byte array to the passed
on transcript as described in the STROBE documentation. [TODO: where?]
====

[#defn-vrf-evaluate-vrf]
.<<defn-vrf-evaluate-vrf, `Evaluate-VRF`>>
====
The stem:["Evaluate-VRF"] function takes a public key, stem:[k], a transcript
(<<defn-vrf-transcript>>), stem:[t], and produces a VRF-Pair
(<<defn-vrf-pair>>), stem:[p].

[stem]
++++
p larr "Evaluate-VRF"(k,t)
++++

The functions converts the public key, stem:[k], into a Ristretto point and a
corresponding wire format (<<defn-vrf-pair>>), respectively the value stem:[I]
(or stem:[O], which are equal). [TODO]
====

[#defn-vrf-dleq-proove]
.<<defn-vrf-dleq-proove, `DLEQ-Prove`>>
====
The stem:["DLEQ-Prove"] function takes a private key, stem:[s_k], and a
transcript (<<defn-vrf-transcript>>), stem:[t], and a VRF pair
(<<defn-vrf-pair>>), stem:[v], and produces a VRF proof (<<defn-vrf-proof>>),
stem:[p].

[stem]
++++
p larr "DLEQ-Prove"(s_k,t,v)
++++

The functions executed the following steps: [TODO]
====

[#defn-vrf-create-transcript]
.<<defn-vrf-create-transcript, `Create-Transcript`>>
====
The stem:["Create-Transcript"] function takes a context, stem:[c], represented
as a UTF-8 encoded string and produces a transcript (<<defn-vrf-transcript>>),
stem:[t].

[stem]
++++
t larr "Create-Transcript"(c)
++++

The function initializes a Merlin transcript as described in the
https://merlin.cool/transcript/index.html[Merlin documentation], respectively
section “3.1.1 Transcript Objects” and section “3.1.2 Initialization”.
====

==== `Make-Challenge-Bytes`
****
Algorithm: stem:["Make-Challenge-Bytes"(p,c,s) -> A]

. stem:[t larr "Create-Transcript"('"VRFResult"')]
. stem:[t larr "Meta-Ad"(t,phi,c)]
. stem:[t larr "Append-Message"(t, '"vrf-in"', I " where " I in p)]
. stem:[t larr "Append-Message"(t, '"vrf-out"', O " where " O in p)]
. stem:[t larr "Meta-Ad"(t,"Enc"_("LE")(s,4),c)]
. stem:["return Strobe-PRF"(r,s)]

where:

* stem:[p] is the VRF pair (<<defn-vrf-pair>>).
* stem:[c] is the VRF context (<<defn-vrf-context>>).
* stem:[s] is the size of the resulting byte array.
* stem:["Create-Transcript"] is a function defined in
<<defn-vrf-create-transcript>>.
* stem:["Meta-Ad"] is a function defined in <<defn-vrf-meta-ad>>.
* stem:["Append-Message"] is a function defined in <<defn-vrf-append-message>>.
* stem:["Strobe-PRF"] is STROBE function specified in [?] . It extracts
pseudorandom data of given length as deterministic function of the transcript.
This data can be treated as a hash of all preceding operations, messages and
keys.
****

[#defn-vrf-append-message]
.<<defn-vrf-append-message, `Append-Message`>>
====
The stem:["Append-Message"] function takes a transcript
(<<defn-vrf-transcript>>), stem:[t], a context, stem:[c], represented as a UTF-8
encoded string and a message, stem:[m], represented as a byte array and returns
an updated transcript form the initial transcript stem:[t].

[stem]
++++
t larr "Append-Message"(t,c,m)
++++

This function appends the messages to the transcript as described in the
https://merlin.cool/transcript/index.html[Merlin documentation], respectively
section “3.1.3 Appending Messages”.
====

[#sect-cryptographic-keys]
=== Cryptographic Keys

Various types of keys are used in Polkadot to prove the identity of the actors
involved in the Polkadot Protocols. To improve the security of the users, each
key type has its own unique function and must be treated differently, as
described by this Section.

[#defn-account-key]
.<<defn-account-key, Account Key>>
====
*Account key stem:[(sk^a,pk^a)]* is a key pair of type of either of the schemes in the following
table:

.List of the public key scheme which can be used for an account key
|===
|Key Scheme| Description

|sr25519
|Schnorr signature on Ristretto compressed ed25519 points as implemented in TODO

|ed25519
|The standard ed25519 signature complying with TODO

|secp256k1
|Only for outgoing transfer transactions.
|===

An account key can be used to sign transactions among other accounts and
balance-related functions. There are two prominent subcategories of account keys
namely "stash keys" and "controller keys", each being used for a different
function. Keys defined in Definitions <<defn-account-key>>, <<defn-stash-key>>
and <<defn-controller-key>> are created and managed by the user independent of
the Polkadot implementation. The user notifies the network about the used keys
by submitting a transaction, as defined in
link_sect-creating-controller-key[9.5.2] and link_sect-certifying-keys[9.5.5]
respectively.
====

[#defn-stash-key]
.<<defn-stash-key, Stash Key>>
====
The *Stash key* is a type of account key that holds funds bonded for staking
(described in Section link_sect-staking-funds[9.5.1]) to a particular
controller key (defined in Definition
<<defn-controller-key>>). As a result, one may actively
participate with a stash key keeping the stash key offline in a secure location.
It can also be used to designate a Proxy account to vote in governance
proposals, as described in link_sect-creating-controller-key[9.5.2]. The Stash
key holds the majority of the users’ funds and should neither be shared with
anyone, saved on an online device, nor used to submit extrinsics.
====

[#defn-controller-key]
.<<defn-controller-key, Controller Key>>
====
The *Controller key* is a type of account key that acts on behalf of the Stash
account. It signs transactions that make decisions regarding the nomination and
the validation of the other keys. It is a key that will be in direct control of
a user and should mostly be kept offline, used to submit manual extrinsics. It
sets preferences like payout account and commission, as described in
link_sect-controller-settings[9.5.4]. If used for a validator, it certifies the
session keys, as described in link_sect-certifying-keys[9.5.5]. It only needs
the required funds to pay transaction fees [TODO: key needing fund needs to be
defined].
====

[#defn-session-key]
.<<defn-session-key, Session Keys>>
====
*Session keys* are short-lived keys that are used to authenticate validator
operations. Session keys are generated by the Polkadot Host and should be
changed regularly due to security reasons. Nonetheless, no validity period is
enforced by the Polkadot protocol on session keys. Various types of keys used by
the Polkadot Host are presented in Table link_tabl-session-keys[9.1]_:_

.List of key schemes which are used for session keys depending on the protocol
|===
|Protocol |Key scheme

|GRANDPA |ED25519
|BABE |SR25519
|I’m Online |SR25519
|Parachain |SR25519
|===

Session keys must be accessible by certain Polkadot Host APIs defined in
Appendix link_sect-host-api[12]. Session keys are _not_ meant to control the
majority of the users’ funds and should only be used for their intended purpose.
[TODO: key managing fund need to be defined]
====

[#sect-staking-funds]
==== Holding and staking funds

NOTE: TBH

[#sect-creating-controller-key]
==== Creating a Controller key

NOTE: TBH

[#sect-designating-proxy]
==== Designating a proxy for voting

NOTE: TBH

[#sect-controller-settings]
==== Controller settings

NOTE: TBH

[#sect-certifying-keys]
==== Certifying keys

Due to security considerations and Runtime upgrades, the session keys are
supposed to  be changed regularly. As such, the new session keys need to be
certified by a controller key before putting them in use. The controller only
needs to create a certificate by signing a session public key and broadcasting
this certificate via an extrinsic. [TODO: spec the detail of the data structure
of the certificate etc.]
