\documentclass{book}
\usepackage[T2A,T1]{fontenc}
\usepackage[english]{babel}
\usepackage{amsmath,amssymb,graphicx,enumerate,hyperref,calc,xcolor,ifthen,latexsym,alltt,theorem,capt-of,makeidx}
\makeindex

%%%%%%%%%% Start TeXmacs macros
\catcode`\<=\active \def<{
\fontencoding{T1}\selectfont\symbol{60}\fontencoding{\encodingdefault}}
\catcode`\>=\active \def>{
\fontencoding{T1}\selectfont\symbol{62}\fontencoding{\encodingdefault}}
\newcommand{\assign}{:=}
\newcommand{\infixand}{\text{ and }}
\newcommand{\infixor}{\text{ or }}
\newcommand{\nin}{\not\in}
\newcommand{\nobracket}{}
\newcommand{\nosymbol}{}
\newcommand{\textdots}{...}
\newcommand{\tmem}[1]{{\em #1\/}}
\newcommand{\tmmathbf}[1]{\ensuremath{\boldsymbol{#1}}}
\newcommand{\tmmathmd}[1]{\ensuremath{#1}}
\newcommand{\tmname}[1]{\textsc{#1}}
\newcommand{\tmop}[1]{\ensuremath{\operatorname{#1}}}
\newcommand{\tmrsub}[1]{\ensuremath{_{\textrm{#1}}}}
\newcommand{\tmrsup}[1]{\textsuperscript{#1}}
\newcommand{\tmsamp}[1]{\textsf{#1}}
\newcommand{\tmstrong}[1]{\textbf{#1}}
\newcommand{\tmsubtitle}[1]{\thanks{\textit{Subtitle:} #1}}
\newcommand{\tmtextbf}[1]{\text{{\bfseries{#1}}}}
\newcommand{\tmtextit}[1]{\text{{\itshape{#1}}}}
\newcommand{\tmtextsc}[1]{\text{{\scshape{#1}}}}
\newcommand{\tmtexttt}[1]{\text{{\ttfamily{#1}}}}
\newcommand{\tmtextup}[1]{\text{{\upshape{#1}}}}
\newcommand{\tmverbatim}[1]{\text{{\ttfamily{#1}}}}
\newcommand{\todo}[1]{{\color{red!75!black}[To do: #1]}}
\newenvironment{enumeratenumeric}{\begin{enumerate}[1.] }{\end{enumerate}}
\newenvironment{itemizedot}{\begin{itemize} \renewcommand{\labelitemi}{$\bullet$}\renewcommand{\labelitemii}{$\bullet$}\renewcommand{\labelitemiii}{$\bullet$}\renewcommand{\labelitemiv}{$\bullet$}}{\end{itemize}}
\newenvironment{itemizeminus}{\begin{itemize} \renewcommand{\labelitemi}{$-$}\renewcommand{\labelitemii}{$-$}\renewcommand{\labelitemiii}{$-$}\renewcommand{\labelitemiv}{$-$}}{\end{itemize}}
\newenvironment{theglossary}[1]{\begin{list}{}{\setlength{\labelwidth}{6.5em}\setlength{\leftmargin}{7em}\small} }{\end{list}}
\newenvironment{tmindent}{\begin{tmparmod}{1.5em}{0pt}{0pt}}{\end{tmparmod}}
\newenvironment{tmparmod}[3]{\begin{list}{}{\setlength{\topsep}{0pt}\setlength{\leftmargin}{#1}\setlength{\rightmargin}{#2}\setlength{\parindent}{#3}\setlength{\listparindent}{\parindent}\setlength{\itemindent}{\parindent}\setlength{\parsep}{\parskip}} \item[]}{\end{list}}
\newenvironment{tmparsep}[1]{\begingroup\setlength{\parskip}{#1}}{\endgroup}
\newcounter{tmcounter}
\newcommand{\custombinding}[1]{%
  \setcounter{tmcounter}{#1}%
  \addtocounter{tmcounter}{-1}%
  \refstepcounter{tmcounter}}
\newtheorem{definition}{Definition}
{\theorembodyfont{\rmfamily}\newtheorem{example}{Example}}
\newtheorem{notation}{Notation}
{\theorembodyfont{\rmfamily}\newtheorem{note}{Note}}
\providecommand{\qed}{\ensuremath{\Box}}
{\theorembodyfont{\rmfamily}\newtheorem{remark}{Remark}}
\newcommand{\tmfloatcontents}{}
\newlength{\tmfloatwidth}
\newcommand{\tmfloat}[5]{
  \renewcommand{\tmfloatcontents}{#4}
  \setlength{\tmfloatwidth}{\widthof{\tmfloatcontents}+1in}
  \ifthenelse{\equal{#2}{small}}
    {\setlength{\tmfloatwidth}{0.45\linewidth}}
    {\setlength{\tmfloatwidth}{\linewidth}}
  \begin{minipage}[#1]{\tmfloatwidth}
    \begin{center}
      \tmfloatcontents
      \captionof{#3}{#5}
    \end{center}
  \end{minipage}}
%%%%%%%%%% End TeXmacs macros

\providecommand{\nobracket}{}
\providecommand{\nosymbol}{}


\newcommand{\blobB}{\ensuremath{\bar{B}}}
\newcommand{\PoVB}{\ensuremath{\tmop{PoV}_B}}
\newcommand{\paraValidSet}{\ensuremath{\mathcal{V}_{\rho}}}

\begin{document}

\title{
  The Polkadot Host
  \tmsubtitle{Protocol Specification}
}

\date{November 4, 2021}

\maketitle

{\tableofcontents}

\

\chapter{Background}

\section{Introduction}

Formally, Polkadot is a replicated sharded state machine designed to resolve
the scalability and interoperability among blockchains. In Polkadot
vocabulary, shards are called {\tmem{parachains}} and Polkadot {\tmem{relay
chain}} is part of the protocol ensuring global consensus among all the
parachains. The Polkadot relay chain protocol, henceforward called
{\tmem{Polkadot protocol}}, can itself be considered as a replicated state
machine on its own. As such, the protocol can be specified by identifying the
state machine and the replication strategy.

\

From a more technical point of view, the Polkadot protocol has been divided
into two parts, the {\tmem{Runtime}} and the {\tmem{Host}}. The Runtime
comprises the state transition logic for the Polkadot protocol and is designed
and be upgradable via the consensus engine without requiring hard forks of the
blockchain. The Polkadot Host provides the functionality for the Runtime to
execute its state transition logic, such as an execution environment, I/O and
consensus, shared mostly among peer-to-peer decentralized
cryptographically-secured transaction systems, i.e. blockchains whose
consensus system is based on the proof-of-stake. The Polkadot Host is planned
to be stable and static for the lifetime duration of the Polkadot protocol.

\

With the current document, we aim to specify the Polkadot Host part of the
Polkadot protocol as a replicated state machine. After defining the basic
terms in Chapter 1, we proceed to specify the representation of a valid state
of the Protocol in Chapter \ref{chap-state-spec}. In Chapter
\ref{chap-state-transit}, we identify the protocol states, by explaining the
Polkadot state transition and discussing the detail based on which the
Polkadot Host interacts with the state transition function, i.e. Runtime.
Following, we specify the input messages triggering the state transition and
the system behaviour. In Chapter \ref{sect-networking}, we specify the
communication protocols and network messages required for the Polkadot Host to
communicate with other nodes in the network, such as exchanging blocks and
consensus messages. In Chapter \ref{chap-consensu}, we specify the consensus
protocol, which is responsible for keeping all the replica in the same state.
Finally, the initial state of the machine is identified and discussed in
Appendix \ref{sect-genesis-block}. A Polkadot Host implementation which
conforms with this part of the specification should successfully be able to
sync its states with the Polkadot network.

\section{Definitions and Conventions}\label{sect-defn-conv}

\begin{definition}
  \label{defn-state-machine}A {\tmstrong{Discrete State Machine (DSM)}} is a
  state transition system whose set of states and set of transitions are
  countable and admits a starting state. Formally, it is a tuple of
  \[  (\Sigma, S, s_0, \delta) \]
  where \label{defn-runtime}
  \begin{itemize}
    \item $\Sigma$ is the countable set of all possible transitions.
    
    \item $S$ is a countable set of all possible states.
    
    \item $s_0 \in S$ is the initial state.
    
    \item $\delta$ is the state-transition function, known as
    {\tmstrong{Runtime}} in the Polkadot vocabulary, such that
    \[ \delta : S \times \Sigma \rightarrow S \]
  \end{itemize}
\end{definition}

\begin{definition}
  \label{defn-path-graph}A {\tmstrong{path graph}} or a {\tmstrong{path}} of
  $n$ nodes formally referred to as \label{autolab1}{\tmstrong{$P_n$}}, is a
  tree with two nodes of vertex degree 1 and the other n-2 nodes of vertex
  degree 2. Therefore, $P_n$ can be represented by sequences of $(v_1, \ldots,
  v_n)$ where $e_i = (v_i, v_{i + 1})$ for $1 \leqslant i \leqslant n - 1$ is
  the edge which connect $v_i$ and $v_{i + 1}$.
\end{definition}

\begin{definition}
  \label{defn-radix-tree}{\tmstrong{Radix-r tree}} is a variant of \ a trie in
  which:
  \begin{itemize}
    \item Every node has at most $r$ children where $r = 2^x$ for some $x$;
    
    \item Each node that is the only child of a parent, which does not
    represent a valid key is merged with its parent.
  \end{itemize}
\end{definition}

As a result, in a radix tree, any path whose interior vertices all have only
one child and does not represent a valid key in the data set, is compressed
into a single edge. This improves space efficiency when the key space is
sparse.

\begin{definition}
  By a {\tmstrong{sequences of bytes}} or a {\tmstrong{byte array}}, $b$, of
  length $n$, we refer to
  \[ b \assign (b_0, b_1, ..., b_{n - 1})  \text{such that } 0 \leqslant b_i
     \leqslant 255 \]
  We define \label{autolab2}$\mathbb{B}_n$ to be the {\tmstrong{set of all
  byte arrays of length $n$}}. Furthermore, we define:
  \[ \mathbb{B} \assign \bigcup^{\infty}_{i = 0} \mathbb{B}_i \]
\end{definition}

\begin{notation}
  We represent the concatenation of byte arrays $a \assign (a_0, \ldots, a_n)$
  and $b \assign (b_0, \ldots, b_m)$ by:
  \[ a || b \assign (a_0, \ldots, a_n, b_0, \ldots, b_m) \]
\end{notation}

\begin{definition}
  \label{defn-bit-rep}For a given byte $b$ the {\tmstrong{bitwise
  representation}} of $b$ is defined as
  \[ b \assign b^7 \ldots b^0 \]
  where
  \[ b = 2^0 b^0 + 2^1 b^1 + \cdots + 2^7 b^7 \]
\end{definition}

\begin{definition}
  \label{defn-little-endian}By \tmverbatim{}the {\tmstrong{little-endian}}
  representation of a non-negative integer, \label{autolab3}I, represented as
  \[ I = (B_n \ldots B_0)_{256} \]
  in base 256, we refer to a byte array \label{autolab4}$B = (b_0, b_1,
  \ldots, b_n)$ such that
  \[ b_i \assign B_i \]
  Accordingly, we define the function
  \label{autolab5}$\tmop{Enc}_{\tmop{LE}}$:
  \[ \begin{array}{llll}
       \tmop{Enc}_{\tmop{LE}} : & \mathbb{Z}^+ & \rightarrow & \mathbb{B}\\
       & (B_n \ldots B_0)_{256} & \mapsto & (B_{0,} B_1, \ldots , B_n)
     \end{array} \]
  
\end{definition}

\begin{definition}
  By {\tmname{{\tmstrong{\tmverbatim{UINT32}}}}} we refer to a non-negative
  integer stored in a byte array of length 4 using little-endian encoding
  format.
\end{definition}

\begin{definition}
  A \label{autolab6}{\tmstrong{blockchain}} $C$ is a directed path graph. Each
  node of the graph is called \label{autolab7}{\tmstrong{Block}} and indicated
  by {\tmstrong{$B$}}. The unique sink of $C$ is called
  \label{autolab8}{\tmstrong{Genesis Block}}, and the source is called the
  \label{autolab9}{\tmstrong{Head}} of C. For any vertex $(B_1, B_2)$ where
  $B_1 \rightarrow B_2$ we say $B_2$ is the
  \label{autolab10}{\tmstrong{parent}} of $B_1$ and we indicate it by
  \[ B_2 \assign P (B_1) \]
\end{definition}

\begin{definition}
  \label{defn-unix-time}By {\tmstrong{UNIX time}}, we refer to the unsigned,
  little-endian encoded 64-bit integer which stores the number of
  {\tmstrong{milliseconds}} that have elapsed since the Unix epoch, that is
  the time 00:00:00 UTC on 1 January 1970, minus leap seconds. Leap seconds
  are ignored, and every day is treated as if it contained exactly 86'400
  seconds.
\end{definition}

\subsection{Block Tree}

In the course of formation of a (distributed) blockchain, it is possible that
the chain forks into multiple subchains in various block positions. We refer
to this structure as a {\tmem{block tree:}}

\begin{definition}
  \label{defn-block-tree}The \label{autolab11}{\tmstrong{block tree}} of a
  blockchain, denoted by $\tmop{BT}$ is the union of all different versions of
  the blockchain observed by the Polkadot Host such that every block is a node
  in the graph and $B_1$ is connected to $B_2$ if $B_1$ is a parent of $B_2$.
\end{definition}

When a block in the block tree gets finalized, there is an opportunity to
prune the block tree to free up resources into branches of blocks that do not
contain all of the finalized blocks or those that can never be finalized in
the blockchain. For a definition of finality, see Section \ref{sect-finality}.

\begin{definition}
  \label{defn-pruned-tree}By \label{autolab12}{\tmstrong{Pruned Block Tree}},
  denoted by $\tmop{PBT}$, we refer to a subtree of the block tree obtained by
  eliminating all branches which do not contain the most recent finalized
  blocks, as defined in Definition \ref{defn-finalized-block}. By
  \label{autolab13}{\tmstrong{pruning}}, we refer to the procedure of
  $\tmop{BT} \leftarrow \tmop{PBT}$. When there is no risk of ambiguity and is
  safe to prune BT, we use $\tmop{BT}$ to refer to $\tmop{PBT}$.
\end{definition}

Definition \ref{defn-chain-subchain} gives the means to highlight various
branches of the block tree.

\begin{definition}
  \label{defn-chain-subchain}Let \label{autolab14}$G$ be the root of the block
  tree and $B$ be one of its nodes. By
  \label{autolab15}{\tmname{{\tmstrong{Chain($B$)}},}} we refer to the path
  graph from $G$ to $B$ in (P)$\tmop{BT}$. Conversely, for a chain
  $C$={\tmname{Chain(B)}}, we define \label{autolab16}{\tmstrong{the head of
  $C$}} to be $B$, formally noted as $B \assign${\tmname{Head($C$)}}. We
  define \label{autolab17}$| C |$, the length of $C$as a path graph. If $B'$
  is another node on {\tmname{Chain($B$)}}, then by
  \label{autolab18}{\tmname{SubChain($B', B$)}} we refer to the subgraph of
  {\tmname{Chain($B$)}} path graph which contains both $B$ and $B'$ and by
  {\tmname{\textbar SubChain($B', B$)\textbar}} we refer to its length.
  Accordingly, \label{autolab19}$\mathbb{C}_{B'} ((P) \tmop{BT})$ is the set
  of all subchains of $(P) \tmop{BT}$ rooted at $B'$. The set of all chains of
  $(P) \tmop{BT}$, $\mathbb{C}_G ((P) \tmop{BT})$ is denoted by
  $\mathbb{C}$((P)BT) or simply \label{autolab20}$\mathbb{C}$, for the sake of
  brevity.
\end{definition}

\begin{definition}
  \label{defn-longest-chain}We define the following complete order over
  $\mathbb{C}$ such that for $C_1, C_2 \in \mathbb{C}$ if $| C_1 | \neq | C_2
  |$ we say $C_1 > C_2$ if and only if $| C_1 | > | C_2 |$.
  
  If $| C_1 | = | C_2 |$ we say $C_1 > C_2$ if and only if the block arrival
  time of $\tmop{Head} (C_1) $ is less than the block arrival time of
  $\tmop{Head} (C_2)$ as defined in Definition \ref{defn-block-time}. We
  define the
  \label{autolab21}{\tmstrong{{\tmname{Longest-Chain($\tmop{BT}$)}}}} to be
  the maximum chain given by this order.
\end{definition}

\begin{definition}
  \label{autolab22}{\tmname{Longest-Path($\tmop{BT}$)}} returns the path graph
  of $(P) \tmop{BT}$ which is the longest among all paths in $(P) \tmop{BT}$
  and has the earliest block arrival time as defined in Definition
  \ref{defn-block-time}. \label{autolab23}
  {\tmname{Deepest-Leaf($\tmop{BT}$)}} returns the head of
  {\tmname{Longest-Path($\tmop{BT}$)}} chain.
\end{definition}

Because every block in the blockchain contains a reference to its parent, it
is easy to see that the block tree is de facto a tree. A block tree naturally
imposes partial order relationships on the blocks as follows:

\begin{definition}
  We say {\tmstrong{B is descendant of $B'$}}, formally noted as {\tmstrong{$B
  > B'$}} if $B$ is a descendant of $B'$ in the block tree.
\end{definition}

\

\begin{flushright}
  {\qed}
\end{flushright}

\

\chapter{State Specification}\label{chap-state-spec}

\section{State Storage and Storage Trie}\label{sect-state-storage}

For storing the state of the system, Polkadot Host implements a hash table
storage where the keys are used to access each data entry. There is no
assumption either on the size of the key nor on the size of the data stored
under them, besides the fact that they are byte arrays with specific upper
limits on their length. The limit is imposed by the encoding algorithms to
store the key and the value in the storage trie.

\subsection{Accessing System Storage }

The Polkadot Host implements various functions to facilitate access to the
system storage for the Runtime. See Section \ref{sect-entries-into-runtime}
for a an explaination of those functions. Here we formalize the access to the
storage when it is being directly accessed by the Polkadot Host (in contrast
to Polkadot runtime).

\begin{definition}
  \label{defn-stored-value}The \label{autolab24}{\tmstrong{StoredValue}}
  function retrieves the value stored under a specific key in the state
  storage and is formally defined as :
  \[ \begin{array}{cc}
       \tmop{StoredValue} : & \mathcal{K} \rightarrow \mathcal{V}\\
       & k \mapsto \left\{ \begin{array}{cc}
         v & \text{if (k,v) exists in state storage}\\
         \phi & \tmop{otherwise}
       \end{array} \right.
     \end{array} \]
  where $\mathcal{K} \subset \mathbb{B}$ and $\mathcal{V} \subset \mathbb{B}$
  are respectively the set of all keys and values stored in the state storage.
  
  \ 
\end{definition}

\subsection{The General Tree Structure}

In order to ensure the integrity of the state of the system, the stored data
needs to be re-arranged and hashed in a {\tmem{modified Merkle Patricia
Tree}}, which hereafter we refer to as the {\tmem{{\tmstrong{Trie}}}}. This
rearrangment is necessary to be able to compute the Merkle hash of the whole
or part of the state storage, consistently and efficiently at any given time.

The Trie is used to compute the {\tmem{state root}}, $H_r$, (see Definition
\ref{defn-block-header}), whose purpose is to authenticate the validity of the
state database. Thus, the Polkadot Host follows a rigorous encoding algorithm
to compute the values stored in the trie nodes to ensure that the computed
Merkle hash, $H_r$, matches across the Polkadot Host implementations.

The Trie is a {\tmem{radix-16}} tree as defined in Definition
\ref{defn-radix-tree}. Each key value identifies a unique node in the tree.
However, a node in a tree might or might not be associated with a key in the
storage.

When traversing the Trie to a specific node, its key can be reconstructed by
concatenating the subsequences of the key which are stored either explicitly
in the nodes on the path or implicitly in their position as a child of their
parent.

To identify the node corresponding to a key value, $k$, first we need to
encode $k$ in a consistent with the Trie structure way. Because each node in
the trie has at most 16 children, we represent the key as a sequence of 4-bit
nibbles:

\begin{definition}
  For the purpose of labeling the branches of the Trie, the key $k$ is encoded
  to $k_{\tmop{enc}}$ using KeyEncode functions:
  \begin{equation}
    k_{\tmop{enc}} \assign (k_{\tmop{enc}_1}, \ldots, k_{\tmop{enc}_{2 n}})
    \assign \tmop{KeyEncode} (k) \label{key-encode-in-trie}
  \end{equation}
  such that:
  \[ \tmop{KeyEncode} (k) : \left\{ \begin{array}{lll}
       \mathbb{B}^{\nosymbol} & \rightarrow & \tmop{Nibbles}^4\\
       k \assign (b_1, \ldots, b_n) \assign & \mapsto & (b^1_1, b^2_1, b_2^1,
       b^2_2, \ldots, b^1_n, b^2_n)\\
       &  & \assign (k_{\tmop{enc}_1}, \ldots, k_{\tmop{enc}_{2 n}})
     \end{array} \right. \]
  where $\tmop{Nibble}^4$ is the set of all nibbles of 4-bit arrays and
  $b^1_i$ and $b^2_i$ are 4-bit nibbles, which are the big endian
  representations of $b_i$:
  \[ (b^1_i, b^2_i) \assign (b_i / 16, b_i \tmop{mod} 16) \]
  where mod is the remainder and / is the integer division operators.
\end{definition}

By looking at $k_{\tmop{enc}}$ as a sequence of nibbles, one can walk the
radix tree to reach the node identifying the storage value of $k$.

\subsection{Trie Structure}\label{sect-state-storage-trie-structure}

In this subsection, we specify the structure of the nodes in the Trie as well
as the Trie structure:

\begin{notation}
  We refer to the {\tmstrong{set of the nodes of Polkadot state trie}} by
  $\mathcal{N}.$ By $N \in \mathcal{N}$ to refer to an individual node in the
  trie.
\end{notation}

\begin{definition}
  \label{defn-nodetype}The State Trie is a radix-16 tree. Each Node in the
  Trie is identified with a unique key $k_N$ such that:
  \begin{itemizeminus}
    \item $k_N$ is the shared prefix of the key of all the descendants of $N$
    in the Trie.
  \end{itemizeminus}
  and, at least one of the following statements holds:
  \begin{itemizeminus}
    \item $(k_N, v)$ corresponds to an existing entry in the State Storage.
    
    \item N has more than one child.
  \end{itemizeminus}
  \tmverbatim{}Conversely, if $(k, v)$ is an entry in the State Trie then
  there is a node $N \in \mathcal{N}$ such that $k_N$=k.
\end{definition}

\begin{notation}
  A {\tmstrong{branch}} node is a node which has one child or more. A branch
  node can have at most 16 children. A {\tmstrong{leaf}} node is a childless
  node. Accordingly:
  \[ \begin{array}{c}
       \mathcal{N}_b \assign \left\{ N \in \mathcal{N}|N \text{is a branch
       node} \right\}\\
       \mathcal{N}_l \assign \left\{ N \in \mathcal{N}|N \text{is a leaf node}
       \right\}
     \end{array} \]
\end{notation}

For each node, part of $k_N$ is built while the trie is traversed from root to
$N$ part of $k_N$ is stored in $N$ as formalized in Definition
\ref{defn-node-key}.

\begin{definition}
  \label{defn-node-key}For any $N \in \mathcal{N}$, its key $k_N$ is divided
  into an {\tmstrong{aggregated prefix key}},
  {\tmstrong{$\tmop{pk}_N^{\tmop{Agr}}$}}, aggregated by Algorithm
  \ref{algo-aggregate-key} and a {\tmstrong{partial key}},
  {\tmstrong{$\tmop{pk}_N$}} of length $0 \leqslant l_{\tmop{pk}_N} \leqslant
  65535$ in nibbles such that:
  \[ \tmop{pk}_N \assign (k_{\tmop{enc}_i}, \ldots, k_{\tmop{enc}_{i +
     l_{\tmop{pk}_N}}}) \]
  where $\tmop{pk}_N$ is a suffix subsequence of $k_N$; $i$ is the length of
  $\tmop{pk}_N^{\tmop{Agr}}$ in nibbles and so we have:
  \[ \tmop{KeyEncode} (k_N) = \tmop{pk}_N^{\tmop{Agr}} | | \tmop{pk}_N =
     (k_{\tmop{enc}_1}, \ldots, k_{\tmop{enc}_{i - 1}}, k_{\tmop{enc}_i},
     k_{\tmop{enc}_{i + l_{\tmop{pk}_N}}}) \]
\end{definition}

Part of $\tmop{pk}_N^{\tmop{Agr}}$ is explicitly stored in $N$'s ancestors.
Additionally, for each ancestor, a single nibble is implicitly derived while
traversing from the ancestor to its child included in the traversal path using
the $\tmop{Index}_N$ function defined in Definition \ref{defn-index-function}.

\begin{definition}
  \label{defn-index-function}For $N \in \mathcal{N}_b$ and $N_c$ child of N,
  we define {\tmstrong{$\tmop{Index}_N$}} function as:
  \[ \begin{array}{cc}
       \tmop{Index}_N : & \left\{ N_c \in \mathcal{N}|N_c  \text{is a child of
       N} \right\} \rightarrow \tmop{Nibbles}^4_1\\
       & N_c \mapsto i 
     \end{array} \]
  such that
  \[ k_{N_c} = k_N | | i | | \tmop{pk}_{N_c} \]
\end{definition}

Assuming that $P_N$ is the path (see Definition \ref{defn-path-graph}) from
the Trie root to node $N$, Algorithm \ref{algo-aggregate-key} rigorously
demonstrates how to build $\tmop{pk}^{\tmop{Agr}}_N$ while traversing $P_N$.

\custombinding{1}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{1}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-aggregate-key}{\tmname{Aggregate-Key}}$(P_N : =
      (\tmop{TrieRoot} = N_1, \ldots, N_j = N))$
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

\begin{definition}
  \label{defn-node-value}A node $N \in \mathcal{N}$ stores the {\tmstrong{node
  value}}, {\tmstrong{$v_N$}}, which consists of the following concatenated
  data:
  \[ \begin{array}{|l|l|l|}
       \hline
       \tmop{Node} \tmop{Header} & \tmop{Partial} \tmop{key} & \tmop{Node}
       \tmop{Subvalue}\\
       \hline
     \end{array} \]
  Formally noted as:
  \[ v_N \assign \tmop{Head}_N | | \tmop{Enc}_{\tmop{HE}} (\tmop{pk}_N) | |
     \tmop{sv}_N \]
  where $\tmop{Head}_N$, $\tmop{pk}_N$, $\tmop{Enc}_{\tmop{nibbles}}$ and
  $\tmop{sv}_N$ are defined in Definitions \ref{defn-node-header},
  \ref{defn-node-key}, \ref{defn-hex-encoding} and \ref{defn-node-subvalue},
  respectively.
\end{definition}

\begin{definition}
  \label{defn-node-header}The {\tmstrong{node header}} of node $N$,
  $\tmop{Head}_N$, consists of $l + 1 \geqslant 1$ bytes $\tmop{Head}_{N, 1},
  \ldots, \tmop{Head}_{N, l + 1}$ such that:
  
  
  \[ \begin{array}{ll}
       \hline
       \tmop{Node} \tmop{Type} & \tmop{pk} \tmop{length}\\
       \hline
       {\tmop{Head}_{N, 1}^{6 - 7}}   & {\tmop{Head}_{N, 1}^{0 - 5}}  
     \end{array}  \begin{array}{|l|}
       \hline
       \tmop{pk} \tmop{length} \tmop{extra} \tmop{byte} 1\\
       \hline
       {\tmop{Head}_{N, 2}} \\
       \hline
     \end{array}  \begin{array}{|l|}
       \hline
       \tmop{pk} \tmop{key} \tmop{length} \tmop{extra} \tmop{byte} 2\\
       \hline
       \ldots .\\
       \hline
     \end{array} \ldots \begin{array}{|l|}
       \hline
       \tmop{pk} \tmop{length} \tmop{extra} \tmop{byte} l\\
       \hline
       {\tmop{Head}_{N, l + 1} } \\
       \hline
     \end{array} \]
  
  
  In which ${\tmop{Head}_{N, 1}^{6 - 7}}  $, the two most significant bits of
  the first byte of $\tmop{Head}_N$ are determined as follows:
  \[ {\tmop{Head}_{N, 1}^{6 - 7}}   \assign \left\{ \begin{array}{ll}
       00 & \tmop{Special} \tmop{case}\\
       01 & \tmop{Leaf} \tmop{Node}\\
       10 & \tmop{Branch} \tmop{Node} \tmop{with} k_N \nin \mathcal{K}\\
       11 & \tmop{Branch} \tmop{Node} \tmop{with} k_N \in \mathcal{K}
     \end{array} \right. \]
  where $\mathcal{K}$ is defined in Definition \ref{defn-stored-value}.
  
  ${\tmop{Head}_{N, 1}^{0 - 5}}  $, the 6 least significant bits of the first
  byte of $\tmop{Head}_N$ are defined to be:
  \[ {\tmop{Head}_{N, 1}^{0 - 5}}   \assign \left\{ \begin{array}{ll}
       \| \tmop{pk}_N \|_{\tmop{nib}} & \| \tmop{pk}_N \|_{\tmop{nib}} < 63\\
       63 & \| \tmop{pk}_N \|_{\tmop{nib}} \geqslant 63
     \end{array} \right. \]
  In which {\tmstrong{$\| \tmop{pk}_N \|_{\tmop{nib}}$}} is the length of
  $\tmop{pk}_N $ in number nibbles. $\tmop{Head}_{N, 2}, \ldots,
  \tmop{Head}_{N, l + 1}$ bytes are determined by Algorithm
  \ref{algo-pk-length}.
\end{definition}

\custombinding{2}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{2}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-pk-length}{\tmname{Partial-Key-Length-Encoding$\left(
      {\tmop{Head}_{N, 1}^{6 - 7}}  , \tmop{pk}_N \right)$}}
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

\subsection{Merkle Proof}\label{sect-merkl-proof}

To prove the consistency of the state storage across the network and its
modifications both efficiently and effectively, the Trie implements a Merkle
tree structure. The hash value corresponding to each node needs to be computed
rigorously to make the inter-implementation data integrity possible.

\

The Merkle value of each node should depend on the Merkle value of all its
children as well as on its corresponding data in the state storage. This
recursive dependancy is encompassed into the subvalue part of the node value
which recursively depends on the Merkle value of its children. Additionally,
as Section \ref{sect-child-trie-structure} clarifies, the Merkle proof of each
{\tmstrong{child trie}} must be updated first before the final Polkadot state
root can be calculated.

We use the auxilary function introduced in Definition
\ref{defn-children-bitmap} to encode and decode information stored in a branch
node.

\begin{definition}
  \label{defn-children-bitmap}Suppose $N_b, N_c \in \mathcal{N}$ and $N_c$ is
  a child of $N_b$. We define where bit $b_i : = 1$ if $N$ has a child with
  partial key $i$, therefore we define {\tmstrong{ChildrenBitmap}} functions
  as follows:
  \[ \begin{array}{cc}
       \tmop{ChildrenBitmap} : & \mathcal{N}_b \rightarrow \mathbb{B}_2\\
       & N \mapsto (b_{15}, \ldots, b_8, b_7, \ldots b_0)_2
     \end{array} \]
  where
  \[ b_i \assign \left\{ \begin{array}{cc}
       1 & \exists N_c \in \mathcal{N}: k_{N_c} = k_{N_b} | | i | |
       \tmop{pk}_{N_c}\\
       0 & \text{otherwise}
     \end{array} \right. \]
\end{definition}

\tmverbatim{}

\begin{definition}
  \label{defn-node-subvalue}For a given node $N$, the {\tmstrong{subvalue}} of
  $N$, formally referred to as $\tmop{sv}_N$, is determined as follows:
  \begin{itemize}
    \[ \begin{array}{l}
         \tmop{sv}_N \assign\\
         \left\{ \begin{array}{c}
           \tmop{StoredValue}_{\tmop{SC}}\\
           \nobracket \tmop{Enc} _{\tmop{SC}} (\tmop{ChildrenBitmap} (N)) \|
           \tmop{StoredValue}_{\tmop{SC}} \| \nobracket \tmop{Enc}_{\tmop{SC}}
           (H (N_{C_1})) \ldots \tmop{Enc}_{\tmop{SC}} (H (N_{C_n})) 
         \end{array} \right.\\
         \\
         \text{where the first variant is a leaf node and the second variant
         is a branch node.}\\
         \\
         \tmop{StoredValue}_{\tmop{SC}} \assign \left\{ \begin{array}{lll}
           \tmop{Enc}_{\tmop{SC}} (\tmop{StoredValue} (k_N)) &  & \text{if
           StoredValue(k\_N)=v}\\
           \tmmathbf{\phi} &  & \text{if
           StoredValue(k\_N)=\ensuremath{\tmmathbf{{\phi}}}}
         \end{array} \right.
       \end{array} \]
  \end{itemize}
\end{definition}

$N_{C_1} \ldots N_{C_n}$ with $n \leqslant 16$ are the children nodes of the
branch node $N$ and Enc\tmrsub{SC}, $\tmop{StoredValue}$, $H$, and
$\tmop{ChildrenBitmap} (N)$ are defined in Definitions \ref{sect-scale-codec},
\ref{defn-stored-value}, \ref{defn-merkle-value} and
\ref{defn-children-bitmap} respectively.

\

The Trie deviates from a traditional Merkle tree where node value, $v_N$ (see
Definition \ref{defn-node-value}) is presented instead of its hash if it
occupies less space than its hash.

\begin{definition}
  \label{defn-merkle-value}For a given node $N$, the {\tmstrong{Merkle value}}
  of $N$, denoted by $H (N)$ is defined as follows:
  \[ \begin{array}{ll}
       & H : \mathbb{B} \rightarrow \cup_{i \rightarrow 0}^{32}
       \mathbb{B}_{32}\\
       & H (N) : \left\{ \begin{array}{lcl}
         v_N &  & \|v_N \|< 32 \infixand N \neq R\\
         \tmop{Blake} 2 b (v_N) &  & \|v_N \| \geqslant 32 \infixor N = R
       \end{array} \right.
     \end{array} \]
  Where $v_N$ is the node value of $N$ defined in Definition
  \ref{defn-node-value} and $R$ is the root of the Trie. The {\tmstrong{Merkle
  hash}} of the Trie is defined to be $H (R)$.
\end{definition}

\section{Child Storage}\label{sect-child-storages}

As clarified in Section \ref{sect-state-storage}, the Polkadot state storage
implements a hash table for inserting and reading key-value entries. The child
storage works the same way but is stored in a separate and isolated
environment. Entries in the child storage are not directly accessible via
querying the main state storage.

\

The Polkadot Host supports as many child storages as required by Runtime and
identifies each separate child storage by its unique identifying key. Child
storages are usually used in situations where Runtime deals with multiple
instances of a certain type of objects such as Parachains or Smart Contracts.
In such cases, the execution of the Runtime entry might result in generating
repeated keys across multiple instances of certain objects. Even with repeated
keys, all such instances of key-value pairs must be able to be stored within
the Polkadot state.

\

In these situations, the child storage can be used to provide the isolation
necessary to prevent any undesired interference between the state of separated
instances. The Polkadot Host makes no assumptions about how child storages are
used, but provides the functionality for it. This is described in more detail
in the Host API, as described in Section \ref{sect-child-storages}.

\subsection{Child Tries}\label{sect-child-trie-structure}

The child trie specification is the same as the one described in Section
\ref{sect-state-storage-trie-structure}. Child tries have their own isolated
environment. Nonetheless, the main Polkadot state trie depends on them by
storing a node ($K_N, V_N$) which corresponds to an individual child trie.
Here, $K_N$ is the child storage key associated to the child trie, and $V_N$
is the Merkle value of its corresponding child trie computed according to the
procedure described in Section \ref{sect-merkl-proof}

\

The Polkadot Host APIs as defined in \ref{sect-child-storages} allows the
Runtime to provide the key $K_N$ in order to identify the child trie, followed
by a second key in order to identify the value within that child trie. Every
time a child trie is modified, the Merkle proof $V_N$ of the child trie stored
in the Polkadot state must be updated first. After that, the final Merkle
proof of the Polkadot state can be computed. This mechanism provides a proof
of the full Polkadot state including all its child states.

\tmverbatim{}

\

\begin{flushright}
  {\qed}
\end{flushright}

\

\chapter{State Transition}\label{chap-state-transit}

Like any transaction-based transition system, Polkadot's state is changed by
executing an ordered set of instructions. These instructions are known as
{\tmem{extrinsics}}. In Polkadot, the execution logic of the state-transition
function is encapsulated in a Runtime as defined in Definition
\ref{defn-state-machine}. For easy upgradability this Runtime is presented as
a Wasm blob. Nonetheless, the Polkadot Host needs to be in constant
interaction with the Runtime. The detail of such interaction is further
described in Section \ref{sect-entries-into-runtime}.

In Section \ref{sect-extrinsics}, we specify the procedure of the process
where the extrinsics are submitted, pre-processed and validated by Runtime and
queued to be applied to the current state.

To make state replication feasible, Polkadot journals and batches series of
its extrinsics together into a structure known as a {\tmem{block}}, before
propagating them to other nodes, similar to most other prominent distributed
ledger systems. The specification of the Polkadot block as well as the process
of verifying its validity are both explained in Section
\ref{sect-state-replication}.

\section{Interacting with the Runtime}\label{sect-entries-into-runtime}

The Runtime as defined in Definition \ref{defn-runtime} is the code
implementing the logic of the chain. This code is decoupled from the Polkadot
Host to make the the logic of the chain easily upgradable without the need to
upgrade the Polkadot Host itself. The general procedure to interact with the
Runtime is described in Algorithm \ref{algo-runtime-interaction}.

\custombinding{3}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{3}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-runtime-interaction}{\tmname{Interact-With-Runtime}}($F$:
      runtime entry to call,
      
      $H_b (B)$: Block hash indicating the state at the end of $B$,
      
      $A_1, A_2, \ldots, A_n$: arguments to be passed to the runtime entry)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

In this section, we describe the details upon which the Polkadot Host is
interacting with the Runtime. In particular, {\tmname{Set-State-At}} and
{\tmname{Call-Runtime-Entry}} procedures called in Algorithm
\ref{algo-runtime-interaction} are explained in Notation
\ref{nota-call-into-runtime} and Definition \ref{defn-set-state-at}
respectively. $R_B$ is the Runtime code loaded from $\mathcal{S}_B$, as
described in Notation \ref{nota-runtime-code-at-state}, and
$\mathcal{R}\mathcal{E}_B$ is the Polkadot Host API, as described in Notation
\ref{nota-host-api-at-state}.

\subsection{Loading the Runtime Code}\label{sect-loading-runtime-code}

The Polkadot Host expects to receive the code for the Runtime of the chain as
a compiled WebAssembly (Wasm) Blob. The current runtime is stored in the state
database under the key represented as a byte array:
\[ b \assign \text{3A,63,6F,64,65} \]
which is the ASCII byte representation of the string ``\tmverbatim{:code}''
(see Section \ref{sect-genesis-block}). As a result of storing the Runtime as
part of the state, the Runtime code itself becomes state sensitive and calls
to Runtime can change the Runtime code itself. Therefore the Polkadot Host
needs to always make sure to provide the Runtime corresponding to the state in
which the entry has been called. Accordingly, we introduce the following
notation to refer to the Runtime code at a specific state:

\begin{notation}
  \label{nota-runtime-code-at-state}By $R_B$, we refer to the Runtime code
  stored in the state storage at the end of the execution of block $B$.
\end{notation}

The initial Runtime code of the chain is provided as part of the genesis state
(see Section \ref{sect-genesis-block}) and subsequent calls to the Runtime
have the ability to, in turn, upgrade the Runtime by replacing this Wasm blob
with the help of the storage API (see Section \ref{sect-host-api}).

\subsection{Code Executor}\label{sect-code-executor}

The Polkadot Host executes the calls of Runtime entries inside a Wasm Virtual
Machine (VM), which in turn provides the Runtime with access to the Polkadot
Host API. This part of the Polkadot Host is referred to as the
{\tmem{{\tmstrong{Executor}}.}}

Definition \ref{nota-call-into-runtime} introduces the notation for calling
the runtime entry which is used whenever an algorithm of the Polkadot Host
needs to access the runtime.

\begin{notation}
  \label{nota-call-into-runtime} By
  \[ \text{{\tmname{Call-Runtime-Entry}}} \left( R, \mathcal{R}\mathcal{E},
     \text{\tmverbatim{Runtime-Entry}}, A, A_{\tmop{len}} \right) \]
  we refer to the task using the executor to invoke the
  \tmverbatim{Runtime-Entry} while passing an $A_1, \ldots, A_n$ argument to
  it and using the encoding described in Section
  \ref{sect-runtime-send-args-to-runtime-enteries}.
\end{notation}

It is acceptable behavior that the Runtime panics during execution of a
function in order to indicate an error. The Polkadot Host must be able to
catch that panic and recover from it.

\

In this section, we specify the general setup for an Executor that calls into
the Runtime. In Section \ref{sect-runtime-entries} we specify the parameters
and return values for each Runtime entry separately.

\subsubsection{Memory Management}\label{sect-memory-management}

The Polkadot Host is responsible for managing the WASM heap memory starting at
the exported symbol \tmverbatim{\_\_heap\_base} as a part of implementing the
allocator Host API (see Section \ref{sect-ext-allocator}) and the same
allocator should be used for any other heap allocation to be used by the
Polkadot Runtime.

The size of the provided WASM memory should be based on the value of the
\tmverbatim{:heappages} storage key (an unsigned 64-bit integer), where each
page has the size of 64KB. This memory shoule be made available to the
Polkadot Runtime for import under the symbol name \tmverbatim{memory}.

\subsubsection{Sending Data to a Runtime Entry
}\label{sect-runtime-send-args-to-runtime-enteries}

In general, all data exchanged between the Polkadot Host and the Runtime is
encoded using SCALE codec described in Section \ref{sect-scale-codec}.
Therefore all runtime entries have the following identical Wasm function
signatures:

\

\tmcodeinline[cpp]{\tmverbatim{}(func \$runtime\_entry (param \$data i32)
(param \$len i32) (result i64))}

\

In each invocation of a Runtime entry, the argument(s) which are supposed to
be sent to the entry, need to be SCALE encoded into a byte array $B$ (see
Definition \ref{sect-scale-codec}) and copied into a section of Wasm shared
memory managed by the shared allocator described in Section
\ref{sect-memory-management}.

When the Wasm method \tmverbatim{runtime\_entry}, corresponding to the entry,
is invoked, two \tmverbatim{i32} integers are passed as arguments. The first
argument \tmverbatim{data} is set to the memory adress of the byte array $B$
in Wasm memory. The second argument \tmverbatim{len} sets the length of the
encoded data stored in $B$.

\subsubsection{Receiving Data from a Runtime
Entry}\label{sect-runtime-return-value}

The value which is returned from the invocation is an \tmverbatim{i64}
integer, representing two consecutive \tmverbatim{i32} integers in which the
least significant one indicates the pointer to the offset of the result
returned by the entry encoded in SCALE codec in the memory buffer. The most
significant one provides the size of the blob.

\subsubsection{Handling Runtimes update to the
State}\label{sect-handling-runtime-state-update}

In order for the Runtime to carry on various tasks, it manipulates the current
state by means of executing calls to various Polkadot Host APIs (see Appendix
\ref{sect-host-api}). It is the duty of Host APIs to determine the context in
which these changes should persist. For example, if Polkdot Host needs to
validate a transaction using
\tmverbatim{TaggedTransactionQueue\_validate\_transaction} entry (see Section
\ref{sect-rte-validate-transaction}), it needs to sandbox the changes to the
state just for that Runtime call and prevent the global state of the system
from being influence by the call to such a Runtime entry. This includes
reverting the state of function calls which return errors or panic.



As a rule of thumb, any state changes resulting from Runtime enteries are not
persistant with the exception of state changes resulting from calling
\tmverbatim{Core\_execute\_block} (see Section
\ref{sect-rte-core-execute-block}) while Polkadot Host is importing a block
(see Section \ref{sect-block-validation}).

\

For more information on managing multiple variant of state see Section
\ref{sect-managing-multiple-states}.

\section{Extrinsics}\label{sect-extrinsics}

The block body consists of an array of extrinsics. In a broad sense,
extrinsics are data from outside of the state which can trigger state
transitions. This section describes extrinsics and their inclusion into
blocks.

\subsection{Preliminaries}

The extrinsics are divided into two main categories defined as follows:

\begin{definition}
  {\tmstrong{Transaction extrinsics}} are extrinsics which are signed using
  either of the key types described in section \ref{sect-cryptographic-keys}
  and broadcasted between the nodes. {\tmstrong{Inherent extrinsics}} are
  unsigned extrinsics which are generated by Polkadot Host and only included
  in the blocks produced by the node itself. They are broadcasted as part of
  the produced blocks rather than being gossiped as individual extrinsics.
\end{definition}

The Polkadot Host does not specify or limit the internals of each extrinsics
and those are defined and dealt with by the Runtime (defined in Definition
\ref{defn-runtime}). From the Polkadot Host point of view, each extrinsics is
simply a SCALE-encoded blob as defined in Section \ref{sect-scale-codec}.

\subsection{Transactions}

Transaction are submitted and exchanged through {\tmem{Transactions}} network
messages (see Section \ref{sect-msg-transactions}). Upon receiving a
Transactions message, the Polkadot Host decodes the SCALE-encoded blob and
splits it into individually SCALE-encoded transactions.

Alternative transaction can be submitted to the host by offchain worker
through the \tmverbatim{ext\_offchain\_submit\_transaction} Host API, defined
in Section \ref{sect-ext-offchain-submit-transaction}.

Any new transaction should be submitted to the
\tmverbatim{validate\_transaction} Runtime function, defined in Section
\ref{sect-rte-validate-transaction}. This will allow the Polkadot Host to
check the validity of the received transaction against the current stat and if
it should be gossiped to other peers. If \tmverbatim{validate\_transaction}
considers the submitted transaction as valid, the Polkadot Host should store
it for inclusion in future blocks. The whole process of handeling new
transactions is described in more detail by Algorithm
\ref{algo-validate-transactions}.

Additionally valid transactions that are supposed to be gossiped are
propagated to connected peers of the Polkadot Host. While doing so the
Polkadot Host should keep track of peers already aware of each transaction.
This includes peers which have already gossiped the transaction to the node as
well as those to whom the transaction has already been sent. This behavior is
mandated to avoid resending duplicates and unnecessarily overloading the
network. To that aim, the Polkadot Host should keep a {\tmem{transaction
pool{\index{transaction pool}}}} and a {\tmem{transaction
queue}}{\index{transaction queue}} defined as follows:

\begin{definition}
  \label{defn-transaction-queue}The {\tmstrong{Transaction Queue}} of a block
  producer node, formally referred to as $\tmop{TQ}$ is a data structure which
  stores the transactions ready to be included in a block sorted according to
  their priorities (Definition \ref{sect-msg-transactions}). The
  {\tmstrong{Transaction Pool}}, formally referred to as $\tmop{TP}$, is a
  hash table in which the Polkadot Host keeps the list of all valid
  transactions not in the transaction queue.
\end{definition}

Algorithm \ref{algo-validate-transactions} updates the transaction pool and
the transaction queue according to the received message:

\custombinding{4}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{4}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-validate-transactions}{\tmname{Validate-Transactions-and-Store}}($M_T
      :$Transaction Message)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

In which
\begin{itemizeminus}
  \item $\text{{\tmname{Dec\tmrsub{Sc}}}}$ decodes the SCALE encoded message.
  
  \item {\tmname{Longest-Chain}} is defined in Definition
  \ref{defn-longest-chain}.
  
  \item \tmverbatim{TaggedTransactionQueue\_validate\_transaction} is a
  Runtime entry specified in Section \ref{sect-rte-validate-transaction} and
  Requires(R), Priority(R) and Propagate(R) refer to the corresponding fields
  in the tuple returned by the entry when it deems that $T$ is valid.
  
  \item {\tmname{Provided-Tags}}(T) is the list of tags that transaction $T$
  provides. The Polkadot Host needs to keep track of tags that transaction $T$
  provides as well as requires after validating it.
  
  \item {\tmname{Insert-At(}}$\tmop{TQ}, T, \tmop{Requires} (R),
  \tmop{Priority} (R)$) places $T$ into $\tmop{TQ}$ approperietly such that
  the transactions providing the tags which $T$ requires or have higher
  priority than $T$ are ahead of $T$.
  
  \item {\tmname{Maintain-Transaction-Pool}} is described in Algorithm
  \ref{algo-maintain-transaction-pool}.
  
  \item {\tmname{ShouldPropagate}} indictes whether the transaction should be
  propagated based on the \tmverbatim{Propagate} field in the
  \tmverbatim{ValidTransaction} type as defined in Definition
  \ref{defn-valid-transaction}, which is returned by
  \tmverbatim{TaggedTransactionQueue\_validate\_transaction}.
  
  \item {\tmname{Propagate(}}$T$) sends $T$ to all connected peers of the
  Polkadot Host who are not already aware of $T$.
\end{itemizeminus}
\custombinding{5}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{5}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-maintain-transaction-pool}{\tmname{Maintain-Transaction-Pool}}
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

\subsection{Inherents}\label{sect-inherents}

Inherents are unsigned extrinsic inserted into a block by the block author and
as a result are not stored in the transaction pool or gossiped across the
network. Instead they are generated by the Polkadot Host by passing the
required inherent data, as listed in Table \ref{tabl-inherent-data}, to the
Runtime method {\tmsamp{\tmverbatim{BlockBuilder\_inherent\_extrinsics}}}
(Section \ref{defn-rt-builder-inherent-extrinsics}). The then returned
extrinsics should be included in the current block as explained in Algorithm
\ref{algo-build-block}. {\todo{define uncles}}

\begin{table}[h]
  \begin{tabular}{lll}
    \hline
    Identifier & Value type  & Description\\
    \hline
    timstap0 & u64 & Unix epoch time in number of milliseconds\\
    uncles00 & array of block headers & Provides a list of potential uncle
    block headers$^{\ref{defn-block-header}}$ for a given block\\
    \hline
  \end{tabular}
  \caption{\label{tabl-inherent-data}List of inherent data}
\end{table}

\begin{definition}
  \label{defn-inherent-data}{\tmname{Inherent-Data }}is a hashtable
  (Definition \ref{defn-scale-list}), an array of key-value pairs consisting
  of the inherent 8-byte identifier and its value, representing the totality
  of inherent extrinsics included in each block. The entries of this hash
  table which are listed in Table \ref{tabl-inherent-data} are collected or
  generated by the Polkadot Host and then handed to the Runtime for inclusion
  as dercribed in Algorithm \ref{algo-build-block}.
\end{definition}

\section{State Replication}\label{sect-state-replication}

Polkadot nodes replicate each other's state by syncing the history of the
extrinsics. This, however, is only practical if a large set of transactions
are batched and synced at the time. The structure in which the transactions
are journaled and propagated is known as a block (of extrinsics) which is
specified in Section \ref{sect-block-format}. Like any other replicated state
machines, state inconsistency can occure between Polkadot replicas. Section
\ref{sect-managing-multiple-states} is giving an overview of how a Polkadot
Host node manages multiple variants of the state.

\subsection{Block Format}\label{sect-block-format}

A Polkadot block consists a \tmtextit{block header} (Section
\ref{sect-block-header}) and a \tmtextit{block body} (Section
\ref{sect-block-body}). The \tmtextit{block body} in turn is made up out of a
\tmtextup{list of \tmtextit{extrinsics}}, which represent the generalization
of the concept of {\tmem{transactions}}. \tmtextit{Extrinsics} can contain any
set of external data the underlying chain wishes to validate and track.

\subsubsection{Block Header}\label{sect-block-header}

The block header is designed to be minimalistic in order to allow efficienct
handeling by light clients. It is defined formally as follows:

\begin{definition}
  \label{defn-block-header}The {\tmstrong{header of block B}},
  {\tmstrong{$\tmop{Head} (B)$}} is a 5-tuple containing the following
  elements:
  \begin{itemize}
    \item \tmtextbf{{\tmsamp{parent\_hash:}}} formally indicated as
    $\tmstrong{\text{H\tmrsub{p}}}$, is the 32-byte Blake2b hash (Section
    \ref{sect-blake2}) of the SCALE encoded parent block header as defined in
    Definition \ref{defn-block-header-hash}.
    
    \item {\tmstrong{{\tmsamp{number:}}}} formally indicated as
    {\tmstrong{$H_i$}}, is an integer, which represents the index of the
    current block in the chain. It is equal to the number of the ancestor
    blocks. The genesis state has number 0.
    
    \item {\tmstrong{{\tmsamp{state\_root:}}}} formally indicated as
    {\tmstrong{$H_r$}}, is the root of the Merkle trie, whose leaves implement
    the storage for the system.
    
    \item {\tmstrong{{\tmsamp{extrinsics\_root:}}}} is the field which is
    reserved for the Runtime to validate the integrity of the extrinsics
    composing the block body. For example, it can hold the root hash of the
    Merkle trie which stores an ordered list of the extrinsics being validated
    in this block. The {\tmsamp{extrinsics\_root}} is set by the runtime and
    its value is opaque to the Polkadot Host. This element is formally
    referred to as {\tmstrong{$H_e$}}.
    
    \item {\tmstrong{{\tmsamp{digest:}}}} this field is used to store any
    chain-specific auxiliary data, which could help the light clients interact
    with the block without the need of accessing the full storage as well as
    consensus-related data including the block signature. This field is
    indicated as {\tmstrong{$H_d$}} and its detailed format is defined in
    Definition \ref{defn-digest}
  \end{itemize}
\end{definition}

\begin{definition}
  \label{defn-digest}The header {\tmstrong{digest}} of block $B$ formally
  referred to by {\tmstrong{$H_d (B)$}} is an array of {\tmstrong{digest
  items}} $H^i_d$'s , known as digest items of varying data type (see
  Definition \ref{defn-varrying-data-type}) such that
  \[ H_d (B) : = H^1_d, \ldots, H^n_d \]
  where each digest item can hold one of the type described in Table
  \ref{tabl-digest-items}:
  
  \begin{center}
    \tmfloat{h}{small}{table}{
    {\center{\begin{tabular}{|r|l|l|}
      \hline
      Type Id & Type name & sub-components \\
      \hline
      $2$ & Changes trie root & $\mathbb{B}_{32}$\\
      6 & Pre-Runtime & $E_{\tmop{id}}, \mathbb{B}$\\
      4 & Consensus Message & $E_{\tmop{id}}, \mathbb{B}$\\
      5 & Seal  & $E_{\tmop{id}}, \mathbb{B}$\\
      \hline
    \end{tabular}}}
    }{\label{tabl-digest-items}The detail of the varying type that a digest
    item can hold.}
  \end{center}
  
  \
  
  Where $E_{\tmop{id}}$ is the unique consensus engine identifier defined in
  Section \ref{defn-consensus-message-digest} and
  \begin{itemizedot}
    \item {\tmstrong{Changes trie root}} contains the root of the Changes Trie
    at block $B$, as described in Section \ref{sect-changes-trie}. Note that
    this is future-reserved and currently {\tmstrong{not}} used in Polkadot.
    
    \item {\tmstrong{Pre-runtime}} digest items represent messages from a
    consensus engine to the Runtime (e.g. see Definition
    \ref{defn-babe-header}).
    
    \item {\tmstrong{Consensus}} \tmtextbf{Message} digest items represent
    messages from the Runtime to the consensus engine (see Section
    \ref{sect-consensus-message-digest}).
    
    \item {\tmstrong{Seal}} is the data produced by the consensus engine and
    proving the authorship of the block producer. In particular, the Seal
    digest item must be the last item in the digest array and must be stripped
    off by the Polkadot Host before the block is submitted to any Runtime
    function including for validation. The Seal must be added back to the
    digest afterward. The detail of the Seal digest item is laid out in
    Definition \ref{defn-babe-seal}.
  \end{itemizedot}
\end{definition}

\begin{definition}
  \label{defn-block-header-hash}The {\tmstrong{block header hash of block
  $B$}}, {\tmstrong{$H_h (B)$}}, is the hash of the header of block $B$
  encoded by simple codec:
  \[ H_h (B) \assign \tmop{Blake} 2 b (\tmop{Enc}_{\tmop{SC}} (\tmop{Head}
     (B))) \]
\end{definition}

\subsubsection{Justified Block Header}\label{sect-justified-block-header}

The Justified Block Header is provided by the consensus engine and presented
to the Polkadot Host, for the block to be appended to the blockchain. It
contains the following parts:
\begin{itemize}
  \item {\tmstrong{{\tmsamp{{\tmstrong{block\_header}}}}}} the complete block
  header as defined in Section \ref{block} and denoted by $\tmop{Head} (B)$.
  
  \item {\tmstrong{{\tmsamp{justification}}}}: as defined by the consensus
  specification indicated by $\tmop{Just} (B)$ as defined in Definition
  \ref{defn-grandpa-justification}.
  
  \item {\tmstrong{{\tmsamp{authority Ids}}}}: This is the list of the Ids of
  authorities, which have voted for the block to be stored and\tmverbatim{} is
  formally referred to as $A (B)$. An authority Id is 256-bit.
\end{itemize}
\subsubsection{Block Body}\label{sect-block-body}

The Block Body consists of an sequence of extrinsics, each encoded as a byte
array. The content of an extrinsic is completely opaque to the Polkadot Host.
As such, from the point of the Polkadot Host, and is simply a SCALE encoded
array of byte arrays. Formally:

\begin{definition}
  \label{defn-block-body}The {\tmstrong{body of Block}} $B$ represented as
  {\tmstrong{$\tmop{Body} (B)$}} is defined to be
  \[ \tmop{Body} (B) \assign \tmop{Enc}_{\tmop{SC}} (E_1, \ldots, E_n) \]
  Where each $E_i \in \mathbb{B}$ is a SCALE encoded extrinsic.
\end{definition}

\subsection{Importing and Validating
Block}\label{sect-block-validation}\label{sect-block-submission}

Block validation is the process by which a node asserts that a block is fit to
be added to the blockchain. This means that the block is consistent with the
current state of the system and transitions to a new valid state.

\

New blocks can be received by the Polkadot Host via other peers (see Section
\ref{sect-msg-block-request}) or from the Host's own consensus engine (see
Section \ref{sect-block-production}). Both the Runtime and the Polkadot Host
then need to work together to assure block validity. A block is deemed valid
if the block author had authorship rights for the slot in which the block was
produce as well as if the transactions in the block constitute a valid
transition of states. The former criterion is validated by the Polkadot Host
according to the block production consensus protocol. The latter can be
verified by the Polkadot Host invoking \tmverbatim{Core\_execute\_block} entry
into the Runtime as defined in section \ref{sect-rte-core-execute-block} as a
part of the validation process. Any state changes created by this function on
successful execution are persisted.

\

The Polkadot Host implements the following procedure to assure the validity
of the block:

\custombinding{6}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{6}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-import-and-validate-block}{\tmname{Import-and-Validate-Block($B,
      \tmop{Just} (B)$)}}
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

In which
\begin{itemizeminus}
  \item {\tmname{Remove-Seal}} removes the Seal digest from the block as
  described in Definition \ref{defn-digest} before submitting it to the
  Runtime.
  
  \item {\tmname{Add-Seal}} adds the Seal digest back to the block as
  described in Definition \ref{defn-digest} for later propagation.
  
  \item {\tmname{Persist-State}} implies the persistence of any state changes
  created by \tmverbatim{Core\_execute\_block} on successful execution.
  
  \item PBT is the pruned block tree defined in Definition
  \ref{defn-block-tree}.
  
  \item {\tmname{Verify-Authorship-Right}} is part of the block production
  consensus protocol and is described in Algorithm
  \ref{algo-verify-authorship-right}.
  
  \item \tmtextit{Finalized block} and \tmtextit{finality} is defined in
  Section \ref{sect-finality}.
\end{itemizeminus}
\subsection{Managaing Multiple Variants of
State}\label{sect-managing-multiple-states}

Unless a node is committed to only update its state according to the finalized
block (See Definition \ref{defn-finalized-block}), it is inevitable for the
node to store multiple variants of the state (one for each block). This is,
for example, necessary for nodes participating in the block production and
finalization.

While the state trie structure described in Section
\ref{sect-state-storage-trie-structure} facilitates and optimizes storing and
switching between multiple variants of the state storage, the Polkadot Host
does not specify how a node is required to accomplish this task. Instead, the
Polkadot Host is required to implement {\tmname{Set\tmverbatim{}-State-At}}
operation which behaves as defined in Definition \ref{defn-set-state-at}:

\begin{definition}
  \label{defn-set-state-at}The function
  \[ \text{{\tmname{{\tmstrong{Set-State-At($\tmmathbf{B}$)}}}}} \]
  in which $B$ is a block in the block tree (See Definition
  \ref{defn-block-tree}), sets the content of state storage equal to the
  resulting state of executing all extrinsics contained in the branch of the
  block tree from genesis till block B including those recorded in Block B.
\end{definition}

For the definition of the state storage see Section \ref{sect-state-storage}.

\subsection{Changes Trie}\label{sect-changes-trie}

{\todo{NOTE: Changes Tries are still work-in-progress and are currently
{\tmstrong{not}} used in Polkadot. Additionally, the implementation of Changes
Tries might change considerably.}}

\

Polkadot focuses on light client friendliness and therefore implements
functionalities that allows identifying changes in the state of the blockchain
without the requirement to search through the entire chain. The
{\tmstrong{Changes Trie}} is a radix-16 tree data structure as defined in
Definition \ref{defn-radix-tree} and maintained by the Polkadot Host. It
stores different types of storage changes made by each individual block
separately.

\

The primary method for generating the Changes Trie is provided to the Runtime
with the \tmverbatim{ext\_storage\_changes\_root} Host API as described in
Section \ref{sect-ext-storage-changes-root}. The Runtime calls that function
shortly before finalizing the block, the Polkadot Host must then generate the
Changes Trie based on the storage changes which occured during block
production or execution. In order to provide this API function, it is
imperative that the Polkadot Host implements a mechanism to keep track of the
changes created by individual blocks, as mentioned in Sections
\ref{sect-state-storage} and \ref{sect-managing-multiple-states}.

The Changes Trie stores three different types of changes.

\begin{definition}
  The {\tmstrong{inserted key-value pair stored in the nodes of Changes Trie}}
  is formally defined as:
\end{definition}
\[ (K_C, V_C) \]
Where $K_C$ is a SCALE-encoded Tuple
\[ \tmop{Enc}_{\tmop{sc}} \left( \left( {{\tmop{Type}_{V_C}} } , H_i (B_i), K
   \right) \right) \]
and
\[ V_C = \tmop{Enc}_{\tmop{SC}} (C_{\tmop{value}}) \]
is a SCALE encoded byte array.

Furthermore, $K$ represents the changed storage key, $H_i (B_i)$ refers to the
block number at which this key is inserted into the Changes Trie (See
Definition \ref{defn-block-header}) and $\tmop{Type}_{V_C}$ is an index
defining the type \ $C_{\tmop{Value}}$ according to Table
\ref{table-changes-trie-key-types}.{\hspace*{\fill}}

\begin{table}[h]
  \begin{tabular}{lll}
    \hline
    {\tmstrong{Type}} & {\tmstrong{Description}} &
    {\tmstrong{$C_{\tmop{Value}}$}}\\
    \hline
    1 & list of extrinsics indices (section
    \ref{sect-changes-trie-extrinsics-pairs}) & $\{ e_i, \ldots, e_k \}$\\
    & where $e_i$ refers to the index of the extrinsic within the block & \\
    \hline
    2 & list of block numbers (section \ref{sect-changes-trie-block-pairs}) &
    $\{ H_i (B_k), \ldots, H_i (B_m) \}$\\
    \hline
    3 & Child Changes Trie (section \ref{sect-changes-trie-child-trie-pair}) &
    $H_r \left( \text{{\tmname{Child-Changes-Trie}}} \right)$\\
    \hline
  \end{tabular}
  
  \
  \caption{\label{table-changes-trie-key-types}Possible types of keys of
  mappings in the Changes Trie}
\end{table}

The Changes Trie itself is not part of the block, but a separately maintained
database by the Polkadot Host. The Merkle proof of the Changes Trie must be
included in the block digest as described in Definition \ref{defn-digest} and
gets calculated as described in section \ref{sect-merkl-proof}. The root
calculation only considers pairs which were generated on the individual block
and does not consider pairs which were generated at previous blocks.

\

{\todo{This seperately maintained database by the Polkadot Host is intended
to be used by ``proof servers'', where its implementation and behavior has not
been fully defined yet. This is considered future-reserved}}

\

As clarified in the individual sections of each type, not all of those types
get generated on every block. But if conditions apply, all those different
types of pairs get inserted into the same Changes Trie, therefore only one
Changes Trie Root gets generated for each block.

\subsubsection{Key to extrinsics
pairs}\label{sect-changes-trie-extrinsics-pairs}

This key-value pair stores changes which occure in an individual block. Its
value is a SCALE encoded array containing the indices of the extrinsics that
caused any changes to the specified key. The key-value pair is defined as
(clarified in section \ref{sect-changes-trie}):
\[ (1, H_i (B_i), K) \rightarrow \{ e_i, \ldots, e_k \} \]
The indices are unsigned 32-bit integers and their values are based on the
order in which each extrinsics appears in the block (indexing starts at 0).
The Polkadot Host generates those pairs for every changed key on each and
every block. Child storages have their own Changes Trie, as described in
section \ref{sect-changes-trie-child-trie-pair}.

\

{\todo{clarify special key value of 0xffffffff}}

\subsubsection{Key to block pairs}\label{sect-changes-trie-block-pairs}

This key-value pair stores changes which occured in a certain range of blocks.
Its value is a SCALE encoded array containing block numbers in which
extrinsics caused any changes to the specified key. The key-value pair is
defined as (clarified in section \ref{sect-changes-trie}):
\[ (2, H_i (B_i), K) \rightarrow \{ H_i (B_k), \ldots, H_i (B_m) \} \]
The block numbers are represented as unsigned 32-bit integers. There are
multiple ``levels'' of those pairs, and the Polkadot Host does
{\tmstrong{not}} generate those pairs on every block. The genesis state
contains the key \tmverbatim{:changes\_trie} where its unsigned 64-bit value
is a tuple of two 32-bit integers:
\begin{itemizedot}
  \item \tmverbatim{interval} - The interval (in blocks) at which those pairs
  should be created. If this value is less or equal to 1 it means that those
  pairs are not created at all.
  
  \item \tmverbatim{levels} - The maximum number of ``levels'' in the
  hierarchy. If this value is 0 it means that those pairs are not created at
  all.
\end{itemizedot}
For each level from 1 to \tmverbatim{levels}, the Polkadot Host creates those
pairs on every \tmverbatim{$\text{interval\tmrsup{level}\tmverbatim{}}$}-nth
block, formally applied as:

\custombinding{7}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{7}}}{\smallskip}
    
    \begin{tmindent}
      {\tmname{Key-To-Block-Pairs}}($B_i$, $I$: interval, $L :$levels
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}
\begin{itemizedot}
  \item $B_i$ implies the block at which those pairs gets inserted into the
  Changes Trie.
  
  \item {\tmname{Insert-Blocks}} - Inserts every block number within the range
  $H_i (B_i) - I^l + 1$ to $H_i (B_i)$ in which any extrinsic changed the
  specified key.
\end{itemizedot}


For example, let's say \tmverbatim{interval} is set at \tmverbatim{4} and
\tmverbatim{levels} is set at \tmverbatim{3}. This means there are now three
levels which get generated at three different occurences:
\begin{enumeratenumeric}
  \item {\tmstrong{Level 1}} - Those pairs are generated at every
  $\text{{\tmstrong{4\tmrsup{1}}}}$-nth block, where the pair value contains
  the block numbers of every block that changed the specified storage key.
  This level only considers block numbers of the last four ($= 4^1$) blocks.
  \begin{itemizedot}
    \item Example: this level occurs at block 4, 8, 12, 16, 32, etc.
  \end{itemizedot}
  \item {\tmstrong{Level 2}} - Those pairs are generated at every
  $\text{{\tmstrong{4\tmrsup{2}}}}$-nth block, where the pair value contains
  the block numbers of every block that changed the specified storage key.
  This level only considers block numbers of the last 16 ($= 4^2$) blocks.
  \begin{itemizedot}
    \item Example: this level occurs at block 16, 32, 64, 128, 256, etc.
  \end{itemizedot}
  \item {\tmstrong{Level 3}} - Those pairs are generated at every
  \text{$\text{{\tmstrong{4\tmrsup{3}}}}$}-nth block, where the pair value
  contains the block numbers of every block that changed the specified storage
  key. this level only considers block number of the last 64 ($= 4^3$) blocks.
  \begin{itemizedot}
    \item Example: this level occurs at block 64, 128, 196, 256, 320, etc.
  \end{itemizedot}
\end{enumeratenumeric}
\subsubsection{Key to Child Changes Trie
pairs}\label{sect-changes-trie-child-trie-pair}

The Polkadot Host generates a separate Changes Trie for each child storage,
using the same behavior and implementation as describe in section
\ref{sect-changes-trie-extrinsics-pairs}. Additionally, the changed child
storage key gets inserted into the primary, non-Child Changes Trie where its
value is a SCALE encoded byte array containing the Merkle root of the Child
Changes Trie. The key-value pair is defined as:
\[ (3, H_i (B_i), K) \rightarrow H_r \left(
   \text{{\tmname{Child-Changes-Trie}}} \right) \]
The Polkadot Host creates those pairs for every changes child key for each and
every block.

\

\begin{flushright}
  {\qed}
\end{flushright}

\

\chapter{Networking}\label{sect-networking}

\tmtextbf{Chapter Status:} This chapter in its current form is incomplete and
considered work in progress. Authors appreciate receiving request for
clarification or any reports regarding deviation from the current Polkadot
network protocol. This can be done through filing an issue in Polkadot
Specification repository {\cite{w3f_polkadot-spec}}.

\section{Introduction}

The Polkadot network is decentralized and does not rely on any central
authority or entity for achieving its fullest potential of provided
functionality. The networking protocol is based on a family of open protocols,
including protocol implemented \tmverbatim{libp2p} e.g. the distributed
Kademlia hash table which is used for peer discovery.

This chapter walks through the behaviour of the networking implementation of
the Polkadot Host and defines the network messages. The implementation details
of the \tmverbatim{libp2p} protocols used are specified in external sources as
described in Section \ref{sect-networking-external-docs}.

\section{External Documentation}\label{sect-networking-external-docs}

Complete specification of the Polkadot networking protocol relies on the
following external protocols:
\begin{itemize}
  \item \href{https://github.com/libp2p/specs}{libp2p} - \tmverbatim{libp2p}
  is a modular peer-to-{\withbib{bib}{{\withbib{bib}{}}}}peer networking stack
  composed of many modules and different parts. \tmverbatim{libp2p} includes
  the multiplexing protocols \tmverbatim{mplex} and \tmverbatim{yamux}.
  
  \item \href{https://docs.libp2p.io/concepts/addressing/}{libp2p addressing}
  - The Polkadot Host uses the \tmverbatim{libp2p} addressing system to
  identify and connect to peers.
  
  \item \href{https://en.wikipedia.org/wiki/Kademlia}{Kademlia} -
  \tmverbatim{Kademlia} is a distributed hash table for decentralized
  peer-to-peer networks. The Polkadot Host uses Kademlia for peer discovery.
  
  \item \href{https://noiseprotocol.org/}{Noise} - The Noise protocol is a
  framework for building cryptographic protocols. The Polkadot Host uses Noise
  to establish the encryption layer to remote peers.
  
  \item
  \href{https://docs.libp2p.io/concepts/stream-multiplexing/#mplex}{mplex} -
  \tmverbatim{mplex} is a multiplexing protocol developed by
  \tmverbatim{libp2p}. The protocol allows dividing a connection to a peer
  into multiple substreams, each substream serving a specific purpose.
  Generally, Polkadot Host implementers are encouraged to prioritize
  implementing \tmverbatim{yamux}, since it is the de-facto standard in
  Polkadot. \tmverbatim{mplex} is only required to communicate with
  \href{https://github.com/libp2p/js-libp2p}{js-lip2p}.
  
  \item
  \href{https://docs.libp2p.io/concepts/stream-multiplexing/#yamux}{yamux} -
  \tmverbatim{yamux} is a multiplexing protocol like \tmverbatim{mplex} and
  developed by HashiCorp. It is the de-facto standard for the Polkadot Host.
  This protocol should be prioritized over \tmverbatim{mplex}. Section
  \ref{sect-protocols-substreams} describes the subprotocol in more detail.
  
  \item
  \href{https://developers.google.com/protocol-buffers/docs/reference/proto3-spec}{Protocol
  Buffers} - Protocol Buffers is a language-neutral, platform-neutral
  mechanism for serializing structured data and is developed by Google. The
  Polkadot Host uses Protocol Buffers to serialize specific messages, as
  clarified in Section \ref{sect-network-messages}.
\end{itemize}

\section{Node Identities}

Each Polkadot Host node maintains an ED25519 key pair which is used to
identify the node. The public key is shared with the rest of the network
allowing the nodes to establish secure communication channels.

Each node must have its own unique ED25519 key pair. When two or more nodes
use the same key, the network will interpret those nodes as a single node,
which will result in undefined behaviour and can result in equivocation.
Furthermore, the node's \tmverbatim{PeerId} as defined in Definition
\ref{defn-peer-id} is derived from its public key. \tmverbatim{PeerId}
(\ref{defn-peer-id}) is used to identify each node when they are discovered in
the course of the discovery mechanism described in Section
\ref{sect-discovery-mechanism}.

\begin{definition}
  \label{defn-peer-id}The Polkadot node's \tmverbatim{PeerId}, formally
  referred to as $P_{\tmop{id}}$, is derived from the ED25519 public key and
  is structured as defined in the libp2p specification
  (\url{https://docs.libp2p.io/concepts/peer-id/}).
\end{definition}

\section{Discovery mechanism}\label{sect-discovery-mechanism}

The Polkadot Host uses various mechanisms to find peers within the network, to
establish and maintain a list of peers and to share that list with other peers
from the network as follows:
\begin{itemize}
  \item {\tmstrong{Bootstrap nodes}} are hard-coded node identities and
  addresses provided by the genesis state specification as described in
  Appendix \ref{sect-genesis-block}.
  
  \item {\tmstrong{mDNS}} is a protocol that performs a broadcast to the local
  network. Nodes that might be listening can respond to the broadcast.
  \href{https://github.com/libp2p/specs/blob/master/discovery/mdns.md}{The
  libp2p mDNS specification} defines this process in more detail. This
  protocol is an optional implementation detail for Polkadot Host implementers
  and is not required to participate in the Polkadot network.
  
  \item {\tmstrong{Kademlia requests}} invoking Kademlia
  \tmverbatim{FIND\_NODE} requests, where nodes respond with their list of
  available peers. Kademlia requests are performed on a specific substream as
  described in Section \ref{sect-protocols-substreams}.
\end{itemize}
\section{Connection establishment}\label{sect-connection-establishment}

Polkadot nodes connect to peers by establishing a TCP connection. Once
established, the node initiates a handshake with the remote peers on the
encryption layer. An additional layer on top of the encryption layer, known as
the multiplexing layer, allows a connection to be split into substreams, as
described by the
\href{https://docs.libp2p.io/concepts/stream-multiplexing/#yamux}{yamux
specification}, either by the local or remote node.

The Polkadot node supports two types of substream protocols. Section
\ref{sect-protocols-substreams} describes the usage of each type in more
detail:
\begin{itemizedot}
  \item {\tmstrong{Request-Response substreams}}: After the protocol is
  negotiated by the multiplexing layer, the initiator sends a single message
  containing a request. The responder then sends a response, after which the
  substream is then immediately closed. The requests and responses are
  prefixed with their \href{https://en.wikipedia.org/wiki/LEB128}{LEB128}
  encoded length.
  
  \item {\tmstrong{Notification substreams}}. After the protocol is
  negotiated, the initiator sends a single handshake message. The responder
  can then either accept the substream by sending its own handshake or reject
  it by closing the substream. After the substream has been accepted, the
  initiator can send an unbound number of individual messages. The responder
  keeps its sending side of the substream open, despite not sending anything
  anymore, and can later close it in order to signal to the initiator that it
  no longer wishes to communicate.
  
  Handshakes and messages are prefixed with their
  \href{https://en.wikipedia.org/wiki/LEB128}{LEB128} encoded lengths. A
  handshake can be empty, in which case the length prefix would be
  \tmverbatim{0}.
\end{itemizedot}
Connections are established by using the following protocols:
\begin{itemizedot}
  \item \tmverbatim{/noise} - a protocol that is announced when a connection
  to a peer is established.
  
  \item \tmverbatim{/multistream/1.0.0} - a protocol that is announced when
  negotiating an encryption protocol or a substream.
  
  \item \tmverbatim{/yamux/1.0.0} - a protocol used during the
  \tmverbatim{mplex} or \tmverbatim{yamux} negotiation. See Section
  \ref{sect-protocols-substreams} for more information.
\end{itemizedot}
The Polkadot Host can establish a connection with any peer of which it knows
the address. The Polkadot Host supports multiple networking protocols:
\begin{itemize}
  \item {\tmstrong{TCP/IP}} with addresses in the form of
  \tmverbatim{/ip4/1.2.3.4/tcp/} to establish a TCP connection and negotiate
  encryption and a multiplexing layer.
  
  \item {\tmstrong{Websockets}} with addresses in the form of
  \tmverbatim{/ip4/1.2.3.4/ws/} to establish a TCP connection and negotiate
  the Websocket protocol within the connection. Additionally, encryption and
  multiplexing layer is negotiated within the WebSocket connection.
  
  \item {\tmstrong{DNS}} addresses in form of
  \tmverbatim{/dns/website.domain/tcp/} and
  \tmverbatim{/dns/website.domain/ws/}.
\end{itemize}
The addressing system is described in the
\href{https://docs.libp2p.io/concepts/addressing/}{libp2p addressing}
specification. After a base-layer protocol is established, the Polkadot Host
will apply the Noise protocol to establish the encryption layer as described
in Section \ref{sect-encryption-layer}.

\section{Encryption Layer}\label{sect-encryption-layer}

Polkadot protocol uses the {\tmsamp{\tmverbatim{libp2p}}} Noise framework to
build an encryption protocol. The Noise protocol is a framework for building
encryption protocols. \tmverbatim{libp2p} utilizes that protocol for
establishing encrypted communication channels. Refer to the
\href{https://github.com/libp2p/specs/tree/master/noise}{libp2p Secure Channel
Handshake} specification for a detailed description.

Polkadot nodes use the \href{https://noiseexplorer.com/patterns/XX/}{XX
handshake pattern} to establish a connection between peers. The three
following steps are required to complete the handshake process:
\begin{enumeratenumeric}
  \item The initiator generates a keypair and sends the public key to the
  responder. The
  \href{https://github.com/libp2p/specs/tree/master/noise}{Noise
  specification} and the
  \href{https://github.com/libp2p/specs/blob/master/peer-ids/peer-ids.md}{libp2p
  PeerId specification} describe keypairs in more detail.
  
  \item The responder generates its own key pair and sends its public key back
  to the initiator. After that, the responder derives a shared secret and uses
  it to encrypt all further communication. The responder now sends its static
  Noise public key (which may change anytime and does not need to be persisted
  on disk), its \tmverbatim{libp2p} public key and a signature of the static
  Noise public key signed with the \tmverbatim{libp2p} public key.
  
  \item The initiator derives a shared secret and uses it to encrypt all
  further communication. It also sends its static Noise public key,
  \tmverbatim{libp2p} public key and signature to the responder.
\end{enumeratenumeric}
After these three steps, both the initiator and responder derive a new shared
secret using the static and session-defined Noise keys, which are used to
encrypt all further communication.

\section{Protocols and Substreams}\label{sect-protocols-substreams}

After the node establishes a connection with a peer, the use of multiplexing
allows the Polkadot Host to open substreams. \tmverbatim{libp2p} uses the
\href{https://docs.libp2p.io/concepts/stream-multiplexing/#mplex}{\tmverbatim{mplex}
protocol} or the
\href{https://docs.libp2p.io/concepts/stream-multiplexing/#yamux}{\tmverbatim{yamux}
protocol} to manage substreams and to allow the negotiation of
\tmtextit{application-specific protocols}, where each protocol serves a
specific utility.

The Polkadot Host uses multiple substreams whose usage depends on a specific
purpose. Each substream is either a {\tmem{Request-Response substream}} or a
{\tmem{Notification substream}}, as described in Section
\ref{sect-connection-establishment}.
\begin{itemize}
  \item \tmverbatim{/ipfs/ping/1.0.0} - Open a standardized
  \tmverbatim{libp2p} substream to a peer and initialize a ping to verify if a
  connection is still alive. If the peer does not respond, the connection is
  dropped. This is a {\tmem{Request-Response substream}}.
  
  Further specification and reference implementation are available in the
  \href{https://docs.libp2p.io/concepts/protocols/#ping}{libp2p
  documentation}.
  
  \item \tmverbatim{/ipfs/id/1.0.0} - Open a standardized \tmverbatim{libp2p}
  substream to a peer to ask for information about that peer. This is a
  {\tmem{Request-Response substream}}.
  
  Further specification and reference implementation are available in the
  \href{https://docs.libp2p.io/concepts/protocols/#ping}{libp2p
  documentation}.
  
  \item \tmverbatim{/dot/kad} - Open a standardized substream for Kademlia
  \tmverbatim{FIND\_NODE} requests. This is a {\tmem{Request-Response
  substream}}, as defined by the \tmverbatim{libp2p} standard.
  
  Further specification and reference implementation are available on
  \href{https://en.wikipedia.org/wiki/Kademlia}{Wikipedia} respectively the
  \href{https://github.com/libp2p/go-libp2p-kad-dht}{golang Github
  repository}.
\end{itemize}
\begin{itemize}
  \item \tmverbatim{/dot/light/2} - a request and response protocol that
  allows a light client to request information about the state. This is a
  {\tmem{Request-Response substream}}.
  
  {\todo{light client messages are currently not documented}}
  
  \item \tmverbatim{/dot/block-announces/1} - a substream/notification
  protocol which sends blocks to connected peers. This is a
  {\tmem{Notification substream}}.
  
  The messages are specified in Section \ref{sect-msg-block-announce}.
  
  \item \tmverbatim{/dot/sync/2} - a request and response protocol that allows
  the Polkadot Host to perform information about blocks. This is a
  {\tmem{Request-Response substream}}.
  
  The messages are specified in Section \ref{sect-msg-block-request}.
  
  \item \tmverbatim{/dot/transactions/1} - a substream/notification protocol
  which sends transactions to connected peers. This is a {\tmem{Notification
  substream}}.
  
  The messages are specified in Section \ref{sect-msg-transactions}.
  
  \item \tmverbatim{/paritytech/grandpa/1} - a substream/notification protocol
  that sends GRANDPA votes to connected peers. This is a {\tmem{Notification
  substream}}.
  
  The messages are specified in Section \ref{sect-msg-grandpa}.
  
  {\todo{This substream will change in the future. See
  \href{https://github.com/paritytech/substrate/issues/7252}{issue \#7252}.}}
  
  \item \tmverbatim{/paritytech/beefy/1} - a substream/notification protocol
  which sends signed BEEFY statements, as described in Section
  \ref{sect-grandpa-beefy}, to connected peers. This is a
  {\tmem{Notification}} substream.
  
  The messages are specified in Section \ref{sect-msg-grandpa-beefy}.
\end{itemize}
{\tmstrong{Note}}: the \tmverbatim{/dot/} prefixes on those substreams are
known as protocol identifiers and are used to segregate communications to
specific networks. This prevents any interference with other networks.
\tmverbatim{/dot/} is used exclusively for Polkadot. Kusama, for example, uses
the \tmverbatim{/ksmcc3/} protocol identifier.

\section{Network Messages}\label{sect-network-messages}

The Polkadot Host must actively communicate with the network in order to
participate in the validation process or act as a full node.

{\tmstrong{Note}}: The Polkadot network originally only used SCALE encoding
for all message formats. Meanwhile, Protobuf has been adopted for certain
messages. The encoding of each message is explicitly mentioned in their
corresponding definition. Encoding and message formats are subject to change.

\subsection{Announcing blocks}\label{sect-msg-block-announce}

When the node creates or receives a new block, it must be announced to the
network. Other nodes within the network will track this announcement and can
request information about this block. The mechanism for tracking announcements
and requesting the required data is implementation-specific.

Block announcements, requests and responses are sent over the
\tmverbatim{/dot/block-announces/1} substream as defined in Definition
\ref{defn-block-announce-handshake}.

\begin{definition}
  \label{defn-block-announce-handshake}The \tmverbatim{BlockAnnounceHandshake}
  initializes a substream to a remote peer. Once established, all
  \tmverbatim{BlockAnnounce} messages, as defined in Definition
  \ref{defn-block-announce}, and created by the node are sent to the
  \tmverbatim{/dot/block-announces/1} substream.
  
  The \tmverbatim{BlockAnnounceHandshake} is a SCALE-encoded structure of the
  following format:
  \begin{eqnarray*}
    \tmop{BA}_h & = & \tmop{Enc}_{\tmop{SC}} (R, N_B, h_B, h_G)
  \end{eqnarray*}
  where:
  \begin{eqnarray*}
    R & = & \left\{\begin{array}{ll}
      1 & \textit{The node is a full node}\\
      2 & \textit{The node is a light client}\\
      4 & \textit{The node is a validator}
    \end{array}\right.\\
    N_B & = & \textit{Best block number according to the node}\\
    h_B & = & \textit{Best block hash according to the node}\\
    h_G & = & \textit{Genesis block hash according to the node}
  \end{eqnarray*}
\end{definition}

\begin{definition}
  \label{defn-block-announce}The \tmverbatim{BlockAnnounce} message is sent to
  the specified substream and indicates to remote peers that the node has
  either created or received a new block.
  
  The \tmverbatim{BlockAnnounce} message is a SCALE-encoded structure of the
  following format:
  \begin{eqnarray*}
    \tmop{BA} & = & \tmop{Enc}_{\tmop{SC}} (\tmop{Head} (B), b)
  \end{eqnarray*}
  where:
  \begin{eqnarray*}
    \tmop{Head} (B) & = & \textit{Header of the announced block}\\
    b & = & \left\{\begin{array}{ll}
      0 & \textit{Is not part of the best chain}\\
      1 & \textit{Is the best block according to the node}
    \end{array}\right.
  \end{eqnarray*}
\end{definition}

\subsection{Requesting blocks}\label{sect-msg-block-request}

Block requests can be used to retrieve a range of blocks from peers. Those
messages are sent over the \tmverbatim{/dot/sync/2} substream.

\begin{definition}
  The \tmverbatim{BlockRequest} message is a Protobuf serialized structure of
  the following format:
  
  \begin{table}[h]
    \begin{tabular}{llll}
      {\tmstrong{Type}} & {\tmstrong{Id}} & {\tmstrong{Description}} &
      {\tmstrong{Value}}\\
      \hline
      uint32 & 1 & Bits of block data to request & $B_f$\\
      \hline
      oneof &  & Start from this block & $B_S$\\
      \hline
      bytes & 4 & End at this block (optional) & $B_e$\\
      \hline
      Direction & 5 & Sequence direction & \\
      \hline
      uint32 & 6 & Maximum amount (optional) & $B_m$\\
      \hline
    \end{tabular}
    \caption{\tmverbatim{BlockRequest} Protobuf message.}
  \end{table}
  
  where
  \begin{itemizedot}
    \item $B_f$ indicates all the fields that should be included in the
    request. Its {\tmstrong{big-endian}} encoded bitmask that applies to all
    desired fields with bitwise OR operations. For example, the $B_f$ value to
    request \tmverbatim{Header} and \tmverbatim{Justification} is
    \tmverbatim{0001 0001} (17).
    
    \begin{table}[h]
      \begin{tabular}{ll}
        {\tmstrong{Field}} & {\tmstrong{Value}}\\
        \hline
        Header & 0000 0001\\
        \hline
        Body & 0000 0010\\
        \hline
        Justification & 0001 0000\\
        \hline
      \end{tabular}
      \caption{Bits of block data to be requested.}
    \end{table}
    
    \item $B_s$ is a Protobuf structure indicating a varying data type of the
    following values:
    
    \begin{table}[h]
      \begin{tabular}{lll}
        {\tmstrong{Type}} & {\tmstrong{Id}} & {\tmstrong{Description}}\\
        \hline
        bytes & 2 & The block hash\\
        \hline
        bytes & 3 & The block number\\
        \hline
      \end{tabular}
      \caption{Protobuf message indicating the block to start from.}
    \end{table}
    
    \item $B_e$ is either the block hash or block number depending on the
    value of $B_s$. An implementation-defined maximum is used when
    unspecified.
    
    \item \tmverbatim{Direction} is a Protobuf structure indicating the
    sequence direction of the requested blocks. The structure is a varying
    data type, as defined in Definition \ref{defn-varrying-data-type}, of the
    following format:
    
    \begin{table}[h]
      \begin{tabular}{ll}
        {\tmstrong{Id}} & {\tmstrong{Description}}\\
        \hline
        0 & Enumerate in ascending order\\
        & (from child to parent)\\
        \hline
        1 & Enumerate in descending order\\
        & (from parent to canonical child)\\
        \hline
      \end{tabular}
      \caption{\tmverbatim{Direction} Protobuf structure.}
    \end{table}
    
    \item $B_m$ is the number of blocks to be returned. An implementation
    defined maximum is used when unspecified.
  \end{itemizedot}
\end{definition}

\begin{definition}
  The \tmverbatim{BlockResponse} message is received after sending a
  \tmverbatim{BlockRequest} message to a peer. The message is a Protobuf
  serialized structure of the following format:
  
  \begin{table}[h]
    \begin{tabular}{lll}
      {\tmstrong{Type}} & {\tmstrong{Id}} & {\tmstrong{Description}}\\
      \hline
      repeated & 1 & Block data for the requested sequence\\
      BlockData &  & \\
      \hline
    \end{tabular}
    \caption{\tmverbatim{BlockResponse} Protobuf message.}
  \end{table}
  
  where \tmverbatim{BlockData} is a Protobuf structure containing the
  requested blocks. Do note that the optional values are either present or
  absent depending on the requested fields (bitmask value). The structure has
  the following format:
  
  \begin{table}[h]
    \begin{tabular}{llll}
      {\tmstrong{Type}} & {\tmstrong{Id}} & {\tmstrong{Description}} &
      {\tmstrong{Value}}\\
      \hline
      bytes & 1 & Block header hash & Def. \ref{defn-block-header-hash}\\
      \hline
      bytes & 2 & Block header (optional) & Def. \ref{defn-block-header}\\
      \hline
      repeated & 3 & Block body (optional) & Def. \ref{defn-block-body}\\
      bytes &  &  & \\
      \hline
      bytes & 4 & Block receipt (optional) & \\
      \hline
      bytes & 5 & Block message queue (optional) & \\
      \hline
      bytes & 6 & Justification (optional) & Def.
      \ref{defn-grandpa-justification}\\
      \hline
      bool & 7 & Indicates whether the justification & \\
      &  & is empty (i.e. should be ignored). & \\
      \hline
    \end{tabular}
    \caption{{\tmstrong{BlockData}} Protobuf structure.}
  \end{table}
\end{definition}

\subsection{Transactions}\label{sect-msg-transactions}

Transactions, as defined and described in Section \ref{sect-extrinsics}, are
sent directly to peers with which the Polkadot Host has an open transaction
substream, as defined in Definition \ref{defn-transactions-message}. Polkadot
Host implementers should implement a mechanism that only sends a transaction
once to each peer and avoids sending duplicates. Sending duplicate
transactions might result in undefined consequences such as being blocked for
bad behaviour by peers.

The mechanism for managing transactions is further described in Section
\ref{sect-extrinsics}.

\begin{definition}
  \label{defn-transactions-message}The {\tmstrong{transactions message}} is
  the structure of how the transactions are sent over the network. It is
  represented by $M_T$ and is defined as follows:
  \[ M_T \assign \tmop{Enc}_{\tmop{SC}} (C_1, \ldots, C_n) \]
  in which:
  \[ C_i \assign \tmop{Enc}_{\tmop{SC}} (E_i) \]
  Where each $E_i$ is a byte array and represents a separate extrinsic. The
  Polkadot Host is agnostic about the content of an extrinsic and treats it as
  a blob of data.
  
  Transactions are sent over the \tmverbatim{/dot/transactions/1} substream.
\end{definition}

\subsection{GRANDPA Messages}\label{sect-msg-grandpa}

The exchange of GRANDPA messages is conducted on the
\tmverbatim{/paritytech/grandpa/1} substream. The process for the creation and
distributing these messages is described in Section \ref{sect-finality}. The
underlying messages are specified in this section.

\begin{definition}
  \label{defn-gossip-message}A {\tmstrong{GRANDPA gossip message}} is a
  variant, as defined in Definition \ref{defn-varrying-data-type}, which
  identifies the message type that is cast by a voter. This type, followed by
  the sub-component, is sent to other validators.
  
  \begin{table}[h]
    \begin{tabular}{llll}
      {\tmstrong{Id}} & {\tmstrong{Type}} & \tmtextbf{Definiton} &
      \tmtextbf{Repropagated}\\
      \hline
      0 & GRANDPA vote message & \ref{defn-grandpa-vote-msg} & yes\\
      \hline
      1 & GRANDPA commit message & \ref{defn-grandpa-commit-msg} & yes\\
      \hline
      2 & GRANDPA neighbor message & \ref{defn-grandpa-neighbor-msg} & no\\
      \hline
      3 & GRANDPA catch-up request message &
      \ref{defn-grandpa-catchup-request-msg} & no\\
      \hline
      4 & GRANDPA catch-up message & \ref{defn-grandpa-catchup-response-msg} &
      no\\
      \hline
    \end{tabular}
    \caption{GRANDPA gossip message types}
  \end{table}
\end{definition}

\subsubsection{GRANDPA Vote Messages}\label{sect-msg-grandpa-vote}

\begin{definition}
  \label{defn-grandpa-vote-msg}A {\tmstrong{GRANDPA vote message}} by voter
  $v$, \tmtextbf{$M^{r, \tmop{stage}}_v$}, is gossip to the network by voter
  $v$ with the following structure:
  \begin{eqnarray*}
    M^{r, \tmop{stage}}_v (B) & \assign & \tmop{Enc}_{\tmop{SC}} (r,
    \tmop{id}_{\mathbb{V}}, \mathit{SigMsg})\\
    \mathit{SigMsg} & \assign & (\mathit{msg}, \tmop{Sig}^{r,
    \tmop{stage}}_{v_i}, v_{\tmop{id}})\\
    \mathit{msg} & \assign & \tmop{Enc}_{\tmop{SC}} (\tmop{stage}, V^{r,
    \tmop{stage}}_v (B))
  \end{eqnarray*}
  Where:
  {\center{\begin{tabular}{rll}
    r & round number & unsigned 64-bit integer\\
    $\tmop{id}_{\mathbb{V}}$ & authority set Id (Definition
    \ref{defn-authority-set-id}) & unsigned 64-bit integer\\
    $\tmop{Sig}^{r, \tmop{stage}}_{v_i}$ & signature (Definition
    \ref{defn-sign-round-vote}) & 512-bit array\\
    {\rightaligned{$v_{\tmop{id}}$}} & Ed25519 public key of $v$ & 256-bit
    array\\
    {\rightaligned{}}$\tmop{stage}$ & 0 if it's a pre-vote sub-round & 8-bit
    integer\\
    & 1 if it's a pre-commit sub-round & 8-bit integer\\
    & 2 if it's a primary proposal message & 8-bit integer\\
    $V^{r, \tmop{stage}}_v (B)$ & GRANDPA vote for block $B$ (Definition
    \ref{defn-vote}) & 256-bit array, 32-bit integer
  \end{tabular}}}
  
  
  This message is the sub-component of the GRANDPA gossip message as defined
  in Definition \ref{defn-gossip-message} of type Id 0.
\end{definition}

\subsubsection{GRANDPA Commit Message}

\begin{definition}
  \label{defn-grandpa-justifications-compact}The \tmtextbf{GRANDPA compact justification format}
  is an optimized data structure to store a collection
  of pre-commits and their signatures to be submitted as part of a commit
  message. Instead of storing an array of justifications, it uses the
  following format:
  \[ J^{r, \tmop{comp}}_{v_{0 \ldots n}} : = (\{ V^{r, \tmop{pc}}_{v_0},
     \ldots, V^{r, \tmop{pc}}_{v_n} \}, \{  (\tmop{Sig}^{r, \tmop{pc}}_{v_0},
     v_{\tmop{id}_0}), \ldots, (\tmop{Sig}_{v_n}^{r, \tmop{pc}},
     v_{\tmop{id}_n}) \}) \]
  Where:
  {\center{\begin{tabular}{rll}
    $V^{r, \tmop{pc}}_{v_i}$ & pre-commit vote of authority $v_i$ (Definition
    \ref{defn-vote}) & 256-bit array, 32-bit integer\\
    $\tmop{Sig}^{r, \tmop{pc}}_{v_i}$ & pre-commit signature of authority
    $v_i$ (Definition \ref{defn-sign-round-vote}) & 512-bit array\\
    {\rightaligned{$v_{\tmop{id}_i}$}} & public key of authority $v_i$ &
    256-bit array
  \end{tabular}}}
\end{definition}

\begin{definition}
  \label{defn-grandpa-commit-msg}A {\tmstrong{$\tmmathbf{} \tmop{GRANDPA}$
  commit message}} for block $B$ in round $r$ {\tmstrong{$M_v^{r,
  \tmop{Fin}}$(B)}} is a message broadcasted by voter $v$ to the network
  indicating that voter $v$ has finalized block $B$ in round $r$. It has the
  following structure:
  \[ M^{r, \tmop{Fin}}_v (B) \assign \tmop{Enc}_{\tmop{SC}} (r,
     \tmop{id}_{\mathbb{V}}, V_v^r (B), J_{\tilde{v}_{0 \ldots n}}^{r,
     \tmop{comp}}) \]
  Where:
  {\center{\begin{tabular}{rll}
    $r$ & round number & unsigned 64-bit integer\\
    $\tmop{id}_{\mathbb{V}}$ & authority set Id (Definition
    \ref{defn-authority-set-id}) & unsigned 64-bit integer\\
    $V_v^r (B)$ & GRANDPA vote for block $B$ (Definition \ref{defn-vote}) &
    256-bit array, 32-bit integer\\
    $J_{\tilde{v}_{0 \ldots n}}^{r, \tmop{comp}}$ & compacted GRANDPA
    justifications (Definition \ref{defn-grandpa-justifications-compact}) \  &
    variable size\\
    & containing observed pre-commits of authorities $\tilde{v}_0$ to
    $\tilde{v}_n$ & 
  \end{tabular}}}
  
  
  This message is the sub-component of the GRANDPA gossip message as defined
  in Definition \ref{defn-gossip-message} of type Id 1.
\end{definition}

\subsubsection{GRANDPA Neighbor Message}\label{sect-grandpa-neighbor-msg}

Neighbor messages are sent to all connected peers but they are not
repropagated on reception. A message should be send whenever the messages
values change and at least every 5 minutes. The sender should take the
recipients state into account and avoid sending messages to peers that are
using a different voter sets or are in a different round. Messages received
from a future voter set or round can be dropped and ignored.

\begin{definition}
  \label{defn-grandpa-neighbor-msg}A \tmtextbf{GRANDPA neighbor message} is
  defined as
  
  
  \[ M^{\tmop{neigh}} : = \tmop{Enc}_{\tmop{SC}} (\tmop{version}, r,
     \tmop{id}_{\mathbb{V}}, H_h (B_{\tmop{last}})) \]
  Where:
  {\center{\begin{tabular}{rll}
    $\tmop{version}$ & version of neighbor message, currently \tmverbatim{1} &
    unsignes 8-bit integer\\
    r & round number & unsigned 64-bit integer\\
    $\tmop{id}_{\mathbb{V}}$ & authority set Id (Definition
    \ref{defn-authority-set-id}) & unsigned 64-bit integer\\
    $H_i (B_{\tmop{last}})$ & block number of last finialized block
    $B_{\tmop{last}}$ & unsigned 32-bit integer
  \end{tabular}}}
  
  
  This message is the sub-component of the GRANDPA gossip message as defined
  in Definition \ref{defn-gossip-message} of type Id 2.
\end{definition}

\subsubsection{GRANDPA Catch-up Messages}\label{sect-grandpa-catchup-messages}

Whenever a Polkadot node detects that it is lagging behind the finality
procedure, it needs to initiate a {\tmem{catch-up}} procedure. GRANDPA
Neighbor messages (see Section \ref{defn-grandpa-neighbor-msg}) reveal the
round number for the last finalized GRANDPA round which the node's peers have
observed. This provides the means to identify a discrepancy in the latest
finalized round number observed among the peers. If such a discrepancy is
observed, the node needs to initiate the catch-up procedure explained in
Section \ref{sect-grandpa-catchup}.

In particular, this procedure involves sending a {\tmem{catch-up request}} and
processing {\tmem{catch-up response}} messages specified here:

\begin{definition}
  A \label{defn-grandpa-catchup-request-msg}{\tmstrong{GRANDPA catch-up
  request message}} for round r, {\tmstrong{$M_{i, v}^{\tmop{Cat} - q}
  (\tmop{id}_{\mathbb{V}}, r)$}}, is a message sent from node $i$ to its
  voting peer node $v$ requesting the latest status of a GRANDPA round $r' >
  r$ of the authority set $\mathbb{V}_{\tmop{id}}$ along with the
  justification of the status and has the following structure:
  \[ M_{i, v}^{r, \tmop{Cat} - q} \assign \tmop{Enc}_{\tmop{SC}} (r,
     \tmop{id}_{\mathbb{V}}) \]
  This message is the sub-component of the GRANDPA Gossip message as defined
  in Definition \ref{defn-gossip-message} of type Id 3.
\end{definition}

\begin{definition}
  \label{defn-grandpa-catchup-response-msg}{\tmstrong{GRANDPA catch-up
  response message}} for round, {\tmstrong{$M_{v, i}^{\tmop{Cat} - s}
  (\tmop{id}_{\mathbb{V}}, r)$}}, is a message sent by a node $v$ to node i in
  response of a catch-up request $M_{v, i}^{\tmop{Cat} - q}
  (\tmop{id}_{\mathbb{V}}, r')$ in which $r \geqslant r'$ is the latest
  GRANDPA round which v has prove of its finalization and has the following
  structure:
  \[ M_{v, i}^{r, \tmop{Cat} - s} \assign \tmop{Enc}_{\tmop{SC}}
     (\tmop{id}_{\mathbb{V}}, r, J_{0 \ldots n}^{r, \tmop{pv}} (B), J_{0
     \ldots m}^{r, \tmop{pc}} (B), H_h (B'), H_i (B')) \]
  Where B is the highest block which $v$ believes to be finalized in round
  $r$. $B'$ is the highest ancestor of all blocks voted on in the arrays of
  justifications $J^{r, \tmop{pv}}_{0 \ldots n} (B)$ and $J_{0 \ldots m}^{r,
  \tmop{pc}} (B)$ with the exception of the equivocationary votes.
  
  This message is the sub-component of the GRANDPA Gossip message as defined
  in Definition \ref{defn-gossip-message} of type Id 4.
\end{definition}

\subsubsection{GRANDPA BEEFY}\label{sect-msg-grandpa-beefy}

{\todo{NOTE: The BEEFY protocol is currently in early development and subject
to change}}

\

This section defines the messages required for the GRANDPA BEEFY protocol as
described in Section \ref{sect-grandpa-beefy}. Those messages are sent over
the \tmverbatim{/paritytech/beefy/1} substream.

\begin{definition}
  \label{defn-grandpa-beefy-commitment}A commitment, $C$, contains the
  information extracted from the finalized block at height $H_i
  (B_{\tmop{last}})$ as specified in the message body.
  
  \
  
  C is a datastructe of the following format:
  \begin{eqnarray*}
    C & = & (R_h, H_i (B_{\tmop{last}}), \tmop{id}_{\mathbb{V}})
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $R_h$ is the MMR root of all the block header hashes leading up to
    the latest, finalized block.
    
    \item $H_i (B_{\tmop{last}})$ is the block number this commitment is for.
    Namely the latest, finalized block.
    
    \item $\tmop{id}_{\mathbb{V}}$ is the current authority set Id as defined
    in Definition \ref{defn-authority-set-id}.
  \end{itemizedot}
\end{definition}

\begin{definition}
  \label{defn-msg-beefy-gossip}A vote message, $M_v$, is direct vote created
  by the Polkadot Host on every BEEFY round and is gossiped to its peers. The
  message is a datastructure of the following format:
  \begin{eqnarray*}
    M_v & = & \tmop{Enc}_{\tmop{SC}} \left( C, A^{\tmop{bfy}}_{\tmop{id}} {,
    A_{\tmop{sig}}}  \right)
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item C is the commitment as defined in Definition
    \ref{defn-grandpa-beefy-commitment}.
    
    \item $A^{\tmop{bfy}}_{\tmop{id}}$ is the ECDSA public key of the Polkadot
    Host.
    
    \item $A_{\tmop{sig}}$ is the signature created with
    $A^{\tmop{bfy}}_{\tmop{id}}$ by signing the statement $R_h$ in $C$.
  \end{itemizedot}
\end{definition}

\begin{definition}
  \label{defn-grandpa-beefy-signed-commitment}A signed commitment,
  $M_{\tmop{sc}}$, is a datastructure of the following format:
  \begin{eqnarray*}
    M_{\tmop{sc}} & = & \tmop{Enc}_{\tmop{SC}} (C, S_n)\\
    S_n & = & (A^{\tmop{sig}}_0, \ldots, A^{\tmop{sig}}_n)
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $C$ is the commitment as defined in Definition
    \ref{defn-grandpa-beefy-commitment}.
    
    \item $S_n$ is an array where its exact size matches the number of
    validators in the current authority set as specified by
    $\tmop{id}_{\mathbb{V}}$ (Definition \ref{defn-authority-set-id}) in C.
    Individual items are of the type \tmverbatim{Option} as defined in
    Definition \ref{defn-option-type} which can contain a signature of a
    validator which signed the same statement ($R_h$ in $C$) and is active in
    the current authority set. It's critical that the signatures are sorted
    based on their corresponding public key entry in the authority set.
    
    \
    
    For example, the signature of the validator at index 3 in the authority
    set must be placed at index 3 in $S_n$. If not signature is available for
    that validator, then the \tmverbatim{Option} variant \tmverbatim{None} is
    inserted. This sorting allows clients to map public keys to their
    corresponding signatures.
  \end{itemizedot}
\end{definition}

\begin{definition}
  \label{defn-grandpa-beefy-signed-commitment-witness}A signed commitment
  witness, $M^w_{\tmop{sc}}$, is a light version of the signed commitment as
  defined in Definition \ref{defn-grandpa-beefy-signed-commitment}. Instead of
  containing the entire list of signatures, it only claims which validator
  signed the statement.
  
  \
  
  The message is a datastructure of the following format:
  \begin{eqnarray*}
    M^w_{\tmop{sc}} & = & \tmop{Enc}_{\tmop{SC}} (C, V_{0 \ldots n},
    R_{\tmop{sig}})
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $C$ is the commitment as defined in Definition
    \ref{defn-grandpa-beefy-commitment}.
    
    \item $V_{0 \ldots n}$ is an array where its exact size matches the number
    of validators in the current authority set as specified by
    $\tmop{id}_{\mathbb{V}}$ in $C$. Individual items are booleans which
    indicate whether the validator has signed the statement (true) or not
    (false). It's critical that the boolean indicators are sorted based on
    their corresponding public key entry in the authority set.
    
    \
    
    For example, the boolean indicator of the validator at index 3 in the
    authority set must be placed at index 3 in $V_n$. This sorting allows
    clients to map public keys to their corresponding boolean indicators.
    
    \item $R_{\tmop{sig}}$ is the MMR root of the signatures in the original
    signed commitment as defined in Definition
    \ref{defn-grandpa-beefy-signed-commitment}.
  \end{itemizedot}
\end{definition}

\

\begin{flushright}
  {\qed}
\end{flushright}

\

\chapter{Bootstrapping}\label{chap-bootstrapping}

This chapter provides an overview over the tasks a Polkadot Host needs to
performs in order to join and participate in the Polkadot network. While this
chapter does not go into any new specifications of the protocol, it has been
included to provide implementors with a pointer to what these steps are and
where they are defined. In short, the following steps should be taken by all
bootstrapping nodes:
\begin{enumerate}
  \item The node needs to populate the state storage with the official Genesis
  state which can be obtained from {\cite{paritytech_genesis_state}}.
  
  \item The node should maintains a set of around 50 active peers at any time.
  New peers can be found using the \tmverbatim{libp2p} discovery protocols
  (Section \ref{sect-discovery-mechanism})
  
  \item The node should open and maintain the various required streams
  (Section \ref{sect-protocols-substreams}) with each of its active peers.
  
  \item Furthermore, the node should send block requests (Section
  \ref{sect-msg-block-request}) to these peers to receive all blocks in the
  chain and execute each of them.
  
  \item Exchange neighbor packets (Section \ref{sect-grandpa-neighbor-msg})
  
  \ 
\end{enumerate}
Validator nodes should take the following, additional steps.
\begin{enumerate}
  \item Verify that the Host's session key is included in the current Epoch's
  authority set (Section \ref{sect-authority-set}).
  
  \item Run the BABE lottery (Section \ref{sect-block-production}) and wait
  for the next assigned slot in order to produce a block.
  
  \item Gossip any produced blocks to all connected peers (Section
  \ref{sect-msg-block-announce}).
  
  \item Run the catch-up protocol (Section \ref{sect-grandpa-catchup}) to make
  sure that the node is participating in the current round and not a past
  round.
  
  \item Run the GRANDPA rounds protocol (Section \ref{sect-finality}).
\end{enumerate}


\begin{flushright}
  {\qed}
\end{flushright}

\

\chapter{Consensus}\label{chap-consensu}

Consensus in the Polkadot Host is achieved during the execution of two
different procedures. The first procedure is the block-production and the
second is finality. The Polkadot Host must run these procedures if (and only
if) it is running on a validator node.

\section{Common Consensus Structures}

\subsection{Consensus Authority Set}\label{sect-authority-set}

Because Polkadot is a proof-of-stake protocol, each of its consensus engines
has its own set of nodes represented by known public keys, which have the
authority to influence the protocol in pre-defined ways explained in this
Section. To verify the validity of each block, the Polkadot node must track
the current list of authorities for that block as formalized in Definition
\ref{defn-authority-list}

\begin{definition}
  \label{defn-authority-list}The {\tmstrong{authority list}} of block
  $\mathit{B}$ for consensus engine $C$ noted as {\tmstrong{$\tmop{Auth}_C
  (B)$}} is an array that contains the following pair of types for each of its
  authorities $A \in \tmop{Auth}_C (B) $:
  \[ (\tmop{pk}_A, w_A) \]
  $\tmop{pk}_A$ is the session public key of authority A as defined in
  Definition \ref{defn-session-key}. And $w_A$ is a \tmverbatim{u64} value,
  indicating the authority weight. The value of $\tmop{Auth}_C (B)$ is part of
  the Polkadot state. The value for $\tmop{Auth}_C (B_0)$ is set in the
  genesis state (see Section \ref{sect-genesis-block}) and can be retrieved
  using a runtime entry corresponding to consensus engine $C$.
\end{definition}

\begin{remark}
  In Polkadot, all authorities have the weight ${w_A}  = 1$. The weight $w_A$
  in Definition \ref{defn-authority-list} exists for potential improvements in
  the protocol and could have a use-case in the future.
\end{remark}

\subsection{Runtime-to-Consensus Engine
Message}\label{sect-consensus-message-digest}

The authority list (see Definition \ref{defn-authority-list}) is part of the
Polkadot state and the Runtime has the authority to update this list in the
course of any state transitions. The Runtime informs the corresponding
consensus engine about the changes in the authority set by adding the
appropriate consensus message as defined in Definition
\ref{defn-consensus-message-digest}, in the form of a digest item to the block
header of block $B$ which caused the transition in the authority set.

\begin{definition}
  \label{defn-consensus-message-digest} Consensus Message is a digest item of
  type 4 as defined in Definition \ref{defn-digest} and consists of the pair:
  \[ (E_{\tmop{id}}, \tmop{CM}) \]
  Where $E_{\tmop{id}} \in \mathbb{B}_4$ is the consensus engine unique
  identifier which can hold the following possible values
  
  
  \[ E_{\tmop{id}} \assign \left\{ \begin{array}{ccc}
       '' \tmop{BABE}'' &  & \tmop{For} \tmop{messages} \tmop{related}
       \tmop{to} \tmop{BABE} \tmop{protocol} \tmop{referred} \tmop{to}
       \tmop{as} E_{\tmop{id}} (\tmop{BABE})\\
       '' \tmop{FRNK}'' &  & \tmop{For} \tmop{messages} \tmop{related}
       \tmop{to} \tmop{GRANDPA} \tmop{protocol} \tmop{referred} \tmop{to}
       \tmop{as} E_{\tmop{id}} (\tmop{FRNK})
     \end{array} \right. \]
  and CM is of varying data type which can hold one of the types described in
  Table \ref{tabl-consensus-messages-babe} or
  \ref{tabl-consensus-messages-grandpa}:
  {\center{\tmfloat{h}{small}{table}{\begin{tabular}{l|l|l}
    {\tmstrong{Type Id}} & {\tmstrong{Type}} & {\tmstrong{Sub-components}}\\
    \hline
    1 & Next Epoch Data & $(\tmop{Auth}_{\tmop{BABE}}, \mathcal{R})$\\
    2 & On Disabled & $\tmop{Auth}_{\tmop{ID}}$\\
    3 & Next Config Data & $(c, s_{2 \tmop{nd}} )$
  \end{tabular}}{\label{tabl-consensus-messages-babe}The consensus digest item
  for BABE authorities}}}
  Where:
  \begin{itemizeminus}
    \item Auth$_{\tmop{BABE}}$ is the authority list for the next epoch, as
    defined in definition \ref{defn-authority-list}.
    
    \item $\mathcal{R}$ is the 32-byte randomness seed for the next epoch, as
    defined in definition \ref{defn-epoch-randomness}
    
    \item $\tmop{Auth}_{\tmop{ID}}$ is an unsigned 64-bit integer pointing to
    an individual authority in the current authority list.
    
    \item $c$ is the probability that a slot will not be empty, as defined in
    definition \ref{defn-babe-constant}. It is encoded as a tuple of two
    unsigned 64-bit integers $(c_{\tmop{nominator}}, c_{\tmop{denominator}})$
    which are used to compute the rational $c =
    \frac{c_{\tmop{nominator}}}{c_{\tmop{denominator}}}$.
    
    \item $s_{2 \tmop{nd}}$ is the second slot configuration encoded as an
    8-bit enum. 
  \end{itemizeminus}
  {\center{\tmfloat{h}{small}{table}{\begin{tabular}{l|l|l}
    {\tmstrong{Type Id}} & {\tmstrong{Type}} & {\tmstrong{Sub-components}}\\
    \hline
    1 & Scheduled Change & $(\tmop{Auth}_C, N_{\tmop{delay}})$\\
    2 & Forced Change & $(\tmop{Auth}_C, N_{\tmop{delay}})$\\
    3 & On Disabled & $\tmop{Auth}_{\tmop{ID}}$\\
    4 & Pause & $N_{\tmop{delay}}$\\
    5 & Resume & N$_{\tmop{delay}}$
  \end{tabular}}{\label{tabl-consensus-messages-grandpa}The consensus digest
  item for GRANDPA authorities}}}
  Where:
  \begin{itemizeminus}
    \item Auth$_C$ is the authority list as defined in definition
    \ref{defn-authority-list}.
    
    \item $N_{\tmop{delay}} \assign | \nobracket${\tmname{SubChain}}$(B, B') |
    \nobracket$ is an unsigned 32-bit integer indicating the length of the
    subchain starting at $B$, the block containing the consensus message in
    its header digest and ending when it reaches $N_{\tmop{delay}}$ length as
    a path graph. The last block in that subchain, $B'$, depending on the
    message type, is either finalized or imported (and therefore validated by
    the block production consensus engine according to Algorithm
    \ref{algo-import-and-validate-block}. See below for details).
    
    \item $\tmop{Auth}_{\tmop{ID}}$ is an unsigned 64-bit integer pointing to
    an individual authority in the current authority list.
  \end{itemizeminus}
\end{definition}

The Polkadot Host should inspect the digest header of each block and delegate
consensus messages to their consensus engines.

The BABE consensus engine should react based on the type of consensus messages
it receives as follows:
\begin{itemizeminus}
  \item \tmtextbf{Next Epoch Data:} The Runtime issues this message on every
  first block of an epoch $\mathcal{E}_n$. The supplied authority set and
  randomness are intended to be used in the next epoch $\mathcal{E}_{n + 1}$.
  \
  
  \item {\tmstrong{On Disabled}}: An index to the individual authority in the
  current authority list that should be immediately disabled until the next
  authority set changes. When an authority gets disabled, the node should stop
  performing any authority functionality for that authority, including
  authoring blocks. Similarly, other nodes should ignore all messages from the
  indicated authority which pertain to their authority role.
  
  \item \tmtextbf{Next Config Data:} These messages are only issued on
  configuration change and in the first block of an epoch. The supplied
  configuration data are intended to be used from the next epoch onwards. 
\end{itemizeminus}
The GRANDPA consensus engine should react based on the type of consensus
messages it receives as follows:
\begin{itemizeminus}
  \item {\tmstrong{Scheduled Change}}: Schedule an authority set change after
  the given delay of $N_{\tmop{delay}} \assign |
  \nobracket${\tmname{SubChain}}$(B, B') | \nobracket$ where $B'$ in the
  definition of $N_{\tmop{delay}}$, is a block {\tmem{finalized}} by the
  finality consensus engine. The earliest digest of this type in a single
  block will be respected. No change should be scheduled if one is already
  finalized and the delay has not passed completely. If such an inconsistency
  occurs, the scheduled change should be ignored.
  
  \item {\tmstrong{Forced Change}}: Force an authority set change after the
  given delay of $N_{\tmop{delay}} \assign |
  \nobracket${\tmname{SubChain}}$(B, B') | \nobracket$ where $B'$ in the
  definition of $N_{\tmop{delay}}$, is an {\tmem{imported}} block that has
  been validated by the block production consensus engine. Hence, the
  authority changeset is valid for every subchain containing {\tmem{B}} and
  where the delay has been exceeded. If one or more blocks gets finalized
  before the change takes effect, the authority set change should be
  disregarded. The earliest digest of this type in a single block will be
  respected. No change should be scheduled if one is already finalized and the
  delay has not passed completely. If such an inconsistency occurs, the
  scheduled change should be ignored.
  
  \item {\tmstrong{On Disabled}}: An index to the individual authority in the
  current authority list that should be immediately disabled until the next
  authority set changes. When an authority gets disabled, the node should stop
  performing any authority functionality from that authority, including
  authoring blocks and casting GRANDPA votes for finalization. Similarly,
  other nodes should ignore all messages from the indicated authority which
  pertain to their authority role.
  
  \item {\tmstrong{Pause}}: A signal to pause the current authority set after
  the given delay of $N_{\tmop{delay}} \assign |
  \nobracket${\tmname{SubChain}}$(B, B') | \nobracket$ where $B'$ in the
  definition of $N_{\tmop{delay}}$, is a block {\tmem{finalized}} by the
  finality consensus engine. After finalizing block $B'$, the authorities
  should stop voting.
  
  \item {\tmstrong{Resume}}: A signal to resume the current authority set
  after the given delay of $N_{\tmop{delay}} \assign |
  \nobracket${\tmname{SubChain}}$(B, B') | \nobracket$ where $B'$ in the
  definition of $N_{\tmop{delay}}$, is an {\tmem{imported}} block and
  validated by the block production consensus engine. After authoring block
  $B'$, the authorities should resume voting.
\end{itemizeminus}
The active GRANDPA authorities can only vote for blocks that occurred after
the finalized block in which they were selected. Any votes for blocks before
the \tmverbatim{Scheduled Change} came into effect would get rejected.

\section{Block Production}\label{sect-babe}\label{sect-block-production}

The Polkadot Host uses BABE protocol {\cite{w3f_research_group_blind_2019}}
for block production. It is designed based on Ouroboros praos
{\cite{david_ouroboros_2018}}. BABE execution happens in sequential
non-overlapping phases known as an {\tmstrong{{\tmem{epoch}}}}. Each epoch on
its turn is divided into a predefined number of slots. All slots in each epoch
are sequentially indexed starting from 0. At the beginning of each epoch, the
BABE node needs to run Algorithm \ref{algo-block-production-lottery} to find
out in which slots it should produce a block and gossip to the other block
producers. In turn, the block producer node should keep a copy of the block
tree and grow it as it receives valid blocks from other block producers. A
block producer prunes the tree in parallel by eliminating branches that do not
include the most recent finalized blocks according to Definition
\ref{defn-pruned-tree}.

\subsection{Preliminaries}

\begin{definition}
  A {\tmstrong{block producer}}, noted by $\mathcal{P}_j$, is a node running
  the Polkadot Host which is authorized to keep a transaction queue and which
  it gets a turn in producing blocks.
\end{definition}

\begin{definition}
  {\tmstrong{Block authoring session key pair $(\tmop{sk}^s_j,
  \tmop{pk}^s_j)$}} is an SR25519 key pair which the block producer
  $\mathcal{P}_j$ signs by their account key (see Definition
  \ref{defn-account-key}) and is used to sign the produced block as well as to
  compute its lottery values in Algorithm \ref{algo-block-production-lottery}.
  
\end{definition}

\begin{definition}
  \label{defn-epoch-slot}A block production {\tmstrong{epoch}}, formally
  referred to as $\mathcal{E}$, is a period with a pre-known starting time and
  fixed-length during which the set of block producers stays constant. Epochs
  are indexed sequentially, and we refer to the $n^{\tmop{th}}$ epoch since
  genesis by $\mathcal{E}_n$. Each epoch is divided into equal-length periods
  known as block production {\tmstrong{slots}}, sequentially indexed in each
  epoch. The index of each slot is called a {\tmstrong{slot number}}. The
  equal length duration of each slot is called the {\tmstrong{slot duration}}
  and indicated by $\mathcal{T}$. Each slot is awarded to a subset of block
  producers during which they are allowed to generate a block.
\end{definition}

\begin{remark}
  Substrate refers to an epoch as ``session'' in some places, however, epoch
  should be the preferred and official name for these periods.
\end{remark}

\begin{notation}
  \label{note-slot}We refer to the number of slots in epoch $\mathcal{E}_n$ by
  $\tmop{sc}_n$. $\tmop{sc}_n$ is set to the \tmverbatim{duration} field in
  the returned data from the call of the Runtime entry
  \tmverbatim{BabeApi\_configuration} (see \ref{sect-rte-babeapi-epoch}) at
  genesis. For a given block $B$, we use the notation {\tmstrong{$s_B$}} to
  refer to the slot during which $B$ has been produced. Conversely, for slot
  $s$, $\mathcal{B}_s$ is the set of Blocks generated at slot $s$.
\end{notation}

Definition \ref{defn-epoch-subchain} provides an iterator over the blocks
produced during a specific epoch.

\begin{definition}
  \label{defn-epoch-subchain} By {\tmname{SubChain($\mathcal{E}_n$)}} for
  epoch $\mathcal{E}_n$, we refer to the path graph of $\tmop{BT}$ containing
  all the blocks generated during the slots of epoch $\mathcal{E}_n$. When
  there is more than one block generated at a slot, we choose the one which is
  also on {\tmname{Longest-Chain($\tmop{BT}$)}}.
\end{definition}

\begin{definition}
  A block producer {\tmstrong{equivocates}} if they produce more than one
  block at the same slot. The proof of equivocation are the given distinct
  headers that were signed by the validator and which include the slot number.
  
  \
  
  The Polkadot Host must detect equivocations committed by other validators
  and submit those to the Runtime as described in Section
  \ref{sect-babeapi_submit_report_equivocation_unsigned_extrinsic}.
\end{definition}

\subsection{Block Production Lottery}

\begin{definition}
  \label{defn-babe-constant}The \tmtextbf{BABE constant} $\tmmathmd{c} \in (0,
  1 )$ is the probability that a slot will not be empty and used in the
  winning threshold calculation (see Definition \ref{defn-winning-threshold}).
\end{definition}

The babe constant (Definition \ref{defn-babe-constant}) is initialized at
genesis to the value returned by calling \tmverbatim{BabeApi\_configuration}
(see \ref{sect-rte-babeapi-epoch}). For efficiency reasons, it is generally
updated by the Runtime through the ``Next Config Data'' consensus message (see
Definition \ref{defn-consensus-message-digest}) in the digest of the first
block of an epoch for the next epoch.

\begin{definition}
  \label{defn-winning-threshold}The {\tmstrong{Winning threshold}} denoted by
  {\tmstrong{$\tau_{\varepsilon_n}$}} is the threshold that is used alongside
  the result of Algorithm \ref{algo-block-production-lottery} to decide if a
  block producer is the winner of a specific slot. $\tau_{\varepsilon_n}$ is
  calculated \ as follows:
  \[ \tau_{\varepsilon_n} \assign 1 - (1 - c)^{\frac{1}{|
     \tmop{AuthorityDirectory}^{\mathcal{E}_n} |}} \]
  where the $\tmop{AuthorityDirectory}^{\mathcal{E}_n}$ is the set of BABE
  authorities for epoch $\varepsilon_n$ and $c \in (0, 1)$ is the BABE
  constant as defined in definition \ref{defn-babe-constant}.
\end{definition}

A block producer aiming to produce a block during $\mathcal{E}_n$ should run
Algorithm \ref{algo-block-production-lottery} to identify the slots it is
awarded. These are the slots during which the block producer is allowed to
build a block. The $\tmop{sk}$ is the block producer lottery secret key and
$n$ is the index of the epoch for whose slots the block producer is running
the lottery.

\custombinding{8}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{8}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-block-production-lottery}{\tmname{Block-production-lottery}}($\tmop{sk}
      :$ the session secret key of the producer,
      
      $n :$ the epoch index)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

For any slot $i$ in epoch $n$ where $d < \tau$, the block producer is required
to produce a block. For the definitions of {\tmname{Epoch-Randomness}} and
{\tmem{{\tmname{VRF}}}} functions, see Section \ref{sect-epoch-randomness} and
Section \ref{sect-vrf} respectively.

\subsection{Slot Number Calculation}\label{sect-slot-number-calculation}

\begin{definition}
  \label{defn-slot-offset}Let $s_i$ and $s_j$ be two slots belonging to epochs
  $\mathcal{E}_k$ and $\mathcal{E}_l$. By
  \tmtextbf{{\tmname{Slot-Offset}}$(s_i, s_j)$} we refer to the function whose
  value is equal to the number of slots between $s_i$ and $s_j$ (counting
  $s_j$) on the time continuum. As such, we have {\tmname{Slot-Offset}}$(s_i,
  s_i) = 0$.
\end{definition}

It is imperative for the security of the network that each block producer
correctly determines the current slot numbers at a given time by regularly
estimating the local clock offset in relation to the network (Definition
\ref{defn-relative-syncronization}).

\begin{definition}
  \label{defn-relative-syncronization}The \tmtextbf{relative time
  synchronization} is a tuple of a slot number and a local clock timestamp
  $(s_{\tmop{sync}}, t_{\tmop{sync}})$ describing the last point at which the
  slot numbers have been synchronized with the local clock.
\end{definition}

\custombinding{9}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{9}}}{\smallskip}
    
    \begin{tmindent}
      \tmtextsc{Slot-Time(\tmtextup{$s :$ slot number})}
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

\begin{note}
  \tmtextbf{The calculation described in this section is still to be
  implemented and deployed.} For now, each block producer is required to
  synchronize its local clock using NTP instead. The current slot $s$ is then
  calculated by $s  = t_{\tmop{unix}} /\mathcal{T}$ where $t_{\tmop{unix}}$ is
  the current UNIX time in seconds since 1970-01-01 00:00:00 UTC. That also
  entails that slot numbers are currently not reset at the beginning of each
  epoch. 
\end{note}

Polkadot does this synchronization without relying on any external clock
source (e.g. through the \tmtextit{Network Time Protocol} or the
\tmtextit{Global Positioning System}). To stay in synchronization, each
producer is therefore required to periodically estimate its local clock offset
in relation to the rest of the network.

This estimation depends on the two fixed parameters \tmtextbf{$k$}
(Definition \ref{defn-prunned-best}) and $\tmmathbf{s_{\tmop{cq}}}$
(Definition \ref{defn-chain-quality}). These are chosen based on the results
of a formal security analysis, currently assuming a $1 s$clock drift per day
and targeting a probability lower than $0.5\%$ for an adversary to break BABE
in 3 years with resistance against a network delay up to $1 / 3$ of the slot
time and a Babe constant (Definit{\linebreak}ion \ref{defn-babe-constant}) of
$c = 0.38$.

\begin{definition}
  \label{defn-prunned-best}The \tmtextbf{pruned best chain}
  $\tmmathbf{C^{┌k}}$ is the longest chain selected according to Definition
  \ref{defn-longest-chain} with the last k Blocks pruned. We chose $k = 140$.
  The \tmtextbf{last (probabilistically) finalized block} describes the last
  block in this pruned best chain.
\end{definition}

\begin{definition}
  \label{defn-chain-quality}The \tmtextbf{chain quality}
  $\tmmathbf{s_{\tmop{cq}}}$ represents the number of slots that are used to
  estimate the local clock offset. Currently, it is set to $s_{\tmop{cq}} =
  3000$.
\end{definition}

The prerequisite for such a calculation is that each producer stores the
arrival time of each block (Definition \ref{defn-block-time}) measured by a
clock that is otherwise not adjusted by any external protocol.

\begin{definition}
  \label{defn-block-time}The {\tmstrong{block arrival time}} of block $B$ for
  node $j$ formally represented by {\tmstrong{$T^j_B$}} is the local time
  of\tmverbatim{} node $j$ when node $j$ has received block $B$ for the first
  time. If the node $j$ itself is the producer of $B$, $T_B^j$ is set equal to
  the time that the block is produced. The index $j$ in $T^j_B$ notation may
  be dropped and B's arrival time is referred to by $T_B$ when there is no
  ambiguity about the underlying node.
\end{definition}

{\todo{Currently still lacks a clear definition of when block arrival times
are considered valid and how to differentiated imported block on initial sync
from ``fresh'' blocks that were just produced.}}

\begin{definition}
  \label{defn-sync-period}A \tmtextbf{sync period} is an interval at which
  each validator (re-)evaluates its local clock offsets. The first sync period
  $\mathfrak{E}_1$ starts just after the genesis block is released.
  Consequently, each sync period $\mathfrak{E}_i$ starts after
  $\mathfrak{E}_{i - 1}$. The length of the sync period is equal to
  $s_{\tmop{qc}}$ as defined in Definition \ref{defn-chain-quality} and
  expressed in the number of slots.
\end{definition}

All validators are then required to run Algorithm \ref{algo-slot-time} at the
beginning of each sync period (Definition \ref{defn-sync-period}) to update
their synchronization using all block arrival times of the previous period.
The algorithm should only be run once all the blocks in this period have been
finalized, even if only probabilistically (Definition
\ref{defn-prunned-best}). The target slot to which to synchronize should be
the first slot in the new sync period.

\custombinding{10}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{10}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-slot-time}{\tmname{Median-Algorithm}}($\mathfrak{E}_j$: sync
      period used for the estimate, $s_{\tmop{sync}} :$ slot time to estimate)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

$\mathcal{T}$ is the slot duration defined in Definition
\ref{defn-epoch-slot}.

\begin{figure}[h]
  \resizebox{1\columnwidth}{!}{\includegraphics{figures/c06-babe_time_sync.eps}}
  \caption{An exemplary result of Median Algorithm in first sync epoch with
  $s_{\tmop{cq}} = 9$ and $k = 1$.}
\end{figure}

\subsection{Block Production}

Throughout each epoch, each block producer should run Algorithm
\ref{algo-block-production} to produce blocks during the slots it has been
awarded during that epoch. The produced block needs to carry the {\tmem{BABE
header}} as well as the {\tmem{block signature}} as Pre-Runtime and Seal
digest items defined in Definition \ref{defn-babe-header} and
\ref{defn-block-signature} respectively.

\begin{definition}
  \label{defn-babe-header}The {\tmstrong{BABE Header}} of block B, referred to
  formally by {\tmstrong{$H_{\tmop{BABE}} (B)$}} is a tuple and consists of
  the following components:
  \[ (d, \pi, j, s) \]
  in which:
  
  \begin{center}
    \begin{tabular}{rl}
      $\pi, d$: & the results of the block lottery for slot s. \\
      $j$: & the index of the block producer in the authority directory of the
      current epoch\\
      s: & the slot at which the block is produced.
    \end{tabular}
    
    \ 
  \end{center}
  
  \
  
  $H_{\tmop{BABE}} (B)$ must be included as a digest item of Pre-Runtime type
  in the header digest $H_d (B)$ as defined in Definition \ref{defn-digest}. 
\end{definition}

\begin{definition}
  \label{defn-block-signature}\label{defn-babe-seal}The {\tmstrong{Block
  Signature}} $S_B$ is a signature of the block header hash (see
  Definition\ref{defn-block-header-hash}) and defined as
  \[ \tmop{Sig}_{\tmop{SR} 25519, \tmop{sk}^s_j} (H_h (B)) \]
  $S_B$ should be included in $H_d (B)$ as the Seal digest item according to
  Definition \ref{defn-digest} of value:
  \[ (E_{\tmop{id}} (\tmop{BABE}), S_B) \]
  in which, $E_{\tmop{id}} (\tmop{BABE})$ is the BABE consensus engine unique
  identifier defined in Definition \ref{defn-consensus-message-digest}. The
  Seal digest item is referred to as the {\tmstrong{BABE Seal}}.
\end{definition}

\

\custombinding{11}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{11}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-block-production}\tmverbatim{}{\tmname{Invoke-Block-Authoring}}($\tmop{sk}$,
      pk, $n$, $\tmop{BT} : \tmop{Current} \tmop{Block} \tmop{Tree}$)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

{\tmname{Add-Digest-Item}} appends a digest item to the end of the header
digest $H_d (B)$ according to Definition \ref{defn-digest}.

\subsection{Epoch Randomness}\label{sect-epoch-randomness}

\begin{definition}
  \label{defn-epoch-randomness}For epoch $\mathcal{E}$, there is a 32-byte
  \tmtextbf{randomness seed} $\mathcal{R}_{\mathcal{E}}$ computed based on the
  previous epochs VRF outputs. For $\mathcal{E}_0$ and $\mathcal{E}_1$, the
  randomness seed is provided in the genesis state.
\end{definition}

At the beginning of each epoch, $\mathcal{E}_n$ the host will receive the
randomness seed $\mathcal{R}_{\mathcal{E}_{n + 1}}$(Definition
\ref{defn-epoch-randomness}) necessary to participate in the block production
lottery in the next epoch $\mathcal{E}_{n + 1}$ from the Runtime, through the
\tmtextit{Next Epoch Data} consensus message (Definition
\ref{defn-consensus-message-digest}) in the digest of the first block.

\subsection{Verifying Authorship Right}\label{sect-verifying-authorship}

When a Polkadot node receives a produced block, it needs to verify if the
block producer was entitled to produce the block in the given slot by running
Algorithm \ref{algo-verify-authorship-right} where:
\begin{itemizeminus}
  \item T$_B$ is $B$'s arrival time defined in Definition
  \ref{defn-block-time}.
  
  \item $H_d (B)$ is the digest sub-component of $\tmop{Head} (B)$ defined in
  Definitions \ref{defn-block-header} and \ref{defn-digest}.
  
  \item The Seal $D_s$ is the last element in the digest array $H_d (B)$ as
  defined in Definition \ref{defn-digest}.
  
  \item {\tmname{Seal-Id}} is the type index showing that a digest item of
  variable type is of {\tmem{Seal}} type (See Definitions
  \ref{defn-scale-variable-type} and \ref{defn-digest})
  
  \item $\tmop{AuthorityDirectory}^{\mathcal{E}_c}$ is the set of Authority ID
  for block producers of epoch $\mathcal{E}_c$.
  
  \item {\tmname{verify-Slot-Winner}} is defined in Algorithm
  \ref{algo-verify-slot-winner}.
\end{itemizeminus}
\custombinding{12}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{12}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-verify-authorship-right}{\tmname{Verify-Authorship-Right}}($\tmop{Head}_s
      (B)$: The header of the block being verified) 
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

Algorithm \ref{algo-verify-slot-winner} runs as a part of the verification
process, when a node is importing a block, in which:
\begin{itemizeminus}
  \item {\tmname{Epoch-Randomness}} is defined in Definition
  \ref{defn-epoch-randomness}.
  
  \item $H_{\tmop{BABE}} (B)$ is the BABE header defined in Definition
  \ref{defn-babe-header}.
  
  \item {\tmname{Verify-VRF}} is described in Section \ref{sect-vrf}.
  
  \item $\tau$ is the winning threshold defined in
  \ref{defn-winning-threshold}.
\end{itemizeminus}
\custombinding{13}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{13}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-verify-slot-winner}{\tmname{Verify-Slot-Winner}}($B$: the
      block whose winning status to be verified)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

$(d_B, \pi_B)$: Block Lottery Result for Block $B$,

$s_n$: the slot number,

$n$: Epoch index

AuthorID: The public session key of the block producer

\subsection{Block Building Process}\label{sect-block-building}

The blocks building process is triggered by Algorithm
\ref{algo-block-production} of the consensus engine which runs Alogrithm
\ref{algo-build-block}.

\custombinding{14}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{14}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-build-block}{\tmname{Build-Block}}($C_{\tmop{Best}}$: The
      chain is where at its head, the block to be constructed, is
      
      s: Slot number)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}
\begin{itemizeminus}
  \item $\tmop{Head} (B)$ is defined in Definition \ref{defn-block-header}.
  
  \item {\tmname{Call-Runtime-Entry}} is defined in Notation
  \ref{nota-call-into-runtime}.
  
  \item {\tmname{Inherent-Data}} is defined in Definition
  \ref{defn-inherent-data}.
  
  \item {\tmname{End-Of-Slot}} indicates the end of the BABE slot as defined
  in Algorithm \ref{algo-slot-time} respectively Definition
  \ref{defn-epoch-slot}.
  
  \item {\tmname{Next-Ready-Extrinsic}} indicates picking an extrinsic from
  the extrinsics queue (Definition \ref{defn-transaction-queue}).
  
  \item {\tmname{Block-Is-Full}} indicates that the maximum block size is
  being used.
  
  \item {\tmname{Should-Drop}} determines based on the result {\tmem{R}}
  whether the extrinsic should be dropped or remain in the extrinsics queue
  and scheduled for the next block. The \tmverbatim{ApplyExtrinsicResult} as
  defined in Definition \ref{defn-rte-apply-extrinsic-result} describes this
  behavior in more detail.
  
  \item {\tmname{Drop}} indicates removing the extrinsic from the extrinsic
  queue (Definition \ref{defn-transaction-queue}).
  
  \item {\tmname{Add-Seal}} adds the seal to the block as defined in
  Definition \ref{defn-digest} before sending it to peers. The seal is removed
  again before submitting it to the Runtime.
\end{itemizeminus}
\section{Finality}\label{sect-finality}

The Polkadot Host uses GRANDPA Finality protocol
{\cite{stewart_grandpa:_2019}} to finalize blocks. Finality is obtained by
consecutive rounds of voting by the validator nodes. Validators execute
GRANDPA finality process in parallel to Block Production as an independent
service. In this section, we describe the different functions that GRANDPA
service performs to successfully participate in the block-finalization
process.

\subsection{Preliminaries}

\begin{definition}
  \label{defn-grandpa-voter}A {\tmstrong{GRANDPA Voter}}, $v$, represented by
  a key pair $(k^{\tmop{pr}}_v, v_{\tmop{id}})$ where $k_v^{\tmop{pr}}$
  represents an $\tmop{ED} 25519$ private key, is a node running a GRANDPA
  protocol and broadcasting votes to finalize blocks in a Polkadot Host-based
  chain. The {\tmstrong{set of all GRANDPA voters}} for a given block B is
  indicated by $\mathbb{V}_B$. In that regard, we have {\todo{change function
  name, only call at genesis, adjust V\_B over the sections}}
  \[ \mathbb{V}_B = \text{\tmverbatim{grandpa\_authorities}} (B) \]
  where $\texttt{grandpa\_authorities}$ is the entry into the Runtime
  described in Section \ref{sect-rte-grandpa-auth}. We refer to $\mathbb{V}_B
  $ as $\mathbb{V}$ when there is no chance of ambiguity.
  
  Analogously we say that a Polkadot node is a {\tmstrong{non-voter node }}for
  block $B$, if it does not own any of the key pairs in $\mathbb{V}_B$.
\end{definition}

\begin{definition}
  \label{defn-authority-set-id}The {\tmstrong{authority set Id}}
  ($\tmop{id}_{\mathbb{V}}$) is an incremental counter which tracks the amount
  of authority list changes that occurred (Definition
  \ref{defn-consensus-message-digest}). Starting with the value of zero at
  genesis, the Polkadot Host increments this value by one every time a
  {\tmstrong{Scheduled Change}} or a {\tmstrong{Forced Change}} occurs. The
  authority set Id is an unsigned 64-bit integer.
\end{definition}

\begin{definition}
  {\tmstrong{GRANDPA state}}, $\tmop{GS}$, is defined as {\todo{verify V\_id
  and id\_V usage, unify}}
  \[ \tmop{GS} \assign \{\mathbb{V}, \tmop{id}_{\mathbb{V}}, r\} \]
  where:
  
  $\textbf{\ensuremath{\mathbb{V}}}$: is the set of voters.
  
  $\textbf{id\tmrsub{\ensuremath{\mathbb{V}}}}$: is the authority set ID as
  defined in Definition \ref{defn-authority-set-id}.
  
  {\tmstrong{r}}: is the votin\tmverbatim{}g round number.
\end{definition}

Following, we need to define how the Polkadot Host counts the number of votes
for block $B$. First, a vote is defined as:

\begin{definition}
  \label{defn-vote}A {\tmstrong{GRANDPA vote }}or simply a vote for block $B$
  is an ordered pair defined as
  \[ V_{\nosymbol} (B) \assign (H_h (B), H_i (B)) \]
  where $H_h (B)$ and $H_i (B)$ are the block hash and the block number
  defined in Definitions \ref{defn-block-header} and
  \ref{defn-block-header-hash} respectively.
\end{definition}

\begin{definition}
  Voters engage in a maximum of two sub-rounds of voting for each round $r$.
  The first sub-round is called {\tmstrong{pre-vote}} and\tmverbatim{} the
  second sub-round is called {\tmstrong{pre-commit}}.
  
  By {\tmstrong{$V_v^{r, \tmop{pv}}$}} and {\tmstrong{$V_v^{r, \tmop{pc}}$}}
  we refer to the vote cast by voter $v$ in round $r$ (for block $B$) during
  the pre-vote and the pre-commit sub-round respectively.
\end{definition}

Voting is done by means of broadcasting voting messages to the network. The
structure of these messages is described in Section \ref{sect-msg-grandpa}.
Validators inform their peers about the block finalized in round $r$ by
broadcasting a commit message (see Algorithm \ref{algo-grandpa-round} for more
details).

\begin{definition}
  \label{defn-sign-round-vote}{\tmstrong{$\tmop{Sign}^{r,
  \tmop{stage}}_{v_i}$}} refers to the signature of a voter for a specific
  message in a round and is formally defined as:
  \[ \tmop{Sign}^{r, \tmop{stage}}_{v_i} : = \tmop{Sig}_{\tmop{ED} 25519}
     (\tmop{msg}, r, \tmop{id}_{\mathbb{V}}) \]
  Where:
  
  {\center{\begin{tabular}{lll}
    msg & the message to be signed & arbitrary\\
    r: & round number & unsigned 64-bit integer\\
    $\tmop{id}_{\mathbb{V}}$ & authority set Id (Definition
    \ref{defn-authority-set-id}) of v & unsigned 64-bit integer
  \end{tabular}}}
  
  \ 
\end{definition}

\begin{definition}
  \label{defn-grandpa-justification}The {\tmstrong{justification}} for block B
  in round $r$, $\tmmathbf{J^{r, \tmop{stage}} (B)}$, is a vector of pairs of
  the type:
  \[ (V (B'), \tmop{Sign}^{r, \tmop{stage}}_{v_i} (B'), v_{\tmop{id}}) \]
  in which either
  \[ B' \geqslant B \]
  or $V^{r, \tmop{pc}}_{v_i} (B')$ is an equivocatory vote.
  
  \
  
  In all cases, $\tmop{Sign}^{r, \tmop{stage}}_{v_i} (B')$, as defined in
  Definition \ref{defn-sign-round-vote}, is the signature of voter $v_i \in
  \mathbb{V}_B$ broadcasted during either the pre-vote (stage = pv) or the
  pre-commit (stage = pc) sub-round of round r. A {\tmstrong{valid
  justification}} must only contain up-to-one valid vote from each voter and
  must not contain more than two equivocatory votes from each voter.
\end{definition}

\begin{definition}
  \label{defn-finalizing-justification}We say $J^{r, \tmop{pc}} (B)$
  {\tmstrong{justifies the finalization}} of $B' \geqslant B$ {\tmstrong{for a
  non-voter node $n$}} if the number of valid signatures in $J^{r, \tmop{pc}}
  (B)$ for $B'$ is greater than $\frac{2}{3} |\mathbb{V}_B |$.
\end{definition}

Note that $J^{r, \tmop{pc}} (B)$ can only be used by a non-voter node to
finalize a block. In contrast, a voter node can only be assured of the
finality of block $B$ by actively participating in the voting process. That is
by invoking Algorithm \ref{algo-grandpa-round}. See Definition
\ref{defn-finalized-block} for more details.

\

The GRANDPA protocol dictates how an honest voter should vote in each
sub-round, which is described in Algorithm \ref{algo-grandpa-round}. After
defining what constitutes a vote in GRANDPA, we define how GRANDPA counts
votes.

\begin{definition}
  \label{defn-equivocation}Voter $v$ {\tmstrong{equivocates}} if they
  broadcast two or more valid votes to blocks during one voting sub-round. In
  such a situation, we say that $v$ is an {\tmstrong{equivocator}} and any
  vote $V_v^{r, \tmop{stage}} (B)$ cast by $v$ in that sub-round is an
  {\tmstrong{equivocatory vote}}, and
  \[ \mathcal{E}^{r, \tmop{stage}} \]
  represents the set of all equivocators voters in sub-round
  ``$\tmop{stage}$'' of round $r$. When we want to refer to the number
  of\tmverbatim{} equivocators whose equivocation has been observed by voter
  $v$ we refer to it by:
  \[ \mathcal{E}^{r, \tmop{stage}}_{\tmop{obs} (v)} \]
  The Polkadot Host must detect equivocations committed by other validators
  and submit those to the Runtime as described in Section
  \ref{sect-grandpaapi_submit_report_equivocation_unsigned_extrinsic}.
\end{definition}

\begin{definition}
  A vote $V_v^{r, \tmop{stage}} = V (B)$ is {\tmstrong{invalid}} if
  \begin{itemize}
    \begin{itemizedot}
      \item $H (B)$ does not correspond to a valid block;
      
      \item $B$ is not an (eventual) descendant of a previously finalized
      block;
      
      \item $M^{r, \tmop{stage}}_v$ does not bear a valid signature;
      
      \item $\tmop{id}_{\mathbb{V}}$ does not match the current $\mathbb{V}$;
      
      \item If $V_v^{r, \tmop{stage}}$ is an equivocatory vote.
    \end{itemizedot}
  \end{itemize}
\end{definition}

\begin{definition}
  For validator v, {\tmstrong{the set of observed direct votes for Block $B$
  in round $r$}}, formally denoted by ${\tmop{VD}^{r,
  \tmop{stage}}_{\tmop{obs} (v)}}^{\nosymbol}_{\nosymbol} (B)$ is equal to the
  union of:
  \begin{itemizedot}
    \item set of {\underline{valid}} votes $V^{r, \tmop{stage}}_{v_i}$ cast in
    round $r$ and received by v such that $V^{r, \tmop{stage}}_{v_i} = V (B)$.
  \end{itemizedot}
\end{definition}

\begin{definition}
  \label{defn-observed-votes}We refer to {\tmstrong{the set of total votes
  observed by voter $v$ in sub-round ``$\tmop{stage}$'' of round $r$}} by
  {\tmstrong{${V^{r, \tmop{stage}}_{\tmop{obs}
  (v)}}^{\nosymbol}_{\nosymbol}$}}.
  
  The {\tmstrong{set of all observed votes by $v$ in the sub-round stage of
  round $r$ for block $B$}}, {\tmstrong{$V^{r, \tmop{stage}}_{\tmop{obs} (v)}
  (B)$}} is equal to all of the observed direct votes cast for block $B$ and
  all of the $B$'s descendants defined formally as:
  \[ V^{r, \tmop{stage}}_{\tmop{obs} (v)} (B) \assign \bigcup_{v_i \in
     \mathbb{V}, B \geqslant B'} \tmop{VD}^{r, \tmop{stage}}_{\tmop{obs} (v)}
     {(B')_{\nosymbol}^{\nosymbol}}_{\nosymbol} \]
  The {\tmstrong{total number of observed votes for Block $B$ in round $r$}}
  is defined to be the size of that set plus the total number of equivocator
  voters:
  \[ \#V^{r, \tmop{stage}}_{\tmop{obs} (v)} (B) = |V^{r,
     \tmop{stage}}_{\tmop{obs} (v)} (B) | + | \mathcal{E}^{r,
     \tmop{stage}}_{\tmop{obs} (v)} | \]
\end{definition}

Note that for genesis state we always have $\#V_{\tmop{obs} (v)}^{r,
\tmop{pv}} (B) = | \mathbb{V} |$.

\begin{definition}
  \label{defn-total-potential-votes}Let $V^{r, \tmop{stage}}_{\tmop{unobs}
  (v)}$ be the set of voters whose vote in the given stage has not been
  received. We define the {\tmstrong{total number of potential votes for Block
  $B$ in round $r$}} to be:
  \[ \#V^{r, \tmop{stage}}_{\tmop{obv} (v), \tmop{pot}} (B) \assign |V^{r,
     \tmop{stage}}_{\tmop{obs} (v)} (B) | + | V^{r,
     \tmop{stage}}_{\tmop{unobs} (v)} | + \tmop{Min} \left( \frac{1}{3} |
     \mathbb{V} |, | \mathbb{V} | - |V^{r, \tmop{stage}}_{\tmop{obs} (v)} (B)
     | - | V^{r, \tmop{stage}}_{\tmop{unobs} (v)} | \right) \]
\end{definition}

\begin{definition}
  The current {\tmstrong{pre-voted}} block {\tmstrong{$B^{r,
  \tmop{pv}}_v$}}also know as GRANDPA GHOST is the block chosen by Algorithm
  \ref{algo-grandpa-ghost}:
  \[ B^{r, \tmop{pv}}_v \assign \text{{\tmname{GRANDPA-GHOS{\CYRT}}}} (r) \]
\end{definition}

Finally, we define when a voter $v$ sees a round as completable, that is when
they are confident that $B_v^{r, \tmop{pv}}$ is an upper bound for what is
going to be finalized in this round.

\begin{definition}
  \label{defn-grandpa-completable}We say that round $r$ is
  {\tmstrong{completable}} if $|V^{r, \tmop{pc}}_{\tmop{obs} (v)} |
  +\mathcal{E}^{r, \tmop{pc}}_{\tmop{obs} (v)} > \frac{2}{3} \mathbb{V}$ and
  for all $B' > B_v^{r, \tmop{pv}}$:
  \[ \begin{array}{l}
       |V^{r, \tmop{pc}}_{\tmop{obs} (v)} | -\mathcal{E}^{r,
       \tmop{pc}}_{\tmop{obs} (v)} - |V^{r, \tmop{pc}}_{\tmop{obs}
       (v)_{\nosymbol}} (B') | > \frac{2}{3} |\mathbb{V}|
     \end{array} \]
\end{definition}

Note that in practice we only need to check the inequality for those $B' >
B_v^{r, \tmop{pv}}$ where $|V^{r, \tmop{pc}}_{\tmop{obs} (v)_{\nosymbol}} (B')
| > 0$.

\subsection{Initiating the GRANDPA State}

In order to participate coherently in the voting process, a validator must
initiate its state and sync it with other active validators. In particular,
considering that voting is happening in different distinct rounds where each
round of voting is assigned a unique sequential round number $r_v$, it needs
to determine and set its round counter $r$ equal to the voting round $r_n$
currently undergoing in the network. Algorithm \ref{algo-initiate-grandpa}
mandates the initialization procedure for GRANDPA protocol for a joining
validator.

\custombinding{15}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{15}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-initiate-grandpa}{\tmname{Initiate-Grandpa}}(
      
      $r_{\tmop{last}}$: last round number (See the following),
      
      , $B_{\tmop{last}}$: the last block which has been finalized on the
      chain (see Definition \ref{defn-finalized-block})
      
      )
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

$r_{\tmop{last}}$ is equal to the latest round the voter has observed that
other voters are voting on. The voter obtains this information through various
gossiped messages including those mentioned in Definition
\ref{defn-finalized-block}.

$r_{\tmop{last}}$ is set to 0 if the GRANDPA node is initiating the GRANDPA
voting process as a part of a new authority set. This is because the GRANDPA
round number reset to 0 for every authority set change.

\subsubsection{Voter Set Changes}

Voter set changes are signalled by Runtime via a consensus engine message as
described in Section \ref{sect-consensus-message-digest}. When Authorities
process such messages they must not vote on any block with a higher number
than the block at which the change is supposed to happen. The new authority
set should reinitiate GRANDPA protocol by executing Algorithm
\ref{algo-initiate-grandpa}.

\subsection{Voting Process in Round $r$}

For each round $r$, an honest voter $v$ must participate in the voting process
by following Algorithm \ref{algo-grandpa-round}.

\custombinding{16}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{16}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-grandpa-round}{\tmname{Play-Grandpa-round}}$(r)$
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

Where:
\begin{itemizeminus}
  \item $T$ is sampled from a log-normal distribution whose mean and standard
  deviation are equal to the average network delay for a message to be sent
  and received from one validator to another.
  
  \item {\tmname{Derive-Primary}} is described in Algorithm
  \ref{algo-derive-primary}.
  
  \item The condition of {\tmem{completablitiy}} is defined in Definition
  \ref{defn-grandpa-completable}.
  
  \item {\tmname{Best-Final-Candidate}} function is explained in Algorithm
  \ref{algo-grandpa-best-candidate}.
  
  \item {\tmname{{\tmname{Attempt-To-Finalize-Round}}($r$)}} is described in
  Algorithm \ref{algo-attempt-tofinalize}.
  
  \item {\tmname{Finalizabl}} is defined in Algorithm \ref{algo-finalizable}.
\end{itemizeminus}
\custombinding{17}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{17}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-derive-primary}{\tmname{Derive-Primary}}($r$: the GRANDPA
      round whose primary to be determined)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

$\mathbb{V}$ is the GRANDPA voter set as defined in Definition
\ref{defn-grandpa-voter}.

\custombinding{18}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{18}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-grandpa-best-candidate}{\tmname{Best-Final-Candidate}}($r$)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

$\#V^{r, \tmop{stage}}_{\tmop{obv} (v), \tmop{pot}}$ is defined in Definition
\ref{defn-total-potential-votes}.

\custombinding{19}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{19}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-grandpa-ghost}{\tmname{GRANDPA-GHOST}}($r$)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

Where
\begin{itemizeminus}
  \item $B_{\tmop{last}}$ is the last block which has been finalized on the
  chain (see Definitin \ref{defn-finalized-block})
  
  \item $\#V_{\tmop{obs} (v)}^{r, \tmop{pv}} (B)$ is defined in Definition
  \ref{defn-observed-votes}.
\end{itemizeminus}
\custombinding{20}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{20}}}{\smallskip}
    
    \begin{tmindent}
      {\tmname{Best-PreVote-Candidate($r$:}} voting round to cast the pre-vote
      in)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

\custombinding{21}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{21}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-finalizable}{\tmname{Finalizable}}($r :$voting
      round\tmverbatim{})
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

The condition of {\tmem{completablitiy}} is defined in Definition
\ref{defn-grandpa-completable}.

\custombinding{22}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{22}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-attempt-tofinalize}{\tmname{Attempt-To-Finalize-Round}}($r$)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

Note that we might not always succeed in finalizing our best final candidate
due to the possibility of equivocation. Example \ref{exmp-candid-unfinalized}
serves to demonstrate such a situation:

\begin{example}
  \label{exmp-candid-unfinalized}Let us assume that we have 100 voters and
  there are two blocks in the chain ($B_1 < B_2$). At round 1, we get 67
  pre-votes for $B_2$ and at least one pre-vote for $B_1$ which means that
  {\tmname{GRANDPA-GHOST(1) = $B_2$}}.
  
  Subsequently, potentially honest voters who could claim not seeing all the
  pre-votes for $B_2$ but receiving the pre-votes for $B_1$ would pre-commit
  to $B_1$. In this way, we receive 66 pre-commits for $B_1$ and 1 pre-commit
  for $B_2$. Henceforth, we finalize $B_1$ since we have a threshold commit
  (67 votes) for $B_1$.
  
  At this point, though, we have {\tmname{Best-Final-Candidate}}($r$)$= B_2$
  as $\#V^{r, \tmop{stage}}_{\tmop{obv} (v), \tmop{pot}} (B_2) = 67$ and $2 >
  1$.
  
  However, at this point, the round is already completable as we know that we
  have {\tmname{GRANDPA-GHOST(1) = $B_2$}} as an upper limit on what we can
  finalize and nothing greater than $B_2$ can be finalized at $r = 1$.
  Therefore, the condition of Algorithm \ref{algo-grandpa-round}:14 is
  satisfied and we must proceed to round 2.
  
  Nonetheless, we must continue to attempt to finalize round 1 in the
  background as the condition of \ref{algo-attempt-tofinalize}:3 has not been
  fulfilled.
  
  This prevents us from proceeding to round 3 until either:
  \begin{itemizeminus}
    \item We finalize $B_2$ in round 2, or
    
    \item We receive an extra pre-commit vote for $B_1$ in round 1. This will
    make it impossible to finalize $B_2$ in round 1, no matter to whom the
    remaining pre-commits are going to be cast for (even with considering the
    possibility of 1/3 of voter equivocating) and therefore we have
    {\tmname{Best-Final-Candidate}}($r$)$= B_1$.
  \end{itemizeminus}
  Both scenarios unblock the Algorithm \ref{algo-grandpa-round}:14
  {\tmname{Last-Finalized-Block}}$\geqslant${\tmname{Best-Final-Candidate}}($r$-1))
  albeit in different ways: the former with increasing the
  {\tmname{Last-Finalized-Block}} and the latter with decreasing
  {\tmname{Best-Final-Candidate}}($r$-1).
\end{example}

\section{Block Finalization}\label{sect-block-finalization}

\begin{definition}
  \label{defn-finalized-block}A Polkadot relay chain node $n$ should consider
  block $B$ as {\tmstrong{finalized}} if any of the following criteria hold
  for $B' \geqslant B$:
  \begin{itemize}
    \item ${V^{r, \tmop{pc}}_{\tmop{obs} (n)}}^{\nosymbol}_{\nosymbol} (B') >
    2 / 3 |\mathbb{V}_{B'} |$.
    
    \item it receives a $M_v^{r, \tmop{Fin}} (B')$ message in which $J^r (B)$
    justifies the finalization (according to Definition
    \ref{defn-grandpa-justification}).
    
    \item it receives a block data message for $B'$ with $\tmop{Just} (B')$
    defined in Section \ref{sect-justified-block-header} which justifies the
    finalization. 
  \end{itemize}
\end{definition}

for
\begin{itemizedot}
  \item any round $r$ if the node $n$ is {\tmem{not}} a GRANDPA voter.
  
  \item only for rounds $r$ for which the node $n$ has invoked Algorithm
  \ref{algo-grandpa-round} if $n$ is a GRANDPA voter.
\end{itemizedot}
Note that all Polkadot relay chain nodes are supposed to process GRANDPA
commit messages regardless of their GRANDPA voter status.

\subsection{Catching up}\label{sect-grandpa-catchup}

When a Polkadot node (re)joins the network during the process described in
Chapter \ref{chap-bootstrapping}, it requests the history of state transition
in the form of blocks, which it is missing. Each finalized block comes with
the Justification of its finalization as defined in Definition
\ref{defn-grandpa-justification}. Through this process, they can synchronize
the authority list currently performing the finalization process.

\subsubsection{Sending the catch-up
requests}\tmverbatim{}\label{sect-sending-catchup-request}

When a Polkadot node has the same authority list as a peer node who is
reporting a higher number for the ``finalized round'' field, it should send a
catch-up request message, as specified in Definition
\ref{defn-grandpa-catchup-request-msg}, to the reporting peer in order to
catch-up to the more advanced finalized round, provided that the following
criteria hold:
\begin{itemizeminus}
  \item the peer node is a GRANDPA voter, and
  
  \item the last known finalized round for the Polkadot node is at least 2
  rounds behind the finalized round for the peer. 
\end{itemizeminus}
\subsubsection{Processing the catch-up requests}

Only GRANDPA voter nodes are required to respond to the catch-up responses.
When a GRANDPA voter node receives a catch-up request message it needs to
execute Algorithm \ref{algo-process-catchup-request}.

\custombinding{23}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{23}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-process-catchup-request}{\tmname{ProcessCatchupRequest}}(
      
      $M_{i, v}^{\tmop{Cat} - q} (\tmop{id}_{\mathbb{V}}, r)$: The catch-up
      message received from peer $i$ (See Definition
      \ref{defn-grandpa-catchup-request-msg})
      
      )
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

In which:
\begin{itemizeminus}
  \item $\tmop{id}_{\mathbb{V}}$ is the voter set id with which the serving
  node is operating
  
  \item $r$ is the round number for which the catch-up is requested for.
  
  \item $\mathbb{P}$ is the set of immediate peers of node $v$.
  
  \item {\tmname{Last-Completed-Round}} is {\todo{define:
  https://github.com/w3f/polkadot-spec/issues/161}}
  
  \item $M_{v, i}^{\tmop{Cat} - s} (\tmop{id}_{\mathbb{V}}, r)$ is the
  catch-up response defined in Definition
  \ref{defn-grandpa-catchup-response-msg}.
\end{itemizeminus}

\subsubsection{Processing catch-up responses}

A Catch-up response message contains critical information for the requester
node to update their view on the active rounds which are being voted on by
GRANDPA voters. As such, the requester node should verify the content of the
catch-up response message and subsequently updates its view of the state of
the finality of the Relay chain according to Algorithm
\ref{algo-process-catchup-response}.

\custombinding{24}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{24}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-process-catchup-response}
      {\tmname{Process-Catchup-Response}}(
      
      $M_{v, i}^{\tmop{Cat} - s} (\tmop{id}_{\mathbb{V}}, r)$: the catch-up
      response received from node $v$ (See Definition
      \ref{defn-grandpa-catchup-response-msg})
      
      )
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

\section{Bridge design (BEEFY)}\label{sect-grandpa-beefy}

{\todo{NOTE: The BEEFY protocol is currently in early development and subject
to change}}

\

The BEEFY (Bridge Effiency Enabling Finality Yielder) is a secondary protocol
to GRANDPA to support efficient bridging between the Polkadot network (relay
chain) and remote, segregated blockchains, such as Ethereum, which were not
built with the Polkadot interchain operability in mind. The protocol allows
participants of the remote network to verify finality proofs created by the
Polkadot relay chain validators. In other words: clients in the Ethereum
network should able to verify that the Polkadot network is at a specific
state.

\

Storing all the information necessary to verify the state of the remote
chain, such as the block headers, is too expensive. BEEFY stores the
information in a space-efficient way and clients can request additional
information over the protocol.

\subsection{Preliminaries}

\begin{definition}
  Merkle Mountain Ranges, {\tmstrong{MMR}}, as defined in Definition
  {\todo{TODO}} are used as an efficient way to send block headers and
  signatures to light clients.
\end{definition}

\begin{definition}
  \label{defn-beefy-statement}The {\tmstrong{statement}} is the same piece of
  information which every relay chain validator is voting on. Namely, the MMR
  root of all the block header hashes leading up to the latest, finalized
  block.
\end{definition}

\begin{definition}
  {\tmstrong{\label{defn-beefy-witness-data}Witness data}} contains the
  statement as defined in Definition \ref{defn-beefy-statement}, an array
  indicating which validator of the Polkadot network voted for the statement
  (but not the signatures themselves) and a MMR root of the signatures. The
  indicators of which validator voted for the statement are just claimes and
  provide no proofs . The network message is defined in Definition
  \ref{defn-grandpa-beefy-signed-commitment-witness} and the relayer saves it
  on the chain of the remote network.
\end{definition}

\begin{definition}
  \label{defn-beefy-light-client}A {\tmstrong{light client}} is an abstract
  entity in a remote network such as Ethereum. It can be a node or a smart
  contract with the intent of requesting finality proofs from the Polkadot
  network. A light client reads the witness data as defined in Definition
  \ref{defn-beefy-witness-data} from the chain, then requests the signatures
  directly from the relayer in order to verify those.
  
  \
  
  The light client is expected to know who the validators are and has access
  to their public keys.
\end{definition}

\begin{definition}
  \label{defn-beefy-relayer}A {\tmstrong{relayer}} (or ``prover'') is an
  abstract entity which takes finality proofs from the Polkadot network and
  makes those available to the light clients. Inherently, the relayer tries to
  convince the light clients that the finality proofs have been voted for by
  the Polkadot relay chain validators. The relayer operates offchain and can
  for example be a node or a collection of nodes.
\end{definition}

\subsection{Voting on Statements}

The Polkadot Host signs a statement as defined in Definition
\ref{defn-beefy-statement} and gossips it as part of a vote as defined in
Definition \ref{defn-msg-beefy-gossip} to its peers on every new, finalized
block. The Polkadot Host uses ECDSA for signing the statement, since Ethereum
has better compatibility for it compared to SR25519 or ED25519. {\todo{how
does one map the validator set keys to the corresponding ECDSA keys?}}

\subsection{Committing Witnesses}\label{sect-beefy-committing-witnesses}

The relayer as defined in Definition \ref{defn-beefy-relayer} participates in
the Polkadot network by collecting the gossiped votes as defined in Definition
\ref{defn-msg-beefy-gossip}. Those votes are converted into the witness data
structure as defined in Definition \ref{defn-beefy-witness-data}. and the
relayer saves the data on the chain of the remote network. The occurrence of
saving witnesses on remote networks is undefined.

\

How the witness data is saved on the remote chain varies among networks or
implementations. On Ethereum, for example, the relayer could call a smart
contract which saves the witness data on chain and light clients can fetch
this data.

\

{\todo{Add note about 2/3 majority}}

\subsection{Requesting Signed Commitments}

A light client as defined in Definition \ref{defn-beefy-light-client} fetches
the witness data as defined in Definition \ref{defn-beefy-witness-data} from
the chain. Once the light client knows which validators apparently voted for
the specified statement, it needs to request the signatures from the relayer
to verify whether the claims are actually true. This is achieved by requesting
signed commitments as defined in Definition
\ref{defn-grandpa-beefy-signed-commitment}.

How those signed commitments are requested by the light client and delivered
by the relayer varies among networks or implementations. On Ethereum, for
example, the light client can request the signed commitments in form of a
transaction, which results in a response in form of a transaction. {\todo{If
the signed commitments are just transactions, which are stored in the
blockchain, why bother with witnesses?}}

\

\begin{flushright}
  {\qed}
\end{flushright}

\

\

\chapter{Availability \& Validity}

\section{Introduction}

As clarified in Chapter 1, Polkadot serves as a replicated shared-state
machine designed to resolve scalability issues and interoperability among
blockchains. The validators of Polkadot execute transactions and participate
in the consensus of Polkadots primary chain, the so called {\tmem{relay
chain}}. {\tmem{Parachains}} are independent networks that maintain their own
state and are connected to the relay chain. Those parachains can take
advantage of the relay chain consensus mechanism, including sending and
receiving messages to and from other parachains. Parachain nodes that send
parachain blocks, known as {\tmem{candidates}}, to the validators in order to
be inlcuded in relay chain are referred to as {\tmem{collators}}.

\

The Polkadot relay chain validators are responsible for guaranteeing the
validity of both relay chain and parachain blocks. Additionally, the
validators are required to keep enough parachain blocks that should be
included in the relay chain available in their local storage in order to make
those retrievable by peers, who lack the information, to reliably confirm the
issued validity statements about parachain blocks. The Availability \&
Validity (AnV) protocol consists of multiple steps for successfully upholding
those responsibilities.

\

Parachain blocks themselves are produced by collators as described in Section
\ref{sect-collations}, whereas the relay chain validators only verify their
validity (and later, their availability). It is possible that the collators of
a parachain \ produces multiple parachain block candidates for a child of a
specific block. Subsequently, they send the block candadiates to the the relay
chain validators who are assigned to the specific parachain. The assignment is
determined by the Runtime as described in Section
\ref{sect-candidate-backing}. Those validators are then required to check the
validity of submitted candidates as described in Section
\ref{sect-candidate-validation}, then issue and collect statements about the
validity of candidates to other validators as described in Section
\ref{sect-candidate-backing-statements}. This process is known as
{\tmem{candidate backing}}. Once a candidate meets a specified criteria for
inclusion, the selected relay chain block author then choses any of the backed
candidate for each parachain and includes those into the relay chain block as
described in Section \ref{sect-candidate-inclusion}.

\

Every relay chain validator must fetch the proposed candidates and issue
votes on whether they have the candidate saved in their local storage, so
called {\tmem{availability votes}} as described in Section
\ref{sect-availability-votes}, then also collect the votes sent by other
validators and include them in the relay chain state, as described in Section
\ref{sect-candidate-inclusion}. This process ensures that only relay chain
blocks get finalized where each candidate is available on enough nodes of
validators.

\

Parachain candidates contained in {\tmem{non-finalized}} (Section
\ref{sect-finality}) relay chain blocks must then be retrieved by a secondary
set of relay chain validators, unrelated from the candidate backing process,
who are randomly assigned to determine the validity of specific parachains
based on a VRF lottery and are then required to vote on the validity of those
candidates as described in Section \ref{sect-approval-voting}. This process is
known as {\tmem{approval voting}}. If a validator does not have the candidate
data, it must recover the candidate data as described in Section
\ref{sect-availability-recovery}.

\section{Preliminaries}

\begin{definition}
  A {\tmstrong{collator}} is a parachain node that sends parachain blocks,
  known as candidates as defined in Definition \ref{defn-candidate}, to the
  relay chain validators. The relay chain validators are not concerned how the
  collator works or how it creates candidates.
\end{definition}

\begin{definition}
  \label{defn-candidate}A {\tmstrong{candidate}} is a submitted parachain
  block as defined in Definition \ref{defn-parablock} to the relay chain
  validators. A parachain block stops being referred to as a candidate as soon
  it has been finalized.
\end{definition}

\begin{definition}
  \label{defn-parablock}A {\tmstrong{parachain block}} or a
  {\tmstrong{Proof-of-Validity block}} (PoV block) contains the necessary data
  to for parachain specific state transition logic. Relay chain validators are
  not concerned with the inner structure of the block and treat it as a byte
  array.
\end{definition}

\begin{definition}
  \label{defn-para-head-data}The {\tmstrong{head data}} is contains
  information about a parachain block as defined in Definition
  \ref{defn-parablock}. The head data is returned by executing the parachain
  Runtime and relay chain validators are not concerned with its inner
  structure and treat it as a byte arrays. 
\end{definition}

\begin{definition}
  \label{defn-para-id}The {\tmstrong{Parachain Id}} is a unique, unsigned
  32-bit integer which serves as an identifier of a parachain, assigned by the
  Runtime. 
\end{definition}

\begin{definition}
  {\tmstrong{\label{defn-availability-cores}Availability cores}} are slots
  used to process parachains. The Runtime assigns each parachain to a
  availability core and validators can fetch information about the cores, such
  as parachain block candidates, by calling the appropriate Runtime API as
  described in Section \ref{sect-rt-api-availability-cores}. Validators are
  not concerned with the internal workings from the Runtimes perspective.
\end{definition}

\begin{definition}
  {\tmstrong{\label{defn-validator-groups}Validator groups}} indicate which
  validators are responsible for creating backable candidates for certain
  parachains, as described in Section \ref{sect-candidate-backing}, and are
  assigned by the Runtime. Validators are not concerned with the internal
  workings from the Runtimes perspective. Collators can use this information
  for submitting blocks.
\end{definition}

\begin{definition}
  \label{defn-upward-message}An {\tmstrong{upward message}} is an opaque byte
  array sent from a parachain to a relay chain.
\end{definition}

\begin{definition}
  \label{defn-downward-message}A {\tmstrong{downward message}} is an opaque
  byte array received by the parachain from the relay chain.
\end{definition}

\begin{definition}
  \label{defn-outbound-hrmp-message}An {\tmstrong{outbound HRMP message}}
  (Horizontal Relay-routed Message Passing) is sent from the perspective of a
  sender of a parachain to an other parachain by passing it through the relay
  chain. It's a datastructure of the following format:
  \begin{eqnarray*}
    & (I, M) & 
  \end{eqnarray*}
  where $I$ is the recipient Id as defined in Definition \ref{defn-para-id}
  and $M$ is an upward message as defined in Definition
  \ref{defn-upward-message}. 
\end{definition}

\begin{definition}
  \label{defn-inbound-hrmp-message}An {\tmstrong{inbound HRML message}}
  (Horizontal Relay-routed Message Passing) is seen from the perspective of a
  recipient parachain sent from an other parachain by passing it through the
  relay chain. It's a datastructure of the following format:
  \begin{eqnarray*}
    & (N, M) & 
  \end{eqnarray*}
  where $N$ is the relay chain block number at which the message was passed
  down to the recipient parachain and $M$ is a downward message as defined in
  Definition \ref{defn-downward-message}.
\end{definition}

\section{Collations}\label{sect-collations}

Collations are proposed candidates (see Definition \ref{defn-candidate}) to
the Polkadot relay chain validators. The Polkodat network protocol is agnostic
on what candidate productionis mechanism each parachain uses and does not
specify or mandate any of such production methods (e.g. BABE-GRANDPA, Aura,
etc). Furthermore, the relay chain validator host implementation itself does
not directly interpret or process teh internal transactions of the candidate,
but rather rely on the parachain Runtime to validate the candidate, as
described in Section \ref{sect-candidate-validation}. Collators, which are
parachain nodes which produce candidate proposals and send them to the relay
chain validator, must prepare pieces of data specified in Definition
\ref{defn-collation} in order to correctly comply with the requirements of the
parachain protocol.

\begin{definition}
  \label{defn-collation}A {\tmstrong{collation}} is a datastructure which
  contains the proposed parachain candidate, including an optional validation
  parachain Runtime update and upward messages. The collation datastructure,
  $C$, is a datastructure of the following format:
  \begin{eqnarray*}
    C & = & (M, H, R, h, P, p, w)\\
    M & = & (u_n, \ldots u_m)\\
    H & = & (z_n, \ldots z_m)
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $M$ is an array of upward messages, $u$, interpreted by the relay
    chain itself, as defined in Definition \ref{defn-upward-message}.
    
    \item $H$ is an array of outbound horizontal messages, $z$, interpreted by
    other parachains, as defined in Definition
    \ref{defn-outbound-hrmp-message}
    
    \item $R$ is an \tmverbatim{Option} type as defined in Definition
    \ref{defn-option-type} which can contain a parachain Runtime update. The
    new Runtime code is an array of bytes.
    
    \item $H$ is the head data as defined in Definition
    \ref{defn-para-head-data} produced as a result of execution of the
    parachain specific logic.
    
    \item $P$ is the PoV block as defined in Definition \ref{defn-pov-block}.
    
    \item $p$ is an unsigned 32-bit integer indicating the number of downward
    messages processed as defined in Definition \ref{defn-downward-message}.
    
    \item $w$ is an unsigned 32-bit integer indicating the mark up to which
    all inbound HRMP messages have been processed by the parachain.
  \end{itemizedot}
\end{definition}

\section{Candidate Backing}\label{sect-candidate-backing}

The Polkadot validator receives an arbitrary number of parachain candidates
with associated proofs from untrusted collators. The validator must verify and
select a specific quantity of the proposed candidates and issue those as
{\tmem{backable}} candidates to its peers. A candidate is considered
{\tmem{backable}} when at least $2 / 3$ of all assigned validators have issued
a \tmverbatim{Valid} statement about that candidate, as described in Section
\ref{sect-candidate-backing-statements}. Validators can retrieve information
about assignments via the Runtime APIs \ref{sect-rt-api-validator-groups}
respectively \ref{sect-rt-api-availability-cores}.

\subsection{Statements}\label{sect-candidate-backing-statements}

The assigned validator checks the validity of the proposed parachains blocks
as described in Section \ref{sect-candidate-validation} and issues
\tmverbatim{Valid} statements as defined in Definition
\ref{net-msg-full-statement} to its peers if the verification succeeded.
Broadcasting failed verification as \tmverbatim{Valid} statements is a
slashable offense. The validator must only issue one \tmverbatim{Seconded}
statement, based on an arbitrary metric, which implies an explicit vote for a
candidate to be included in the relay chain.

\

{\todo{reference disputes}}

\

This protocol attempts to produce as many backable candidates as possible,
but does not attempt to determine a final candidate for inclusion. Once a
parachain candidate has been seconded by at least one other validator and
enough \tmverbatim{Valid} statements have been issued about that candidate to
meet the $2 / 3$ quorum, the candidate is ready to be inlcuded in the relay
chain as described in Section \ref{sect-candidate-inclusion}.

\

The validator issues validity statements votes in form of a validator
protocol message as defined in Definition
\ref{net-msg-collator-protocol-message}.

\begin{definition}
  \label{net-msg-full-statement}A {\tmstrong{statement}}, $S$, is a
  datastructure of the following format:
  \begin{eqnarray*}
    S & = & (d, A_i, A_s)\\
    d & = & \left\{\begin{array}{l}
      1 \rightarrow C_r\\
      2 \rightarrow C_h
    \end{array}\right.
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $d$ is a varying datatype where $1$ indicates that the validator
    ``seconds'' a candidate, meaning that the candidate should be included in
    the relay chain, followed by the committed candidate receipt, $C_r$, as
    defined in Definition \ref{defn-committed-candidate-receipt}. $2$
    indicates that the validator has deemed the candidate valid, followed by
    the candidate hash.
    
    \item $C_h$ is the candidate hash.
    
    \item $A_i$ is the validator index in the authority set that signed this
    statement.
    
    \item $A_s$ is the signature of the validator.
  \end{itemizedot}
\end{definition}

\begin{definition}
  \label{defn-bitfield-array}A {\tmstrong{bitfield array}} contains single-bit
  values which indidate whether a candidate is available. The number of items
  is equal of to the number of availability cores as defined in Definition
  \ref{defn-availability-cores} and each bit represents a vote on the
  corresponding core in the given order. Respectively, if the single bit
  equals \tmverbatim{1}, then the Polkadot validator claims that the
  availability core is occupied, there exists a committed candidate receipt as
  defined in Definition \ref{defn-committed-candidate-receipt} and that the
  validator has a stored chunk of the parachain block as defined in Definition
  \ref{sect-availability-recovery}.
\end{definition}

\subsection{Inclusion}\label{sect-candidate-inclusion}

The Polkadot validator includes the backed candidates as inherent data as
defined in Definition \ref{defn-parachain-inherent-data} into a block as
described in Section \ref{sect-inherents}. The relay chain block author
decides on whatever metric which candidate should be selected for inclusion,
as long as that candidate is valid and meets the validity quorum of $2 / 3 +$
as described in Section \ref{sect-candidate-backing-statements}. The candidate
approval process as described in Section \ref{sect-approval-voting} ensures
that only relay chain blocks are finalized where each candidate for each
availability core meets the requirement of 2/3+ availability votes.

\begin{definition}
  \label{defn-parachain-inherent-data}The {\tmstrong{parachain inherent data}}
  contains backed candidates and is included when authoring a relay chain
  block. The datastructure, $I$, is of the following format:
  \begin{eqnarray*}
    I & = & (A, T, D, P_h)\\
    T & = & (C_0, \ldots C_n)\\
    D & = & (d_n, \ldots d_m)\\
    C & = & (R, V, i)\\
    V & = & (a_n, \ldots a_m)\\
    a & = & \left\{\begin{array}{l}
      1 \rightarrow s\\
      2 \rightarrow s
    \end{array}\right.\\
    A & = & (L_n, \ldots L_m)\\
    L & = & (b, v_i, s)
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $A$ is an array of signed bitfields by validators claiming the
    candidate is available (or not). The array must be sorted by validator
    index corresponding to the authority set as described in Section
    \ref{defn-authority-list}.
    
    \item $T$ is an array of backed candidates for inclusing in the current
    block.
    
    \item $D$ is an array of disputes.
    
    \item $P_h$ is the parachain parent head data as defined in Definition
    \ref{defn-para-head-data}.
    
    \item $d$ is a dispute statement as described in Section
    \ref{sect-anv-disputes}.
    
    \item $R$ is a committed candidate receipt as defined in Definition
    \ref{defn-committed-candidate-receipt}.
    
    \item $V$ is an array of validity votes themselves, expressed as
    signatures.
    
    \item $i$ is a bitfield of indices of the validators within the validator
    group as defined in Definition \ref{defn-validator-groups}.
    
    \item $a$ is either an implicit or explicit attestation of the validity of
    a parachain candidate, where $1$ implies an implicit vote (in
    correspondence of a \tmverbatim{Seconded} statement) and $2$ implies an
    explicit attestation (in correspondence of a \tmverbatim{Valid}
    statement). Both variants are followed by the signature of the validator.
    
    \item $s$ is the signature of the validator.
    
    \item $b$ the availability bitfield as described in Section
    \ref{sect-availability-votes}.
    
    \item $v_i$ is the validator index of the authority set as defined in
    Definition \ref{defn-authority-list}.
  \end{itemizedot}
\end{definition}

\begin{definition}
  \label{defn-candidate-receipt}A {\tmstrong{candidate receipt}}, R, contains
  information about the candidate and a proof of the results of its execution.
  It's a datastructure of the following format:
  \begin{eqnarray*}
    R & = & (D, C_h)
  \end{eqnarray*}
  where $D$ is the candidate descriptor as defined in Definition
  \ref{defn-candidate-descriptor} and $C_h$ is the hash of candidate
  commitments as defined in Definition \ref{defn-candidate-commitments}.
\end{definition}

\begin{definition}
  \label{defn-committed-candidate-receipt}The {\tmstrong{committed candidate
  receipt}}, $R$, contains information about the candidate and the the result
  of its execution that is included in the relay chain. This type is similiar
  to the candidate receipt as defined in Definition
  \ref{defn-candidate-receipt}, but actually contains the execution results
  rather than just a hash of it. It's a datastructure of the following format:
  \begin{eqnarray*}
    R & = & (D, C)
  \end{eqnarray*}
  where $D$ is the candidate descriptor as defined in Definition
  \ref{defn-candidate-descriptor} and C is the candidate commitments as
  defined in Definition \ref{defn-candidate-commitments}.
\end{definition}

\begin{definition}
  \label{defn-candidate-descriptor}The {\tmstrong{candidate descriptor}}, $D$,
  is a unique descriptor of a candidate receipt. It's a datastructure of the
  following format:
  \begin{eqnarray*}
    D & = & (p, H, C_i, V, B, r, s, p_h, R_h)
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $p$ is the parachain Id as defined in Definition \ref{defn-para-id}.
    
    \item $H$ is the hash of the relay chain block the candidate is executed
    in the context of.
    
    \item $C_i$ is the collators public key.
    
    \item $V$ is the hash of the persisted validation data as defined in
    Definition \ref{defn-persisted-validation-data}.
    
    \item $B$ is the hash of the PoV block.
    
    \item $r$ is the root of the block's erasure encoding Merkle tree.
    {\todo{clarify}}
    
    \item $s$ the collator signature of the concatenated components $p$, $H$,
    $R_h$ and $B$.
    
    \item $p_h$ is the hash of the parachain head data as described in
    Definition \ref{defn-para-head-data} of this candidate.
    
    \item $R_h$ is the hash of the parachain Runtime.
  \end{itemizedot}
\end{definition}

\begin{definition}
  The \label{defn-candidate-commitments}\tmtextbf{candidate commitments}, $C$,
  is the result of the execution and validation of a parachain (or parathread)
  candidate whose produced values must be committed to the relay chain. Those
  values are retrieved from the validation result as defined in Definition
  \ref{defn-validation-result}. A candidate commitment is a datastructure of
  the following format:
  
  \begin{alignat*}{2}
    C & = (M\tmrsub{u},M\tmrsub{h},R,h,p,w)
  \end{alignat*}
  
  where:
  \begin{itemize}
    \item $M_u$ is an array of upward messages sent by the parachain. Each
    individual message, $m$, is an array of bytes.
    
    \item $M_h$ is an array of outbound horizontal messages sent by the
    parachain. Each individual messages, $t$, is a datastructure as defined in
    Definition \ref{defn-outbound-hrmp-message}.
    
    \item $R$ is an \tmverbatim{Option} value as described in Section
    \ref{defn-option-type} that can contain a new parachain Runtime in case of
    an update.
    
    \item $h$ is the parachain head data as described in Definition
    \ref{defn-para-head-data}.
    
    \item $p$ is a unsigned 32-bit intiger indicating the number of downward
    messages that were processed by the parachain. It is expected that the
    parachain processes the messages from frist to last.
    
    \item $w$ is a unsigned 32-bit integer indicating the watermark which
    specifies the relay chain block number up to which all inbound horizontal
    messages have been processed.
  \end{itemize}
\end{definition}

\section{Candidate Validation}\label{sect-candidate-validation}

Received candidates submitted by collators and must have its validity verified
by the assigned Polkadot validators. For each candidate to be valid, the
validator must successfully verify the following condidations in the following
order:
\begin{enumeratenumeric}
  \item The candidate does not exceed any parameters in the persisted
  validation data as defined in Definition
  \ref{defn-persisted-validation-data}.
  
  \item The signature of the collator is valid.
  
  \item Validate the candidate by executing the parachain Runtime as defined
  in Definition \ref{sect-parachain-runtime}.
\end{enumeratenumeric}
If all steps are valid, the Polkadot validator must create the necessary
candidate commitments as defined in Definition
\ref{defn-candidate-commitments} and submit the appropriate statement for each
candidate as described in Section \ref{sect-candidate-backing-statements}.

\subsection{Parachain Runtime}\label{sect-parachain-runtime}

Parachain Runtimes are stored in the relay chain state, and can either be
fetched by the parachain Id or the Runtime hash via the relay chain Runtime
API as described in Section \ref{sect-rt-api-validation-code} and
\ref{sect-rt-api-validation-code-by-hash} respectively. The retrieved
parachain Runtime might need to be decompressed based on the magic identifier
as described in Section \ref{sect-runtime-compression}.

\

In order to validate a parachain block, the Polkadot validator must prepare
the validation parameters as defined in Definition
\ref{defn-validation-parameters}, then use its local Wasm execution
environment as described in Section \ref{sect-code-executor} to execute the
\tmverbatim{validate\_block} parachain Runtime API by passing on the
validation parameters as an argument. The parachain Runtime function returns
the validation result as defined in Definition \ref{defn-validation-result}.

\begin{definition}
  \label{defn-validation-parameters}The {\tmstrong{validation parameters}}
  structure, $P$, is required to validate a candidate against a parachain
  Runtime. It's a datastructure of the following format:
  \begin{eqnarray*}
    P & = & (h, b, B_i, S_r)
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $h$ is the parachain head data as defined in Definition
    \ref{defn-para-head-data}.
    
    \item $b$ is the block body as defined in Definition \ref{defn-parablock}.
    
    \item $B_i$ is the latest relay chain block number.
    
    \item $S_r$ is the relay chain block storage root as defined in Definition
    \ref{sect-merkl-proof}.
  \end{itemizedot}
\end{definition}

\begin{definition}
  \label{defn-validation-result}The {\tmstrong{validation result}} is returned
  by the \tmverbatim{validate\_block} parachain Runtime API after attempting
  to validate a parachain block. Those results are then used in candidate
  commitments as defined in Definition \ref{sect-merkl-proof}., which then
  will be inserted into the relay chain via the parachain inherent data as
  described in Definition \ref{defn-parachain-inherent-data}. The validation
  result, V, is a datastructure of the following format:
  \begin{eqnarray*}
    V & = & (h, R, M_u, M_h, p , w)\\
    M_u & = & (m_0, \ldots m_n)\\
    M_h & = & (t_0, \ldots t_n)
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $h$ is the parachain head data as defined in Definition
    \ref{defn-para-head-data}.
    
    \item $R$ is an \tmverbatim{Option} value as described in Section
    \ref{defn-option-type} that can contain a new parachain Runtime in case of
    an update.
    
    \item $M_u$ is an array of upward messages sent by the parachain. Each
    individual message, $m$, is an array of bytes.
    
    \item $M_h$ is an array of outbound horizontal messages sent by the
    parachain. Each individual message, $t$, is a datastructure as defined in
    Definition \ref{defn-outbound-hrmp-message}.
    
    \item $p$ is a unsigned 32-bit integer indicating the number of downward
    messages that were processed by the parachain. It is expected that the
    parachain processes the messages from first to last.
    
    \item $w$ is a unsigned 32-bit integer indicating the watermark which
    specifies the relay chain block number up to which all inbound horizontal
    messages have been processed.
  \end{itemizedot}
\end{definition}

\subsection{Runtime Compression}\label{sect-runtime-compression}

{\todo{todo}}

\section{Availability}

\subsection{Availability Votes}\label{sect-availability-votes}

The Polkadot validator must issue a bitfield as defined in Definition
\ref{defn-bitfield-array} which indicates votes for the availabilty of
candidates. Issued bitfields can be used by the validator and other peers to
determine which backed candidates meet the $2 / 3 +$ availability quorum.

\

Candidates are inserted into the relay chain in form of inherent data by a
block author, as described in Section \ref{sect-candidate-inclusion}. A
validator can retrieve that data by calling the appropriate Runtime API entry
as described in Section \ref{sect-rt-api-availability-cores}, then create a
bitfield indicating for which candidate the validator has availability data
stored and broadcast it to the network as defined in Definition
\ref{net-msg-bitfield-dist-msg}. When sending the bitfield distrubtion
message, the validator must ensure $B_h$ is set approriately, therefore
clarifying to which state the bitfield is referring to, given that candidates
can vary based on the chain fork.

\

Missing availability data of candidates must be recovered by the validator as
described in Section \ref{sect-availability-recovery}. If previously issued
bitfields are no longer accurate, i.e. the availability data has been
recovered or the candidate of an availablity core has changed, the validator
must create a new bitfield and boradcast it to the network. Candidates must be
kept available by validators for a specific amount of time. If a candidate
does not receive any backing, validators should keep it available for about
one hour, in case the state of backing does change. Backed and even approved
candidates (described in Section \ref{sect-approval-voting}) must be kept by
validators for about 25 hours, since disputes (described in Section
{\todo{todo}}) can occure and the candidate needs to be checked again.

\

The validator issues availability votes in form of a validator protocol
message as defined in Definition \ref{net-msg-collator-protocol-message}.

\subsection{Candidate Recovery}\label{sect-availability-recovery}

The availability distribution of the Polkadot validator must be able to
recover parachain candidates that the validator is assigned to, in order to
determine whether the candidate should be backed as described in Section
\ref{sect-candidate-backing} repsectively whether the candidate should be
approved as described in Section \ref{sect-approval-voting}. Additionally,
peers can send availability requests as defined in Definition
\ref{net-msg-chunk-fetching-request} and Definition
\ref{net-msg-available-data-request} to the validator, which the validator
should be able to respond to.

\

Candidates are recovered by sending requests for specific indices of erasure
encoded chunks. Erasure encoding is described in Section {\todo{todo}}. A
validator should request chunks by picking peers randomly and must recover at
least $f + 1$ chunks, where $n = 3 f + k$ and $k \in \{ 1, 2, 3 \}$. $n$ is
the number of validators as specified in the session info, which can be
fetched by the Runtime API as described in Section
\ref{sect-rt-api-session-info}.

\section{Approval Voting}\label{sect-approval-voting}

The approval voting process ensures that only valid parachain blocks are
finalized on the relay chain. After {\tmem{backable}} parachain candidates
were submitted to the relay chain, as described in Section
\ref{sect-candidate-inclusion}, which can be retrieved by the Runtime API as
described in Section \ref{sect-rt-api-availability-cores}, validators need to
determine their assignments for each parachain and issue approvals for valid
candidates, respectively disputes for invalid candidates. Since it cannot be
expected that each validator verifies every single parachain candidate, this
mechanism ensures that enough honest validators are selected to verify
parachain candidates in order prevent the finalization of invalid blocks. If
an honest validator detects an invalid block which was approved by one or more
validators, the honest validator must issue a disputes which wil cause
escalations, resulting in consequences for all malicious parties, i.e.
slashing. This mechanism is described more in Section
\ref{sect-availability-assingment-criteria}.

\subsection{Assignment Criteria}\label{sect-availability-assingment-criteria}

Validators determine their assignment based on a VRF mechanism, similiar to
the BABE consensus mechanism. First, validators generate an availability core
VRF assignment as defined in Definition \ref{defn-aval-core-vrf-assignment},
which indicates which availability core a validator is assigned to. Then a
{\tmem{delayed}} availability core VRF assignment is generated which indicates
at what point a validator should start the approval process. The delays are
based on ``tranches'', as described in Section \ref{defn-tranches}.

\

An assigned validator never broadcasts their assignment until relevant. Once
the assigned validator is ready to check a candidate, the validator broadcasts
their assignment by issuing an approval distribution message as defined in
Definition \ref{net-msg-approval-distribution}, where $M$ is of variant $0$.
Other assigned validators that receive that network message must keep track of
if, expecting an approval vote following shortly after. Assigned validators
can retrieve the candidate by using the availability recovery as described in
Section \ref{sect-availability-recovery} and then validate the candidate as
described in Section \ref{sect-candidate-validation}.

\

The validator issues approval votes in form of a validator protocol message
as defined in Definition \ref{net-msg-validator-protocol-message} and disputes
as described in Section \ref{sect-anv-disputes}.

\subsection{Tranches}\label{defn-tranches}

Validators use a subjective, tick-based system to determine when the approval
process should start. A validator starts the tick-based system when a new
availability core candidates have been proposed, which can be retrieved via
the Runtime API as described in Section \ref{sect-rt-api-availability-cores},
and increments the tick every 500 Milliseconds. Each tick/increment is
referred to as a ``tranche'', represented as an integer, starting at $0$.

\

As described in Section \ref{sect-availability-assingment-criteria}, the
validator first executes the VRF mechanism to determine which parachains
(availability cores) the validator is assigned to, then an additional VRF
mechanism for each assigned parachain to determine the {\tmem{delayed
assignment}}. The delayed assignment indicites the tranche at which the
validator should start the approval process. A tranche of value 0 implies that
the assignment should be started immediately, while later assignees of later
tranches wait until it's their term to issue assignments, determined by their
subjective, tick-based system.

\

Validators are required to track broadcasted assignments by other validators
assigned to the same parachain, including verifying the VRF output. Once a
valid assignment from a peer was received, the validator must wait for the
following approval vote within a certain period as described in Section
\ref{sect-rt-api-session-info} by orienting itself on its local, tick-based
system. If the waiting time after a broadcasted assignment exceeds the
specified period, the validator interprets this behavior as a ``no-show'',
indicating that more validators should commit on their tranche until enough
approval votes have been collected.

\

If enough approval votes have been collected as described in Section
\ref{sect-rt-api-session-info}, then assignees of later tranches do not have
to start the approval process. Therefore, this tranche system serves as a
mechanism to ensure that enough candidate approvals from a {\tmem{random}} set
of validators are created without requiring all assigned validators to check
the candidate.

\

{\todo{TODO: Move all VRF related definitions to the VRF sections}}

\begin{definition}
  \label{defn-relay-vrf-story}The {\tmstrong{relay VRF story}} is an array of
  random bytes derived from the VRF submitted within the block by the block
  author. The relay VRF story, $T$, is used as input to determine approval
  voting criteria and generated the following way:
  \begin{eqnarray*}
    T & = & \text{{\tmname{Transcript{\tmname{}}}}} (b_r, b_s, e_i, A)
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item {\tmname{Transcript}} constructs a VRF transcript as defined in
    Definition {\todo{todo}}.
    
    \item $b_r$ is the BABE randomness of the current epoch as defined in
    Definition {\todo{todo}}.
    
    \item $b_s$ is the current BABE slot as defined in Definition
    {\todo{todo}}.
    
    \item $e_i$ is the current BABE epoch index as defined in Definition
    {\todo{todo}}.
    
    \item A is the public key of the authority.
  \end{itemizedot}
\end{definition}

\begin{definition}
  \label{defn-aval-core-vrf-assignment}An {\tmstrong{availability core VRF
  assignment}}, $T$, is computed by a relay chain validator to determine which
  availability core as defined in Definition \ref{defn-availability-cores} a
  validator is assigned to and should vote for approvals. The assignment
  consits of a VRF pair, $v$, as defined in Definition \ref{defn-vrf-pair} and
  a VRF proof, $p$, as defined in Definition \ref{defn-vrf-proof}:
  \begin{eqnarray*}
    T & = & (v, p)
  \end{eqnarray*}
  The Runtime dictates how many assignments should be conducted by a
  validator, as specified in the session index which can be retrieved via the
  Runtime API as described in Section \ref{sect-rt-api-session-info}. The
  amount of assignments is referred to as ``samples''. For each iteration of
  the number of samples, the validator calculates an individual assignment,
  $T$, where the little-endian encoded sample number, $S$, is incremented by
  one. At the beginning of the iteration, $S$ starts at value $0$.
  
  \
  
  The validator executes the following steps to retrieve a (possibly valid)
  core index:
  \begin{eqnarray*}
    t & \leftarrow & \text{{\tmname{Create-Transcript}}} \left(
    \text{\tmrsup{''}A\&V MOD\tmrsup{''}} \right)\\
    t & \leftarrow & \text{{\tmname{Meta-Ad}}} \left( t \text{,
    \tmrsup{''}RC-VRF\tmrsup{''}}, R_s \right)\\
    t & \leftarrow & \tmname{\text{Meta-Ad}} \left( t \text{,
    \tmrsup{''}sample\tmrsup{''}}, S \right)\\
    e & \leftarrow & \tmname{\text{Evaluate-VRF}} (s_k, t)\\
    b & \leftarrow & \text{{\tmname{Make-Bytes}}} \left( e, 4 \text{,
    \tmrsup{''}A\&V CORE\tmrsup{''}} \right)\\
    c_i & \leftarrow & \text{{\tmname{LE}}} (b) \tmop{mod} a_c
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item {\tmname{Create-Transcript}} is a function defined in Definition
    \ref{defn-vrf-create-transcript}.
    
    \item {\tmname{Meta-Ad}} is a function defined in Definition
    {\todo{todo}}.
    
    \item {\tmname{Evaluate-VRF}} is a function defined in Definition
    \ref{defn-vrf-evaluate-vrf}.
    
    \item {\tmname{LE}} implies that the 4-byte input is converted to a
    little-endian encoded 32-bit interger.
    
    \item {\tmname{Make-Bytes}} is a function defined in Definition
    \ref{defn-vrf-make-bytes}.
    
    \item $R_s$ is the relay VRF story as defined in Definition
    \ref{defn-relay-vrf-story}.
    
    \item $s_k$ is the secret key of the validator.
    
    \item $a_c$ is the number of availablity cores used during the active
    session, as defined in the session info retrieved by the Runtime API as
    defined in Definition \ref{sect-rt-api-session-info}.
  \end{itemizedot}
  
  
  The resulting integer, $c_i$, indicates the parachain Id as defined in
  Definition \ref{defn-para-id}. If the Id doesn't exist, as can be retrieved
  by the Runtime API as described in Section
  \ref{sect-rt-api-availability-cores}, the validator discards that value and
  continues with the next iteration. If the Id does exist, the validators
  continues with the following steps:
  \begin{eqnarray*}
    t & \leftarrow & \text{{\tmname{Create-Transcript}}} \left(
    \text{\tmrsup{''}A\&V ASSIGNED\tmrsup{''}} \right)\\
    t & \leftarrow & \text{{\tmname{Meta-Ad}}} \left( t \text{,
    \tmrsup{''}core\tmrsup{''}}, c_i \right)\\
    (p, \tmmathbf{\phi}) & \leftarrow & \tmname{\text{DLEQ-Proove}} (s_k, t,
    e)\\
    T & = & (e, p)
  \end{eqnarray*}
  where{\tmname{ DLEQ-Proove}} is a function defined in Definition
  \ref{defn-vrf-dleq-proove}. Hence, the full list of available core VRF
  assignments is represtend as:
  \begin{eqnarray*}
    & \{ T_n, \ldots, T_m \} & 
  \end{eqnarray*}
  where each $T_x$ corresponds to a sample number. The amount of individual
  assignments does not necessarily equal the number of samples, but the amount
  must not exceed the number of samples.
\end{definition}

\begin{definition}
  \label{defn-delayed-aval-core-vrf-assignment}The {\tmstrong{delayed
  availability core VRF assignments}} determined at what point a validator
  should start the approval process as described in Section
  \ref{defn-tranches}. The validator executes the following steps:
  \begin{eqnarray*}
    t & \leftarrow & \text{{\tmname{Create-Transcript}}} \left(
    \text{\tmrsup{''}A\&V DELAY\tmrsup{''}} \right)\\
    t & \leftarrow & \text{{\tmname{Meta-Ad}}} (t,'' \tmop{RC} - \tmop{VRF}'',
    R_s)\\
    t & \leftarrow & \text{{\tmname{Meta-Ad}}} (t,'' \tmop{core}'', c_i)\\
    e & \leftarrow & \text{{\tmname{Evaluate-VRF}}} (s_k, t )\\
    t  & \leftarrow & \text{{\tmname{Create-Transcript}}} ('' \tmop{VRF}'')\\
    (p, x) & \leftarrow & \text{{\tmname{DLEQ-Proove}}} (s_k, t, e)
  \end{eqnarray*}
  The resulting values $e$ and $p$ are the VRF pair as defined in Definition
  \ref{defn-vrf-pair} respectively the VRF proof as defined in Definition
  \ref{defn-vrf-proof}.
  
  \
  
  The {\tmstrong{tranche}}, $d$, is determined as:
  \begin{eqnarray*}
    b & = & \text{{\tmname{Make-Bytes}}} \left( e, 4,'' \text{A\&V TRANCHE}''
    \right)\\
    d & = & \tmop{LE} (b) \tmop{mod} (d_c + d_z) - d_z
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item {\tmname{Make-Bytes}} is a function defined in Definition
    \ref{defn-vrf-make-bytes}.
    
    \item {\tmname{LE}} implies that the 4-byte input is converted to a
    little-endian encoded 32-bit interger.
    
    \item $d_c$ is the number of delayed tranches by total as specified by the
    session info, retrieved via the Runtime API as described in Section
    \ref{sect-rt-api-session-info}.
    
    \item $d_z$ is the zeroth delay tranche width as specified by the session
    info, retrieved via the Runtime API as described in Section
    \ref{sect-rt-api-session-info}.
  \end{itemizedot}
  The resulting tranche, $n$, cannot be less than $0$. If the tranche is less
  than $0$, then $d = 0$.
\end{definition}

\begin{definition}
  \label{defn-vrf-pair}The {\tmstrong{VRF Pair}} is a datastructure that
  contains both the VRV input and its corresponding output.
\end{definition}

\begin{definition}
  \label{defn-vrf-proof}The {\tmstrong{VRF proof}} and {\tmstrong{VRF
  batchable proof}} {\textdots} {\todo{todo}} {\todo{does batchable proof need
  to be specced?}}
\end{definition}

\begin{definition}
  \label{defn-vrf-transcript}The {\tmstrong{transcript}} {\textdots}
  {\todo{todo}}
\end{definition}

\begin{definition}
  \label{defn-vrf-evaluate-vrf}The {\tmname{Evaluate-VRF}} function takes a
  public key, $k$, a transcript, $t$, as defined in Definition
  \ref{defn-vrf-transcript} and procudes a VRF-Pair, $p$, as defined in
  Definition \ref{defn-vrf-pair}.
  \begin{eqnarray*}
    p & \leftarrow & \tmname{\text{Evaluate-VRF}} (k, t)
  \end{eqnarray*}
  The functions executes the following steps: {\todo{todo}}
\end{definition}

\begin{definition}
  \label{defn-vrf-dleq-proove}The {\tmname{DLEQ-Proove}} function takes a
  private key, $s_k$, and a transcript, $t$, as defined in Definition
  \ref{defn-vrf-transcript} and a VRF pair, $v$, as defined in Definition
  \ref{defn-vrf-pair} and produces a VRF proof and a VRF batchable proof, $p$
  respectively $p_b$, as defined in Definition \ref{defn-vrf-proof}.
  \begin{eqnarray*}
    (p, p_b) & \leftarrow & \text{{\tmname{DLEQ-Proove}}} (s_k, t, v)
  \end{eqnarray*}
  The functions executed the following steps: {\todo{todo}}
\end{definition}

\begin{definition}
  \label{defn-vrf-create-transcript}The {\tmname{Create-Transcript}} function
  takes a context, $c$, represented as a UTF-8 encoded string and produces a
  transcript, $t$, as defined in Definition \ref{defn-vrf-transcript}.
  \begin{eqnarray*}
    t & \leftarrow & \text{{\tmname{Create-Transcript}}} (c)
  \end{eqnarray*}
  The function executes the following steps: {\todo{todo}}
\end{definition}

\begin{definition}
  \label{defn-vrf-make-bytes}The {\tmname{Make-Bytes}} function takes a VRF
  Pair, $p$, as defined in Definition \ref{defn-vrf-pair}, the size of the
  buffer in bytes, $s$, and a context, $c$, represtended as a UTF-8 encoded
  string and produces the raw byte output of the VRF.
  \begin{eqnarray*}
    b & \leftarrow & \text{{\tmname{Make-Bytes}}} (p, s, c)
  \end{eqnarray*}
\end{definition}

\subsection{Disputes}\label{sect-anv-disputes}

{\todo{TODO}}

\section{Runtime Api}

\subsection{validators}\label{sect-rt-api-validators}

Returns the validator set at the current state. The specified validators are
responsible for backing parachains for the current state.

\

{\tmstrong{Arguments}}
\begin{itemizedot}
  \item None.
\end{itemizedot}


{\tmstrong{Return}}
\begin{itemizedot}
  \item An array of public keys representing the validators.
\end{itemizedot}
\subsection{validator\_groups}\label{sect-rt-api-validator-groups}

Returns the validator groups as defined in Definition
\ref{defn-validator-groups} used during the current session. The validators in
the groups are referred to by the validator set Id as defined in Definition
\ref{defn-authority-list}.

\

{\tmstrong{Arguments}}
\begin{itemizedot}
  \item None
\end{itemizedot}


{\tmstrong{Return}}
\begin{itemizedot}
  \item An array of tuples, $T$, of the following format:
  \begin{eqnarray*}
    T & = & (I, G)\\
    I & = & (v_n, \ldots v_m)\\
    G & = & (B_s, f, B_c)
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $I$ is an array the validator set Ids as defined in Definition
    \ref{defn-authority-list}.
    
    \item $B_s$ indicates the block number where the session started.
    
    \item $f$ indicates how often groups rotate. $0$ means never.
    
    \item $B_c$ indicates the current block number. 
  \end{itemizedot}
\end{itemizedot}
\subsection{availability\_cores}\label{sect-rt-api-availability-cores}

Returns information on all availability cores as defined in Definition
\ref{defn-availability-cores}.

\

{\tmstrong{Arguments}}
\begin{itemizedot}
  \item None
\end{itemizedot}


{\tmstrong{Return}}
\begin{itemizedot}
  \item An array of core states, $S$, of the following format:
  \begin{eqnarray*}
    S & = & \left\{\begin{array}{l}
      0 \rightarrow C_o\\
      1 \rightarrow C_s\\
      2 \rightarrow \tmmathbf{\phi}
    \end{array}\right.\\
    C_o & = & (n_u, B_o, B_t, n_t, b, G_i, C_h, C_d)\\
    C_s & = & (P_{\tmop{id}}, C_i)
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $S$ specifies the core state. $0$ indicates that the core is
    occupied, $1$ implies it's currently free but scheduled and given the
    opportunity to occupy and $2$ implies it's free and there's nothing
    scheduled.
    
    \item $n_u$ is an \tmverbatim{Option} as described in Definition
    \ref{defn-option-type} which can contain a $C_s$ value if the core was
    freed by the Runtime and indicates the assignment that is next scheduled
    on this core. An empty value indicates there is nothing scheduled.
    
    \item $B_o$ indicates the relay chain block number at which the core got
    occupied.
    
    \item $B_t$ indicates the relay chain block number the core will time-out
    at, if any.
    
    \item $n_t$ is an \tmverbatim{Option} as described in Definition
    \ref{defn-option-type} which can contain a $C_s$ value if the core is
    freed by a time-out and indicates the assignment that is next scheduled on
    this core. An empty value indicates there is nothing scheduled.
    
    \item $b$ is a bitfield array as defined in Definition
    \ref{defn-bitfield-array}. A $> 2 / 3$ majority of assigned validators
    voting with $1$ values means that the core is available.
    
    \item $G_i$ indicates the assigned validator group index as defined in
    Definition \ref{defn-validator-groups} is to distribute availability
    pieces of this candidate.
    
    \item $C_h$ indicates the hash of the candidate occypying the core.
    
    \item $C_d$ is the candidate descriptor as defined in Definition
    \ref{defn-candidate-descriptor}.
    
    \item $C_i$ is an \tmverbatim{Option} as described in Definition
    \ref{defn-option-type} which can contain the collators public key
    indicating who should author the block.
  \end{itemizedot}
\end{itemizedot}
\subsection{persisted\_validation\_data}\label{sect-rt-api-persisted-validation-data}

Returns the persistend validation data for the given parachain Id and a given
occupied core assumption.

\

{\tmstrong{Arguments}}
\begin{itemizedot}
  \item The parachain Id as defined in Definition \ref{defn-para-id}.
  
  \item An occupied core assumption as defined in Definition
  \ref{defn-occupied-core-assumption}.
\end{itemizedot}


{\tmstrong{Return}}
\begin{itemizedot}
  \item An \tmverbatim{Option} as described in Definition
  \ref{defn-option-type} which can contain the persisted validation data as
  defined in Definition \ref{defn-persisted-validation-data}. The value is
  empty if the parachain Id is not registered or the core assumption is of
  index $2$, meaning that the core was freed.
\end{itemizedot}
\begin{definition}
  \label{defn-occupied-core-assumption}A {\tmstrong{occupied core assumption}}
  is used for fetching certain pieces of information about a parachain by
  using the relay chain API. The assumption indicates how the Runtime API
  should compute the result. {\todo{how does the node make assumptions?}} The
  assumptions, $A$, is a varying datatype of the following format:
  \begin{eqnarray*}
    A & = & \left\{\begin{array}{l}
      0 \rightarrow \tmmathbf{\phi}\\
      1 \rightarrow \tmmathbf{\phi}\\
      2 \rightarrow \tmmathbf{\phi}
    \end{array}\right.
  \end{eqnarray*}
  where $0$ indicates that the candidate occupying the core was made available
  and included to free the core, $1$ indicates that it timed-out and freed the
  core without advancing the parachain and $2$ indicates that the core was not
  occuped to begin with.
\end{definition}

\begin{definition}
  \label{defn-persisted-validation-data}The {\tmstrong{persisted validation
  data}} provides information about how to create the inputs for the
  validation of a candidate by calling the Runtime. This information is
  derived from the parachain state and will vary from parachain to parachain,
  although some of the fields may be the same for every parachain. This
  validation data acts as a way to authorize the additional data (such as
  messages) the collator needs to pass to the validation function.
  
  \
  
  The persisted validation data, $D_{\tmop{pv}}$, is a datastructure of the
  following format:
  \begin{eqnarray*}
    D_{\tmop{pv}} & = & (P_h, H_i, H_r, m_b)
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $P_h$ is the parent head data as defined in Definition
    \ref{defn-para-head-data}.
    
    \item $H_i$ is the relay chain block number this is in the context of.
    
    \item $H_r$ is the relay chain storage root this is in the context of.
    
    \item $m_b$ is the maximum legal size of the PoV block, in bytes.
  \end{itemizedot}
  The persisted validation data is fetched via the Runtime API as described in
  Section \ref{sect-rt-api-persisted-validation-data}.
\end{definition}

\subsection{check\_validation\_outputs}

Checks if the given validation outputs pass the acceptence criteria.

\

{\tmstrong{Arguments}}
\begin{itemizedot}
  \item The parachain Id as defined in Definition \ref{defn-para-id}.
  
  \item The candidate commitments as defined in Definition
  \ref{defn-candidate-commitments}.
\end{itemizedot}


{\tmstrong{Return}}
\begin{itemizedot}
  \item A boolean indicating whether the candidate commitments pass the
  acceptence criteria.
\end{itemizedot}

\subsection{session\_index\_for\_child}

Returns the session index that is expected at the child of a block.
{\todo{clarify session index}}

\

{\tmstrong{Arguments}}
\begin{itemizedot}
  \item None
\end{itemizedot}


{\tmstrong{Return}}
\begin{itemizedot}
  \item A unsigned 32-bit integer representing the session index.
\end{itemizedot}
\subsection{validation\_code}\label{sect-rt-api-validation-code}

Fetches the validation code (Runtime) of a parachain by parachain Id.

\

{\tmstrong{Arguments}}
\begin{itemizedot}
  \item The parachain Id as defined in Definition \ref{defn-para-id}.
  
  \item The occupied core assumption as defined in Definition
  \ref{defn-occupied-core-assumption}.
\end{itemizedot}


{\tmstrong{Return}}
\begin{itemizedot}
  \item An \tmverbatim{Option} value as defined in Definition
  \ref{defn-option-type} containing the full validation code in an byte array.
  This value is empty if the parachain Id cannot be found or the assumption is
  wrong.
\end{itemizedot}
\subsection{validation\_code\_by\_hash}\label{sect-rt-api-validation-code-by-hash}

Returns the validation code (Runtime) of a parachain by its hash.

\

{\tmstrong{Arguments}}
\begin{itemizedot}
  \item The hash value of the validation code.
\end{itemizedot}


{\tmstrong{Return}}
\begin{itemizedot}
  \item An \tmverbatim{Option} value as defined in Definition
  \ref{defn-option-type} containing the full validation code in an byte array.
  This value is empty if the parachain Id cannot be found or the assumption is
  wrong.
\end{itemizedot}

\subsection{candidate\_pending\_availability}

Returns the receipt of a candidate pending availability for any parachain
assigned to an occupied availabilty core.

\

{\tmstrong{Arguments}}
\begin{itemizedot}
  \item The parachain Id as defined in Definition \ref{defn-para-id}.
\end{itemizedot}


{\tmstrong{Return}}
\begin{itemizedot}
  \item An \tmverbatim{Option} value as defined in Definition
  \ref{defn-option-type} containing the committed candidate receipt as defined
  in Definition \ref{defn-candidate-receipt}. This value is empty if the given
  parachain Id is not assigned to an occupied availability cores.
\end{itemizedot}

\subsection{candidate\_events}

Returns an array of candidate events that occured within the lastest state.

\

{\tmstrong{Arguments}}
\begin{itemizedot}
  \item None
\end{itemizedot}


{\tmstrong{Return}}
\begin{itemizedot}
  \item An array of single candidate events, $E$, of the following format:
  \begin{eqnarray*}
    E & = & \left\{\begin{array}{l}
      0 \rightarrow d\\
      1 \rightarrow d\\
      2 \rightarrow (C_r, h, I_c)
    \end{array}\right.\\
    d & = & (C_r, h, I_c, G_i)
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $E$ specifies the the event type of the candidate. $0$ indicates
    that the candidate receipt was backed in the latest relay chain block, $1$
    indicates that it was included and became a parachain block at the latest
    relay chain block and $2$ indicates that the candidate receipt was not
    made available and timed-out.
    
    \item $C_r$ is the candidate receipt as defined in Definition
    \ref{defn-candidate-receipt}.
    
    \item $h$ is the parachain head data as defined in Definition
    \ref{defn-para-head-data}.
    
    \item $I_c$ is the index of the availabilty core as can be retrieved in
    Section \ref{sect-rt-api-availability-cores} that the candidate is
    occupying. If $E$ is of variant $2$, then this indicates the core index
    the candidate {\tmem{was}} occupying.
    
    \item $G_i$ is the group index as defined in Definition
    \ref{defn-validator-groups} that is responsible of backing the candidate.
  \end{itemizedot}
\end{itemizedot}
\subsection{session\_info}\label{sect-rt-api-session-info}

Get the session info of the given session, if available.

\

{\tmstrong{Arguments}}
\begin{itemizedot}
  \item The unsigned 32-bit integer indicating the session index.
\end{itemizedot}


{\tmstrong{Return}}
\begin{itemizedot}
  \item An \tmverbatim{Option} type as defined in Definition
  \ref{defn-option-type} which can contain the session info structure, $S$, of
  the following format:
  \begin{eqnarray*}
    S & = & (A, D, K, G, c, z, s, d, x, a)\\
    A & = & (v_n, \ldots v_m)\\
    D & = & (v_{_n}, \ldots v_m)\\
    K & = & (v_n, \ldots v_m)\\
    G & = & (g_n, \ldots g_m)\\
    g & = & (A_n, \ldots A_m)
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $A$ indicates the validators of the current session, in canonical
    order. There might be more validators in the current session than
    validators participating in parachain consensus, as returned by the
    Runtime API as defined in Section \ref{sect-rt-api-validators}.
    
    \item $D$ indicates the validator authority discovery keys for the given
    session in canonical order. The first couple of validators are equal to
    the corresponding validators participating in the parachain consensus, as
    returned by the Runtime API as defined in Section
    \ref{sect-rt-api-validators}. The remaining authorities are not
    participating in the parachain consensus.
    
    \item $K$ indicates the assignment keys for validators. There might be
    more authorities in the session that validators participating in parachain
    consensus, as returned by the Runtime API as defined in Section
    \ref{sect-rt-api-validators}.
    
    \item $G$ indicates the validator groups in shuffled order. {\todo{what's
    the purpose of this?}}
    
    \item $v_n$ is public key of the authority.
    
    \item $A_n$ is the authority set Id as defined in Definition
    {\todo{todo}}.
    
    \item $c$ is an unsigned 32-bit integer indicating the number of
    availability cores used by the protocol during the given session.
    
    \item $z$ is an unsigned 32-bit integer indicating the zeroth delay
    tranche width.
    
    \item $s$ is an unsigned 32-bit integer indicating the number of samples
    an assigned validator should do for approval voting.
    
    \item $d$ is an unsigned 32-bit integer indicating the number of delay
    tranches in total.
    
    \item $x$ is an unsigned 32-bit integer indicating how many BABE slots
    must pass before an assignment is considered a ``no-show''. {\todo{clarify
    how to convert between BABE slots and ``ticks''}}
    
    \item $a$ is an unsigned 32-bit integer indicating the number of
    validators needed to approve a block.
  \end{itemizedot}
\end{itemizedot}

\subsection{dmq\_contents}

Returns all the pending inbound messages in the downward message queue for a
given parachain.

\

{\tmstrong{Arguments}}
\begin{itemizedot}
  \item The parachain Id as defined in Definition \ref{defn-para-id}.
\end{itemizedot}


{\tmstrong{Return}}
\begin{itemizedot}
  \item An array of inbound downward messages as defined in {\todo{reference
  messaging chapter}}
\end{itemizedot}

\subsection{inbound\_hrmp\_channels\_contents}

Returns the contents of all channels addresssed to the given recipient.
Channels that have no messages in them are also included.

\

{\tmstrong{Arguments}}
\begin{itemizedot}
  \item The parachain Id as defined in Definition \ref{defn-para-id}.
\end{itemizedot}


{\tmstrong{Return}}
\begin{itemizedot}
  \item An array of inbound HRMP messages as defined in {\todo{reference
  messaging chapter}}
\end{itemizedot}

\subsection{disputes\_info}

{\todo{looks like this was renamed (and modified) into on\_chain\_votes?}}

\

Returns information about all disputes known by the Runtime, including which
validators the Runtime will accept disputes from.

\

{\tmstrong{Arguments}}
\begin{itemizedot}
  \item None
\end{itemizedot}


{\tmstrong{Return}}
\begin{itemizedot}
  \item A dispute information structure, $I$, of the following format:
  \begin{eqnarray*}
    I & = & ((D_0, \ldots D_n), T)\\
    D & = & (i, C_h, S, l)\\
    T & = & (m, (p_0, \ldots p_n))\\
    p & = & (i, (s_0, \ldots s_n))
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $D$ represents a dispute.
    
    \item $T$ represents information about spam slots {\todo{clarify}}
    
    \item $i$ is the session index as defined in Definition {\todo{todo}}.
    
    \item $C_h$ is the candidate hash {\todo{receipt?}}.
    
    \item $S$ is the dispute state as defined in Definition {\todo{todo}}.
    
    \item $l$ is a boolean indacting {\textdots} {\todo{?}}.
    
    \item $m$ is a unsigned 32-bit integer indicating the maximum spam slots
    {\todo{clarify}}.
    
    \item $s$ is a unsigned 32-bit integer indicating the spam slot.
  \end{itemizedot}
\end{itemizedot}

\subsection{candidates\_included}

{\todo{looks like this was removed?}}

\

Checks which candidates have been included within the local chain.

\

{\tmstrong{Arguments}}
\begin{itemizedot}
  \item An array for pairs, $p$, of the following format:
  \begin{eqnarray*}
    p & = & (i, C_h)
  \end{eqnarray*}
  where $i$ is the session index as defined in Definition {\todo{todo}} and
  $C_h$ is the candidate hash.
\end{itemizedot}


{\tmstrong{Return}}
\begin{itemizedot}
  \item An array of booleans which indicate whether the a candidate is
  included ({\tmem{true}}) or not ({\tmem{false}}). The order of booleans
  corresponds to the order of the passed on pairs $p$.
\end{itemizedot}

\section{Network messages}

The availability and validity process requires certain network messages to be
exchanged between validators and collators.

\subsection{Notification Messages}

The notification messages are exchanged between validators, including messages
sent by collators to validators. The protocol messages are exchanged based on
a streaming notification substream as described in Section
\ref{sect-connection-establishment}. The messages are SCALE encoded as
described in Section \ref{sect-scale-codec}.

\begin{definition}
  \label{net-msg-validator-protocol-message}The {\tmstrong{validator protocol
  message}} is a varying datatype used by validators to broadcast relevant
  information about certain steps in the A\&V process. Specifically, this
  includes the backing process as described in Section
  \ref{sect-candidate-backing} and the approval process as described in
  Section \ref{sect-approval-voting}. The validator protocol message, $M$, is
  a varying datatype of the following format:
  \begin{eqnarray*}
    M & = & \left\{\begin{array}{l}
      1 \rightarrow M_f\\
      3 \rightarrow M_s\\
      4 \rightarrow M_a
    \end{array}\right.
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $M_f$ is a bitfield distribution message as defined in Definition
    \ref{net-msg-bitfield-dist-msg}.
    
    \item $M_s$ is a statement distribution message as defined in Definition
    \ref{net-msg-statement-distribution}.
    
    \item $M_a$ is a approval distribution message as defined in Definition
    \ref{net-msg-approval-distribution}.
  \end{itemizedot}
\end{definition}

\begin{definition}
  \label{net-msg-collator-protocol-message}The {\tmstrong{collation protocol
  message}}, $M$, is a varying datatype of the following format:
  \begin{eqnarray*}
    M & = & \left\{\begin{array}{l}
      0 \rightarrow M_c
    \end{array}\right.
  \end{eqnarray*}
  where $M_c$ is the collator message as defined in Definition
  \ref{net-msg-collator-protocol}.
\end{definition}

\begin{definition}
  \label{net-msg-collator-protocol}The {\tmstrong{collator message}}, $M$, is
  a varying datatype of the following format:
  \begin{eqnarray*}
    M & = & \left\{\begin{array}{l}
      0 \rightarrow (C_i, P_i, C_s)\\
      1 \rightarrow H\\
      4 \rightarrow (B_h, S)
    \end{array}\right.
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $M$ is a varying datatype where $0$ indicates the intent to
    advertise a collation and $1$ indicates the advertisment of a collation to
    a validator. $4$ indicates that a collation sent to a validator was
    seconded.
    
    \item $C_i$ is the public key of the collator.
    
    \item $P_i$ is the parachain Id as defined in Definition
    \ref{defn-para-id}.
    
    \item $C_s$ is the signature of the collator using the \tmverbatim{PeerId}
    of the collators node.
    
    \item $H$ is the hash of the parachain block as defined in Definition
    \ref{defn-parablock}.
    
    \item $S$ is a full statement as defined in Definition
    \ref{net-msg-full-statement}.
  \end{itemizedot}
  This message is not sent directly but is sent as part of the collator
  protocol message as defined in Section
  \ref{net-msg-collator-protocol-message}.
\end{definition}

\begin{definition}
  \label{net-msg-statement-distribution}The {\tmstrong{statement distribution
  message}} is sent as part of the validator protocol message as defined in
  Section \ref{net-msg-validator-protocol-message}, indicates the validity
  vote of a validator for a given candidate, described further in Section
  \ref{sect-candidate-backing-statements}. The statement distribution message,
  $M$, is of varibale type of the following format:
  \begin{eqnarray*}
    M & = & \left\{\begin{array}{l}
      0 \rightarrow (B_h, S)\\
      1 \rightarrow S_m
    \end{array}\right.\\
    S_m & = & (B_h, C_h, A_i, A_s)
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $M$ is a vayring datatype where $0$indicates a signed statement
    \tmverbatim{}and $1$ contains metadata about a seconded statement with a
    larger payload, such as a runtime upgrade. The candidate itself can be
    fetched via the request/response message as defined in Definition
    \ref{net-msg-statement-fetching-request}.
    
    \item $B_h$ is the hash of the relay chain parent, indicating the state
    this message is for.
    
    \item $S$ is a full statement as defined in Definition
    \ref{net-msg-full-statement}.
    
    \item $A_i$ is the validator index in the authority set that signed this
    message.
    
    \item $A_s$ is the signature of the validator. 
  \end{itemizedot}
\end{definition}

\begin{definition}
  \label{net-msg-bitfield-dist-msg}The {\tmstrong{bitfield distribution
  message}} indicates the availability vote of a validator for a given
  candidate, described further in Section \ref{sect-availability-votes}. This
  message is sent in form of a validator protocol message as defined in
  Definition \ref{net-msg-validator-protocol-message}. The bitfield
  distribution message, $M$, is a datastructure of the following format:
  \begin{eqnarray*}
    M & = & \left\{\begin{array}{l}
      0 \rightarrow (B_h, P)
    \end{array}\right.\\
    P & = & (d, A_i, A_s)
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $B_h$ is the hash of the relay chain parent, indicating the state
    this message is for.
    
    \item $d$ is the bitfield array as described in Definition
    \ref{defn-bitfield-array}.
    
    \item $A_i$ is the validator index in the authority set as defined in
    Definition \ref{defn-authority-list} that signed this message.
    
    \item $A_s$ is the signature of the validator.
  \end{itemizedot}
  This message is not sent directly but is sent as part of the collator
  protocol message as defined in Section
  \ref{net-msg-validator-protocol-message}.
\end{definition}

\begin{definition}
  \label{net-msg-approval-distribution}The {\tmstrong{approval distribution
  message}} indicates the approval vote of a validator for a given candidate,
  described further in Section \ref{sect-availability-assingment-criteria}.
  This message is sent in form of a validator protocol message as defined in
  Definition \ref{net-msg-validator-protocol-message}. The approval
  distribution message, $M$, is a varying datatype of the following format:
  \begin{eqnarray*}
    M & = & \left\{\begin{array}{l}
      0 \rightarrow ((C , I )_0 \ldots (C, I)_n)\\
      1 \rightarrow (V_0, \ldots V_n)
    \end{array}\right.\\
    C & = & (B_h, A_i, c_a)\\
    c_a & = & (c_k, P_o, P_p)\\
    c_k & = & \left\{\begin{array}{l}
      0 \rightarrow s\\
      1 \rightarrow i
    \end{array}\right.\\
    V & = & (B_h, I, A_i, A_s)
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $M$ is a varying datatype where $0$ indicates assignments for
    candidates in recent, unfinalized blocks and $1$ indicates approvals for
    candidates in some recent, unfinalized block.
    
    \item $C$ is an assignment criterion which refers to the candidate under
    which the assignment is relevant by the block hash.
    
    \item $I$ is an unsigned 32-bit integer indicating the index of the
    candidate, corresponding the the order of the availability cores as
    described in Section \ref{sect-rt-api-availability-cores}.
    
    \item $B_h$ is the relay chain block hash where the candidate appears.
    
    \item $A_i$ is the authority set Id of the validator as defined in
    Definition \ref{defn-authority-list} that created this message.
    
    \item $A_s$ is the signature of the validator issuing this message.
    
    \item $c_a$ is the certification of the assignment.
    
    \item $c_k$ is a varying datatype where $0$ indicates an assignment based
    on the VRF that authorized the relay chain block where the candidate was
    included, followed by a sample number, $s.$ $1$ indicates an assignment
    story based on the VRF that authorized the relay chain block where the
    candidate was included combined with the index of a particular core. This
    is described further in Section \ref{sect-approval-voting}.
    
    \item $P_o$ is a VRF output and $P_p$ its corresponding proof.
  \end{itemizedot}
  This message is not sent directly but is sent as part of the collator
  protocol message as defined in Section
  \ref{net-msg-validator-protocol-message}.
\end{definition}

\section{Request \& Response}

The request \& response network messages are sent and received between peers
in the Polkadot network, including collators and non-validator nodes. Those
messages are conducted on the request-response substreams are described in
Section \ref{sect-connection-establishment}. The network messages are SCALE
encoded as described in Section \ref{sect-scale-codec}.

\begin{definition}
  \label{net-msg-pov-fetching-request}The {\tmstrong{PoV fetching request}} is
  sent by clients who want to retrieve a PoV block from a node. The request is
  a datastructure of the following format:
  \[ (C_h) \]
  where $C_h$ is the 256-bit hash of the PoV block. The reponse message is
  defined in Definition \ref{net-msg-pov-fetching-response}.
  
  \ 
\end{definition}

\begin{definition}
  \label{net-msg-pov-fetching-response}The {\tmstrong{PoV fetching response}}
  is sent by nodes to the clients who issued a PoV fetching request as defined
  in Definition \ref{net-msg-pov-fetching-request}. The response, $R$, is a
  varying datatype of the following format:
  \begin{eqnarray*}
    R & = & \left\{\begin{array}{l}
      0 \rightarrow B\\
      1 \rightarrow \tmmathbf{\phi}
    \end{array}\right.
  \end{eqnarray*}
  where $0$ is followed by the PoV block and $1$ indicates that the PoV block
  was not found.
\end{definition}

\begin{definition}
  \label{net-msg-chunk-fetching-request}The {\tmstrong{chunk fetching
  request}} is sent by clients who want to retrieve chunks of a parachain
  candidate. The request is a datastructure of the following format:
  \[ (C_h, i) \]
  where $C_h$ is the 256-bit hash of the parachain candiate and $i$ is a
  32-bit unsigned integer indicating the index of the chunk to fetch. The
  response message is defined in Definition
  \ref{net-msg-chunk-fetching-response}.
\end{definition}

\begin{definition}
  \label{net-msg-chunk-fetching-response}The {\tmstrong{chunk fetching
  response}} is sent by nodes to the clients who issued a chunk fetching
  request as defined in Definition \ref{net-msg-chunk-fetching-request}. The
  reponse, $R$, is a varying datatype of the following format:
  \begin{eqnarray*}
    R & = & \left\{\begin{array}{l}
      0 \rightarrow C_r\\
      1 \rightarrow \tmmathbf{\phi}
    \end{array}\right.\\
    C_r & = & (c, c_p)
  \end{eqnarray*}
  where 0 is followed by the chunk response, $C_r$ and 1 indicates that the
  requested chunk was not found. $C_r$ contains the erasure-encoded chunk of
  data belonging to the candidate block, $c$, and $c_p$ is that chunks proof
  in the Merkle tree. Both $c$ and $c_p$ are byte arrays of type $ (b_n \ldots
  b_m)$.
\end{definition}

\begin{definition}
  \label{net-msg-available-data-request}The {\tmstrong{available data
  request}} is sent by clients who want to retrieve the PoV block of a
  parachain candidate. The request is a datastructure of the following format:
  \[ C_h \]
  where $C_h$ is the 256-bit candidate hash to get the available data for. The
  reponse message is defined in Definition
  \ref{net-msg-available-data-reponse}.
\end{definition}

\begin{definition}
  \label{net-msg-available-data-reponse}The {\tmstrong{available data
  response}} is sent by nodes to the clients who issued a available data
  request as defined in Definition \ref{net-msg-available-data-request}. The
  reponse, $R$, is a varying datatype of the following format:
  \begin{eqnarray*}
    R & = & \left\{\begin{array}{l}
      0 \rightarrow A\\
      1 \rightarrow \tmmathbf{\phi}
    \end{array}\right.\\
    A & = & (P_{\tmop{ov}}, D_{\tmop{pv}})
  \end{eqnarray*}
  where $0$ is followed by the available data, $A$, and $1$ indicates the the
  requested candidate hash was not found. $P_{\tmop{ov}}$ is the PoV block as
  defined in Definition \ref{defn-pov-block} and $D_{\tmop{pv}}$ is the
  persisted validation data as defined in Definition
  \ref{defn-persisted-validation-data}.
\end{definition}

\begin{definition}
  \label{net-msg-collation-fetching-request}The {\tmstrong{collation fetching
  request}} is sent by clients who want to retrieve the advertised collation
  at the specified relay chain block. The request is a datastructure of the
  following format:
  \[ (B _h, P_{\tmop{id}}) \]
  where $B _h$ is the hash of the relay chain block and $P_{\tmop{id}}$ is the
  parachain Id as defined in Definition \ref{defn-para-id}. The response
  message is defined in Definition \ref{net-msg-collation-fetching-response}.
\end{definition}

\begin{definition}
  \label{net-msg-collation-fetching-response}The {\tmstrong{collation fetching
  response}} is sent by nodes to the clients who issued a collation fetching
  request as defined in Definition \ref{net-msg-collation-fetching-request}.
  The response, $R$, is a varying datatype of the following format:
  \begin{eqnarray*}
    R & = & \left\{\begin{array}{l}
      0 \rightarrow (C_r, B)
    \end{array}\right.
  \end{eqnarray*}
  where $0$ is followed by the candidate receipt, $C_r$, as defined in
  Definition \ref{defn-candidate-receipt} and the PoV block, $B$. This type
  does not notify the client about a statement that was not found.
\end{definition}

\begin{definition}
  \label{net-msg-statement-fetching-request}The {\tmstrong{statement fetching
  request}} is sent by clients who want to retrieve statements about a given
  candidate. The request is a datastructure of the following format:
  \begin{eqnarray*}
    & (B_h, C_h) & 
  \end{eqnarray*}
  where $B_h$ is the hash of the relay chain parent and $C_h$ is the candidate
  hash that was used to create a committed candidate recept as defined in
  Definition \ref{defn-committed-candidate-receipt}. The response message is
  defined in Definition \ref{net-msg-statement-fetching-response}.
\end{definition}

\begin{definition}
  \label{net-msg-statement-fetching-response}The {\tmstrong{statement fetching
  response}} is sent by nodes to the clients who issued a collation fetching
  request as defined in Definition \ref{net-msg-statement-fetching-request}.
  The reponse, $R$, is a varying datatype of the following format:
  \begin{eqnarray*}
    R & = & \left\{\begin{array}{l}
      0 \rightarrow C_r
    \end{array}\right.
  \end{eqnarray*}
  where $C_r$ is the committed candidate receipt as defined in Definition
  \ref{defn-committed-candidate-receipt}. No response is returned if no
  statement is found.
\end{definition}

\begin{definition}
  \label{net-msg-dispute-request}The {\tmstrong{dispute request}} is sent by
  clients who want to issue a dispute about a candidate. The request, $D_r$,
  is a datastructure of the following format:
  \begin{eqnarray*}
    D_r & = & (C_r, S_i, I_v, V_v)\\
    I_v & = & (A_i, A_s, k_i)\\
    V_v & = & (A_i, A_s, k_v)\\
    k_i & = & \left\{\begin{array}{l}
      0 \rightarrow \tmmathbf{\phi}
    \end{array}\right.\\
    k_v & = & \left\{\begin{array}{l}
      0 \rightarrow \tmmathbf{\phi}\\
      1 \rightarrow C_h\\
      2 \rightarrow C_h\\
      3 \rightarrow \tmmathbf{\phi}
    \end{array}\right.
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $C_r$ is the candidate that is being disputed. The structure is a
    candidate receipt as defined in Definition \ref{defn-candidate-receipt}.
    
    \item $S_i$ is an unsigned 32-bit integer indicating the session index the
    candidate appears in.
    
    \item $I_v$ is the invalid vote that makes up the request.
    
    \item $V_v$ is the valid vote that makes this disput request valid.
    
    \item $A_i$ is an unsigned 32-bit integer indicating the validator index
    in the authority set as defined in Definition \ref{defn-authority-list}.
    
    \item $A_s$ is the signature of the validator.
    
    \item $k_i$ is a varying datatype and implies the dispute statement. $0$
    indicates an explicit statemet.
    
    \item $k_v$ is a varying datatype and implies the dispute statement.
    \begin{itemizedot}
      \item $0$ indicates an explicit statement.
      
      \item $1$ indicates a seconded statement on a candidate, $C_h$, from the
      backing phase. $C_h$ is the hash of the candidate.
      
      \item $2$ indicates a valid statement on a candidate, $C_h$, from the
      backing phase. $C_h$ is the hash of the candidate.
      
      \item $3$ indicates an approval vote from the approval checking phase.
    \end{itemizedot}
  \end{itemizedot}
  The response message is defined in Definition
  \ref{net-msg-dispute-response}.
\end{definition}

\begin{definition}
  \label{net-msg-dispute-response}The {\tmstrong{dispute response}} is sent by
  nodes to the clients who who issued a dispute request as defined in
  Definition \ref{net-msg-dispute-request}. The response, $R$, is a varying
  type of the following format:
  \begin{eqnarray*}
    R & = & \left\{\begin{array}{l}
      0 \rightarrow \tmmathbf{\phi}
    \end{array}\right.
  \end{eqnarray*}
  where $0$ indicates that the dispute was successfully processed.
\end{definition}

\section{{\todo{todo - Outdated section}}}\label{sect-primary-validation}

Collators produce candidates (Definition \ref{defn-candidate}) and send those
to validators. Validators verify the validity of the received candidates
(Algo. \ref{algo-primary-validation}) by executing the validation code,
$R_{\rho}$, and issue statements (Definition \ref{defn-gossip-statement})
about the candidates to connected peers. The validator ensures the that every
candidate considered for inclusion has at least one other validator backing
it. Candidates without backing are discarded.

\

The validator must keep track of which candidates were submitted by
collators, including which validators back those candidates in order to
penalize bad behavior. This is described in more detail in section
\ref{sect-primary-validaty-announcement}.

\subsection{Parachain Block Production}\label{sect-parachain-block-production}

Collators produce a candidate for their corresponding parachains and submit
those to the parachain validators which are part of the Polkadot relay chain.

\subsubsection{Building a parachain block}

\custombinding{25}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{25}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-build-parablock}Producing a parachain candidate
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}
\begin{itemizedot}
  \item {\tmname{RelayParent}} - Fetches the parent block hash of the relay
  chain as described in Section \ref{sect-collator-consensus}.
  
  \item {\tmname{ValidationData}} - Fetches the persistent validation data as
  defined in Definition \ref{defn-persisted-validation-data}.
  
  \item {\tmname{ParentHead}} - Derives the parachain parent header from
  validation data $v_d$.
  
  \item {\tmname{ProduceCandidate}} - Produces a candidate as defined in
  Definition \ref{defn-candidate} from the values $r_p$, $v_d$ and $h_d$.
  
  \item {\tmname{CreateParaBlock}} - Creates a parachain block as defined in
  Definition \ref{defn-parablock} from the produced candidate $D_p$.
  
  \item {\tmname{BuildCollation}} - Builds the final collation as defined in
  Definition \ref{defn-collation} from the created parachain block $B_p$.
  
  \item {\tmname{Announce}} - Sends the collation to relay chain validators.
\end{itemizedot}
\begin{definition}
  \label{defn-gossip-pov-block}A \tmtextbf{Gossip PoV block} is a tuple of the
  following format:
  \[ (h_b (B_{^{\tmop{relay}}_{\tmop{parent}}}), h_b (C_{\tmop{coll}}
     (\tmop{PoV}_B)), \tmop{PoV}_B) \]
  where $h_b (B_{^{\tmop{relay}}_{\tmop{parent}}})$ is the block hash of the
  relay chain being referred to and $h_b (C_{\tmop{coll}} (\tmop{PoV}_B))$ is
  the hash of some candidate localized to the same Relay chain block.
\end{definition}

\custombinding{26}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{26}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-primary-validation-announcement}{\tmname{PrimaryValidationAnnouncement}}($\tmop{PoV}_B$)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}
\begin{itemize}
  \item \tmtextsc{ValidateBlock}: Validates $\tmop{PoV}_B$ as defined in
  Algorithm \ref{algo-validate-block}.
  
  \item \tmtextsc{SetValid}: Creates a valid statement as defined in
  Definition \ref{defn-gossip-statement}.
  
  \item \tmtextsc{SetInvalid}: Creates an invalid statement as defined in
  Definition \ref{defn-gossip-statement}.
  
  \item \tmtextsc{BlacklistCollatorOf}: blacklists the collator which sent the
  invalid PoV block, preventing any new PoV blocks from being received. The
  amount of time for blacklisting is unspecified.
  
  \item \tmtextsc{Propagate}: sends the statement to the connected peers.
\end{itemize}
\custombinding{27}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{27}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-endorse-candidate-receipt}{\tmname{ConfirmCandidateReceipt}}($\tmop{Stmt}_{\tmop{peer}}$)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}
\begin{itemize}
  \item $\tmop{Stmt}_{\tmop{peer}}$: a statement received from another
  validator.
  
  \item \tmtextsc{Retrieve}: Retrieves the PoV block from the statement
  (\ref{defn-gossip-statement}).
  
  \item \tmtextsc{ValidateBlock}: Validates $\tmop{PoV}_B$ as defined in
  Algorithm \ref{algo-validate-block}.
  
  \item \tmtextsc{AlreadySeconded}: Verifies if a parachain block has already
  been seconded for the given Relay Chain block. Validators that second more
  than one (1) block per Relay chain block are subject to slashing. More
  information is available in Definition \ref{defn-gossip-statement}.
  
  \item \tmtextsc{SetValid}: Creates a valid statement as defined in
  Definition \ref{defn-gossip-statement}.
  
  \item \tmtextsc{SetSeconded}: Creates a seconded statement as defined in
  Definition \ref{defn-gossip-statement}. Seconding a block should ensure that
  the next call to \tmtextsc{AlreadySeconded} reliably affirms this action.
  
  \item \tmtextsc{SetInvalid}: Creates an invalid statement as defined in
  Definition \ref{defn-gossip-statement}.
  
  \item \tmtextsc{BlacklistCollatorOf}: blacklists the collator which sent the
  invalid PoV block, preventing any new PoV blocks from being received. The
  amount of time for blacklisting is unspecified.
  
  \item \tmtextsc{AnnounceMisbehaviorOf}: announces the misbehavior of the
  validator who claimed a valid statement of invalid PoV block as described in
  algorithm {\todo{@fabio}}.
  
  \item \tmtextsc{Propagate}: sends the statement to the connected peers.
\end{itemize}

\section{Erasure encoding {\todo{todo}}}

In order for the Polkadot protocol to ensure the security of validatod
parachain blocks, it must be able to reproduce those blocks in case of future
dispute. To this aim, \ backed candidates must be available for the entire,
elected validators set. However it is impractical to require each of those
validator to maintain a full copy of all PoV blocks. A practical solution to
this problem is to employ erasure codes: PoV blocks are broken into chunks and
the chunks are encoded using Reed-Solomon erasure codes. Erasure-encoded
chunks are arranged into a Merkle tree to ensure their integrity.
Subsequently, the encoded chunks are distributed among the validators each
along side its Merkle proof of integrity. Each validator keeps track of how
those chunks are distributed among the validator set. When a validator has to
verify a PoV block, it can request the relevant chunks from its peers, verify
its integrity and reconstruct the originally validated PoV block.

This Section specifies the interaction of a validator node with the erasure
code library to obtain the encoded chunk and to reconstructing the original
PoV when enough encode chunks are available. However, the specification of the
Reed-Solomon encoding/decoding Algorithm is beyond the scope of this
section.\tmverbatim{}

\begin{definition}
  For validator set of size $n$, The {\tmstrong{encoding parameters}} for
  Polkadot Reed-Solomon code is set as follow:
  \begin{itemize}
    \item {\tmstrong{$k$, the number of message symbols}} is set to be
    $\left\lfloor \frac{n - 1}{3} \right\rfloor + 1$.
    
    \item {\tmstrong{n, the number of code symbols}} is set to be $n$.
  \end{itemize}
\end{definition}

\begin{definition}
  \label{defn-erasure-encoder-decoder}The \tmtextbf{erasure encoder},
  \tmtextbf{$\tmop{encode}_{k, n}$ }is defined to be the Reed-Solomon encoder
  of a message of length k symbols which encodes it into $n$ symbles as
  follows:
  \[ \tmop{encode}_{k, n} : \left\{ \begin{array}{ccc}
       \mathbb{B}_m & \rightarrow & \mathbb{S}_n\\
       (b_1, \ldots, b_m) & \rightarrow & (S_1, S_2, \ldots, S_n)
     \end{array} \right. \]
  where $[b_1, \ldots, b_m]$ is a byte array of arbitrary size $m$ and $(S_1,
  S_2, \ldots, S_n)$ is a sequence of shards defined in
  \ref{defn-erasure-shard}.
\end{definition}

\begin{definition}
  \label{defn-erasure-shard}For a validator node $i$, and byte array blob $B =
  (b_1, \ldots, b_m) \in \mathbb{B}_M$ we define {\tmstrong{$S_i$}} as the
  {\tmstrong{$i$'th erasure coded Shard}} \ which is a byte array of length
  $\lceil m / 2 k \rceil$. It is indexed as $i$ because it is out to be handed
  over to and kept by validator $i$ {\todo{define how bytes are distributed
  before encoding? First k Shards are containing pure data?}}
\end{definition}

\begin{definition}
  The \tmtextbf{erasure decoder $\tmop{decoder}_{k, n}$} is defined to be the
  Reed-Solomon decoder of a code word of n symboles into a message of k
  symbols as follows:
  \[ \tmop{decode}_{k, n} : \left\{ \begin{array}{ccc}
       O S_n & \rightarrow & \mathbb{B}_m\\
       (O S_1, O S_2, \ldots, O S_n) & \rightarrow & (b_1, \ldots, b_m)\\
       &  & 
     \end{array} \right. \]
  Where $\tmop{OS}_n$ is the set of sequence of length n of optional shards as
  defined in Definition \ref{defn-erasure-optional-shard} and $\mathbb{B}_m$
  is the set of byte arrays of length m representing the decoded blob of data.
\end{definition}

\begin{definition}
  \label{defn-erasure-optional-shard}For a validator node $i$, we define
  {\tmstrong{O$S_i$}} as the {\tmstrong{$i$'th Optional Shard}} which is a of
  varying type:
  \[ \begin{array}{lll}
       \tmop{idx} &  & \\
       0 & \tmop{None} & \tmop{When} S_i \tmop{is} \tmop{not} \tmop{received}
       \tmop{by} \tmop{the} \tmop{constructing} \tmop{node}\\
       1 & S_i & \tmop{When} S_i \tmop{shard} \tmop{is} \tmop{received} .
     \end{array} \]
\end{definition}

\custombinding{28}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{28}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-erasure-encode}{\tmname{Erasure-Encode}}($\bar{B}$: the
      available PoV blob defined in Definition \ref{defn-blob},
      
      $v_B$: number of validator in the active set)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}
\begin{itemize}
  \item \tmtextsc{Make-Shards(..)}: return shards for each validator as
  described in Algorithm \ref{algo-make-shards}. Return value is defined as
  $(\mathbb{S}_0, ..., \mathbb{S}_n)$ where $\mathbb{S} \assign (b_0, ...,
  b_n)$
  
  \item {\tmname{Generate-Availability-Merkle-Tree}} is described in Algorithm
  \ref{algo-gen-availblity-tree}.
  
  \item \tmtextsc{Insert($\tmop{trie}, \tmop{key}, \tmop{val}$)}: insert the
  given $\tmop{key}$ and $\tmop{value}$ into the $\tmop{trie}$.
  
  \item \tmtextsc{Get-Nodes($\tmop{trie}, \tmop{key}$)}: based on the
  $\tmop{key}$, return all required $\tmop{trie}$ nodes in order to verify the
  corresponding value for a (unspecified) Merkle root. Return value is defined
  as $(\mathbb{N}_0, ..., \mathbb{N}_n)$ where $\mathbb{N} \assign (b_0, ...,
  b_n)$.
  
  \item \tmtextsc{Add($\tmop{sequence}, \tmop{item}$)}: add the given
  $\tmop{item}$ to the $\tmop{sequence}$.
  
  \item $\tmop{ER}_B$ is the collection of erasure coded chunk as defined in
  Definition \ref{defn-erasure-coded-chunks}.
\end{itemize}
\custombinding{29}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{29}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-make-shards}{\tmname{Make-Shards}}($D$: The data to be
      erasure coded and sharded,
      
      $v_B$: Number of required resulting shards (equal to the number of
      validators))
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}
\begin{itemize}
  \item {\tmname{Make-Encoder(C)}} is the API function provided by
  {\cite{w3f_rs-ec-perf_2021}}.
\end{itemize}
Algorithm \ref{algo-gen-availblity-tree} creates a Merkle tree from the shards
produced by Algorithm \ref{algo-make-shards}. The Merkle tree is to produce
the Merkle proofs to verify each chunk.

\custombinding{30}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    {\tmstrong{Algorithm \tmtextup{30}}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-gen-availblity-tree}{\tmname{Generate-Availability-Merkle-Tree}}(S:
      Sequence of Shards generated
      
      by Algorithm \ref{algo-make-shards} )
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

{\todo{ Either we should spec the trie completly as we did with Storage Trie
or we should

refer to Storage trie spec.}}

\begin{definition}
  \label{defn-erasure-coded-chunks}The \tmtextbf{collection of erasure-encoded
  chunks} of $\bar{B}$, denoted by:
  \[ \tmop{Er}_B \assign (e_1, ..., e_n) \]
  is defined to be the output of the Algorithm \ref{algo-erasure-encode}. Each
  chunk is a tuple of the following format:
  
  \begin{alignat*}{2}
    e &
    {\assign}(\ensuremath{\mathbb{S}},I,(\ensuremath{\mathbb{N}}\tmrsub{0},...,\ensuremath{\mathbb{N}}\tmrsub{n}))\\
    \ensuremath{\mathbb{S}} & {\assign}(b\tmrsub{0},...,b\tmrsub{n})\\
    \ensuremath{\mathbb{N}} & {\assign}(b\tmrsub{0},...,b\tmrsub{n})
  \end{alignat*}
  
  where each value represents:
  \begin{itemize}
    \item $\mathbb{S}$: a byte array containing the erasure-encoded shard of
    data.
    
    \item $I$: the unsigned 32-bit integer representing the index of this
    erasure-encoded chunk of data.
    
    \item $(\mathbb{N}_0, ..., \mathbb{N}_n)$: an array of inner byte arrays,
    each containing the nodes of the Trie in order to verify the chunk based
    on the Merkle root.
  \end{itemize}
\end{definition}

\chapter{Message Passing}

{\todo{DISCLAIMER: this document is currently outdated. The messaging protocol
for Parachains is heavily work-in-progress and will change a lot until
finalization.}}

\section{Overview}

Polkadot implements two types of message passing mechanisms; vertical passing
and horizontal passing.
\begin{itemize}
  \item Vertical message passing refers to the communication between the
  parachains and the relay chain. More precisely, when the relay chain sends
  messages to a parachain, it's ``downward message passing''. When a parachain
  sends messages to the relay chain, it's ``upward message passing''.
  
  \item Horizontal message passing refers to the communication between the
  parachains, only requiring minimal involvement of the relay chain. The relay
  chain essentially only stores proofs that message where sent and whether the
  recipient has read those messages.
\end{itemize}
\begin{figure}[h]
  \resizebox{1\columnwidth}{!}{\includegraphics{figures/c08-overview.pdf}}
  \caption{Parachain Message Passing Overview}
\end{figure}

\section{Message Queue Chain (MQC)}

The Message Queue Chain (MQC) is a general hash chain construct created by
validators which keeps track of any messages and their order as sent from a
sender to an individual recipient. The MQC is used by both HRMP and XCMP.

Each block within the MQC is a triple containing the following fields:

- \tmtexttt{parent\_hash}: The hash of the previous triple.

- \tmtexttt{message\_hash}: The hash of the message itself.

- \tmtexttt{number}: The relay block number at which the message was sent.

\begin{figure}[h]
  \resizebox{1\columnwidth}{!}{\includegraphics{figures/c08-message_queue_chain.pdf}}
  \caption{Message Queue Chain Overview}
\end{figure}

A MQC is always specific to one channel. Additional channels require its own,
individual MQC. The MQC itself is not saved anywhere, but only provides a
final proof of all the received messages. When a validators receives a
candidate, it generates the MQC from the messages placed withing
\tmtexttt{upward\_messages}, in ascending order.

\section{HRMP}

Polkadot currently implements the mechanism known as Horizontal Relay-routed
Message Passing (HRMP), which fully relies on vertical message passing in
order to communicate between parachains. Consequently, this goes against the
entire idea of horizontal passing in the first place, since now every message
has to be inserted into the relay chain itself, therefore heavily increasing
footprint and resource requirements. However, HRMP currently serves as a fast
track to implementing cross-chain interoperability. The upcoming replacement
of HRMP is Cross-Chain Message Passing (XCMP), which exchanges messages
directly between parachains and only updates proofs and read-confirmations on
chain. With XCMP, vertical message processing is only used for opening and
closing channels.

\subsection{Channels}

A channel is a construct on the relay chain indicating an open,
one-directional communication line between a sender and a recipient, including
information about how the channel is being used. The channel itself does not
contain any messages. A channel construct is created for each, individual
communication line.

A channel contains the following fields:

\tmtexttt{HrmpChannel}:
\begin{itemize}
  \item \tmtexttt{sender\_deposit: int}: staked balances of sender.
  
  \item \tmtexttt{recipient\_deposit: int}: staked balances of recipient.
  
  \item \tmtexttt{limit\_used\_places: int}: the maximum number of messages
  that can be pending in the channel at once.
  
  \item \tmtexttt{limit\_used\_bytes: int}: the maximum total size of the
  messages that can be pending in the channel at once.
  
  \item \tmtexttt{limit\_message\_size}: the maximum message size that could
  be put into the channel.
  
  \item \tmtexttt{used\_places: int}: number of messages used by the sender in
  this channel.
  
  \item \tmtexttt{used\_bytes: int}: total number of bytes used by the sender
  in this channel.
  
  \item \tmtexttt{sealed: bool}: (TOOD: this is not defined in the Impl-Guide)
  indicator wether the channel is sealed. If it is, then the recipient will no
  longer accept any new messages.
  
  \item \tmtexttt{mqc\_head}: a head of the MQC for this channel.
\end{itemize}
This structure is created or overwritten on every start of each session.
Individual fields of this construct are updated for every message sent, such
as \tmtexttt{used\_places}, \tmtexttt{used\_bytes} and \tmtexttt{mqc\_head}.
If the channel is sealed and \tmtexttt{used\_places} reaches \tmtexttt{0}
(occurs when a new session begins), this construct is be removed on the
{\tmem{next}} session start.

The Runtime maintains a structure of the current, open channels in a map. The
key is a tuple of the sender ParaId and the recipient ParaId, where the value
is the corresponding \tmtexttt{HrmpChannel} structure.
\begin{alltt}

channels: map(ParaId, ParaId) => Channel
\end{alltt}

\subsection{Opening Channels}

Polkadot places a certain limit on the amount of channels that can be opened
between parachains. Only the the sender can open a channel.

In order to open a channel, the sender must send an opening request to the
relay chain. The request is a construct containing the following fields:

\tmtexttt{ChOpenRequest}:
\begin{itemize}
  \item \tmtexttt{sender: ParaId}: the ParaId of the sender.
  
  \item \tmtexttt{recipient: ParaId}: the ParaId of the recipient.
  
  \item \tmtexttt{confirmed: bool}: indicated whether the recipient has
  accepted the channel. On request creation, this value is \tmtexttt{false}.
  
  \item \tmtexttt{age: int}: the age of this request, which start at
  \tmtexttt{0} and is incremented by 1 on every session start.
\end{itemize}
TODO: Shouldn't \tmtexttt{ChOpenRequest} also have an \tmtexttt{initiator}
field? Or can only the sender open an channel?

\subsubsection{Workflow}

Before execution, the following conditions must be valid, otherwise the
candidate will be rejected.
\begin{itemize}
  \item The \tmtexttt{sender} and the \tmtexttt{recipient} exist.
  
  \item \tmtexttt{sender} is not the \tmtexttt{recipient}.
  
  \item There's currently not a active channel established, either seal or
  unsealed (TODO: what if there's an active closing request pending?).
  
  \item There's not already an open channel request for \tmtexttt{sender} and
  \tmtexttt{recipient} pending.
  
  \item The caller of this function (\tmtexttt{sender}) has capacity for a new
  channel. An open request counts towards the capacity (TODO: where is this
  defined?).
  
  \item The caller of this function (\tmtexttt{sender}) has enough funds to
  cover the deposit.
\end{itemize}
The PVF executes the following steps:
\begin{itemize}
  \item Create a \tmtexttt{ChOpenRequest} message and inserts it into the
  \tmtexttt{upward\_messages} list of the candidate commitments.
\end{itemize}
Once the candidate is included in the relay chain, the runtime reads the
message from \tmtexttt{upward\_messages} and executes the following steps:
\begin{itemize}
  \item Reads the message from \tmtexttt{upward\_messages} of the candidate
  commitments.
  
  \item Reserves a deposit for the caller of this function (\tmtexttt{sender})
  (TODO: how much?).
  
  \item Appends the \tmtexttt{ChOpenRequest} request to the pending open
  request queue.
\end{itemize}

\subsection{Accepting Channels}

Open channel requests must be accepted by the other parachain.

TODO: How does a Parachain decide which channels should be accepted? Probably
off-chain consensus/agreement?

The accept message contains the following fields:

\tmtexttt{ChAccept}:
\begin{itemize}
  \item \tmtexttt{index: int}: the index of the open request list.
\end{itemize}

\subsubsection{Workflow}

Before execution, the following conditions must be valid, otherwise the
candidate will be rejected.
\begin{itemize}
  \item The \tmtexttt{index} is valid (the value is within range of the list).
  
  \item The \tmtexttt{recipient} ParaId corresponds to the ParaId of the
  caller of this function.
  
  \item The caller of this function (\tmtexttt{recipient}) has enough funds to
  cover the deposit.
\end{itemize}
The PVF executes the following steps:
\begin{itemize}
  \item Generates a \tmtexttt{ChAccept} message and inserts it into the
  \tmtexttt{upward\_messages} list of the candidate commitments.
\end{itemize}
Once the candidate is included in the relay chain, the relay runtime reads the
message from \tmtexttt{upward\_messages} and executes the following steps:
\begin{itemize}
  \item Reserve a deposit for the caller of this function
  (\tmtexttt{recipient}).
  
  \item Confirm the open channel request in the request list by setting the
  \tmtexttt{confirmed} field to \tmtexttt{true}.
\end{itemize}

\subsection{Closing Channels}

Any open channel can be closed by the corresponding sender or receiver. No
mutual agreement is required. A close channel request is a construct
containing the following fields:

\tmtexttt{ChCloseRequest}:
\begin{itemize}
  \item \tmtexttt{initiator: int}: the ParaId of the parachain which initiated
  this request, either the sender or the receiver.
  
  \item \tmtexttt{sender: ParaId}: the ParaId of the sender.
  
  \item \tmtexttt{recipient: ParaId}: the ParaId of the recipient.
\end{itemize}

\subsection{Workflow}

Before execution, the following conditions must be valid, otherwise the
candidate will be rejected.
\begin{itemize}
  \item There's currently and open channel or a pending open channel request
  between \tmtexttt{sender} and \tmtexttt{recipient}.
  
  \item The channel is not sealed.
  
  \item The caller of the Runtime function is either the \tmtexttt{sender} or
  \tmtexttt{recipient}.
  
  \item There is not existing close channel request.
\end{itemize}
The PVF executes the following steps:
\begin{itemize}
  \item Generates a \tmtexttt{ChCloseRequest} message and inserts it into the
  \tmtexttt{upward\_messages} list of the candidate commitments.
\end{itemize}
Once a candidate block is inserted into the relay chain, the relay runtime:
\begin{itemize}
  \item Reads the message from \tmtexttt{upward\_message} of the candidate
  commitments.
  
  \item Appends the request \tmtexttt{ChCloseRequest} to the pending close
  request queue.
\end{itemize}

\subsection{Sending messages}

The Runtime treats messages as SCALE encoded byte arrays and has no concept or
understanding of the message type or format itself. Consensus on message
format must be established between the two communicating parachains (TODO:
SPREE will handle this).

Messages intended to be read by other Parachains are inserted into
\tmtexttt{horizontal\_messages} of the candidate commitments
(\tmtexttt{CandidateCommitments}), while message which are only intended to be
read by the relay chain (such as when opening, accepting or closing channels)
are inserted into \tmtexttt{upward\_messages}.

The messages are included by collators into the committed candidate receipt
(), which contains the following fields:

TODO: This should be defined somewhere else, ideally in a backing/validation
section (once this document is merged with AnV).

\tmtexttt{CommittedCandidateReceipt}:
\begin{itemize}
  \item \tmtexttt{descriptor: CandidateDescriptor}: the descriptor of the
  candidate.
  
  \item \tmtexttt{commitments: CandidateCommitments}: the commitments of the
  candidate receipt.
\end{itemize}
The candidate descriptor contains the following fields:

\tmtexttt{CandidateDescriptor}:
\begin{itemize}
  \item \tmtexttt{para\_id: ParaId}: the ID of the para this is a candidate
  for.
  
  \item \tmtexttt{relay\_parent: Hash}: the hash of the relay chain block this
  is executed in the context of.
  
  \item \tmtexttt{collator: CollatorId}: the collator's SR25519 public key.
  
  \item \tmtexttt{persisted\_validation\_data\_hash: Hash}: the hash of the
  persisted valdation data. This is extra data derived from the relay chain
  state which may vary based on bitfields included before the candidate.
  Therefore, it cannot be derived entirely from the relay parent.
  
  \item \tmtexttt{pov\_hash: Hash}: the how of the PoV block.
  
  \item \tmtexttt{signature: Signature}: the signature on the Blake2 256-bit
  hash of the following components of this receipt:
  \begin{itemize}
    \item \tmtexttt{para\_id}
    
    \item \tmtexttt{relay\_parent}
    
    \item \tmtexttt{persisted\_validation\_data\_hash}
    
    \item \tmtexttt{pov\_hash}
  \end{itemize}
\end{itemize}
The candidate commitments contains the following fields:

\tmtexttt{CandidateCommitments}:
\begin{itemize}
  \item \tmtexttt{fees: int}: fees paid from the chain to the relay chian
  validators
  
  \item \tmtexttt{horizontal\_message: [Message]}: a SCALE encoded arrary
  containing the messages intended to be received by the recipient parachain.
  
  \item \tmtexttt{upward\_messages: [Message]}: message destined to be
  interpreted by the relay chain itself.
  
  \item \tmtexttt{erasure\_root: Hash}: the root of a block's erasure encoding
  Merkle tree.
  
  \item \tmtexttt{new\_validation\_code: Option<ValidationCode>}: new
  validation code for the parachain.
  
  \item \tmtexttt{head\_data: HeadData}: the head-data produced as a result of
  execution.
  
  \item \tmtexttt{processed\_downward\_messages: u32}: the number of messages
  processed from the DMQ.
  
  \item \tmtexttt{hrmp\_watermark: BlockNumber}: the mark which specifies the
  block number up to which all inbound HRMP messages are processed.
\end{itemize}

\subsection{Receiving Messages}

A recipient can check for unread messages by calling into the
\tmtexttt{downward\_messages} function of the relay runtime (TODO: currently
it's not really clear how a recipient will check for new messages).

Params:
\begin{itemize}
  \item \tmtexttt{id: ParaId}: the ParaId of the sender.
\end{itemize}
On success, it returns a SCALE encoded array of messages.

\section{XCMP}

XCMP is a horizontal message passing mechanism of Polkadot which allows
Parachains to communicate with each other and to prove that messages have been
sent. A core principle is that the relay chain remains as thin as possible in
regards to messaging and only contains the required information for the
validity of message processing.

\begin{figure}[h]
  \resizebox{1\columnwidth}{!}{\includegraphics{figures/c08-xcmp_overview.pdf}}
  \caption{Parachain XCMP Overview}
\end{figure}

The entire XCMP process requires a couple of steps:
\begin{itemize}
  \item The sender creates a local Message Queue Chain (MQC) of the messages
  it wants to send and inserts the Merkle root into a structure on the relay
  chain, known as the Channel State Table (CST).
  
  \item The messages are sent to the recipient and contain the necessary data
  in order to reproduce the MQC.
  
  \item The BIOS module of the recipient process those messages. The messages
  are then inserted into the next parablock body as inherent extrinsics.
  
  \item Once that parablock is inserted into the relay chain, the recipient
  then updates the Watermark, which points to the relay block number which
  includes the parablock. This serves as an indicator that the receiving
  parachain has processed messages up to that relay block.
\end{itemize}
Availabilty
\begin{itemize}
  \item The messages created by the sender must be kept available for at least
  one day. When AnV assigns validators to check the validity of the sending
  parachains parablocks, it can load the data from the CST, which includes the
  information required in order to regenerate the MQC.
  
  \item ...
\end{itemize}

\subsection{CST: Channel State Table}

The Channel State Table (CST) is a map construct on the relay chain which
keeps track of every MQC generated by a single sender. The corresponding value
is a list of pairs, where each pair contains the ParaId of the recipient, the
Merkle root of MQC heads and the relay block number where that item was last
updated in the CST. This provides a mechanism for receiving parachains to
easily verify messages sent from a specific source.

When a PoV block on the recipient is created, the collator which builds that
block fetches the pairs of the sender from the CST and creates its own Merkle
root. When that PoV block is sent to the validator, the validator can just
fetch the Merkle root from the CST Root and verify the PoV block without
requiring the full list of pairs.

\subsection{Message content}

All messages sent to the recipient must contain enough information in order
for the recipient to verify those messages with the CST. This includes the
necessary Merkle trie nodes, the parent triple of each individual MQC block
and the messages themselves. The recipient then recreates the MQC and verifies
it against the CST.

\subsection{Watermark}

Collators of the recipient insert the messages into their parablock as
Inherents and publish the parablock to the relay chain. Once included, the
watermark is updated and points to the relay chain block number where the
inclusion ocurred.
\begin{alltt}

watermark: map ParaId => (BlockNumber, ParaId)

\end{alltt}

\section{SPREE}

...

\

\begin{flushright}
  {\qed}
\end{flushright}

\

\

\appendix\chapter{Cryptographic Algorithms}

\section{Hash Functions}\label{sect-hash-functions}

\section{BLAKE2}\label{sect-blake2}

BLAKE2 is a collection of cryptographic hash functions known for their high
speed. Their design closely resembles BLAKE which has been a finalist in the
SHA-3 competition.

Polkadot is using the Blake2b variant which is optimized for 64-bit platforms.
Unless otherwise specified, the Blake2b hash function with a 256-bit output is
used whenever Blake2b is invoked in this document. The detailed specification
and sample implementations of all variants of Blake2 hash functions can be
found in RFC 7693 {\cite{saarinen_blake2_2015}}.

\section{Randomness}\label{sect-randomness}

\section{VRF}\label{sect-vrf}

\section{Cryptographic Keys}\label{sect-cryptographic-keys}

Various types of keys are used in Polkadot to prove the identity of the actors
involved in the Polkadot Protocols. To improve the security of the users, each
key type has its own unique function and must be treated differently, as
described by this Section.

\begin{definition}
  \label{defn-account-key}{\tmstrong{Account key $(\tmop{sk}^a,
  \tmop{pk}^a)$}} is a key pair of type of either of the schemes listed in
  Table \ref{tabl-account-key-schemes}:
  {\center{\begin{table}[h]
    \begin{tabular}{ll}
      \hline
      Key scheme & Description\\
      \hline
      SR25519 & Schnorr signature on Ristretto compressed Ed25519 points as
      implemented in {\cite{burdges_schnorr_2019}}\\
      ED25519 & The standard ED25519 signature complying with
      {\cite{josefsson_edwards-curve_2017}}\\
      secp256k1 & Only for outgoing transfer transactions\\
      \hline
    \end{tabular}
    \caption{\label{tabl-account-key-schemes}List of the public key scheme
    which can be used for an account key}
  \end{table}}}
  An account key can be used to sign transactions among other accounts and
  blance-related functions.
\end{definition}

There are two prominent subcategories of account keys namely ``stash keys''
and ``controller keys'', each being used for a different function, as
described below.

\begin{definition}
  The \label{defn-stash-key}{\tmstrong{Stash key}} is a type of account key
  that holds funds bonded for staking (described in Section
  \ref{sect-staking-funds}) to a particular controller key (defined in
  Definition \ref{defn-controller-key}). As a result, one may actively
  participate with a stash key keeping the stash key offline in a secure
  location. It can also be used to designate a Proxy account to vote in
  governance proposals, as described in \ref{sect-creating-controller-key}.
  The Stash key holds the majority of the users' funds and should neither be
  shared with anyone, saved on an online device, nor used to submit
  extrinsics.
\end{definition}

\begin{definition}
  \label{defn-controller-key}The {\tmstrong{Controller key}} is a type of
  account key that acts on behalf of the Stash account. It signs transactions
  that make decisions regarding the nomination and the validation of the other
  keys. It is a key that will be in direct control of a user and should mostly
  be kept offline, used to submit manual extrinsics. It sets preferences like
  payout account and commission, as described in
  \ref{sect-controller-settings}. If used for a validator, it certifies the
  session keys, as described in \ref{sect-certifying-keys}. It only needs the
  required funds to pay transaction fees {\todo{key needing fund needs to be
  defined}}.
\end{definition}

Keys defined in Definitions \ref{defn-account-key}, \ref{defn-stash-key} and
\ref{defn-controller-key} are created and managed by the user independent of
the Polkadot implementation. The user notifies the network about the used keys
by submitting a transaction, as defined in \ref{sect-creating-controller-key}
and \ref{sect-certifying-keys} respectively.

\begin{definition}
  \label{defn-session-key}{\tmstrong{Session keys}} are short-lived keys that
  are used to authenticate validator operations. Session keys are generated by
  the Polkadot Host and should be changed regularly due to security reasons.
  Nonetheless, no validity period is enforced by the Polkadot protocol on
  session keys. Various types of keys used by the Polkadot Host are presented
  in Table \ref{tabl-session-keys}{\tmem{:}}
  
  \begin{table}[h]
    \begin{tabular}{ll}
      \hline
      Protocol & Key scheme\\
      \hline
      GRANDPA & ED25519\\
      BABE & SR25519\\
      I'm Online & SR25519\\
      Parachain & SR25519\\
      \hline
    \end{tabular}
    \caption{\label{tabl-session-keys}List of key schemes which are used for
    session keys depending on the protocol}
  \end{table}
\end{definition}

Session keys must be accessible by certain Polkadot Host APIs defined in
Appendix \ref{sect-host-api}. Session keys are {\tmem{not}} meant to control
the majority of the users' funds and should only be used for their intended
purpose. {\todo{key managing fund need to be defined}}

\subsection{Holding and staking funds}\label{sect-staking-funds}

To be specced

\subsection{Creating a Controller key}\label{sect-creating-controller-key}

To be specced

\subsection{Designating a proxy for voting}\label{sect-designating-proxy}

To be specced

\subsection{Controller settings}\label{sect-controller-settings}

To be specced

\subsection{Certifying keys}\label{sect-certifying-keys}

Due to security considerations and Runtime upgrades, the session keys are
supposed to \ be changed regularly. As such, the new session keys need to be
certified by a controller key before putting them in use. The controller only
needs to create a certificate by signing a session public key and broadcasting
this certificate via an extrinsic. {\todo{spec the detail of the data
structure of the certificate etc.}}

\

\begin{flushright}
  {\qed}
\end{flushright}

\

\chapter{Auxiliary Encodings}\label{sect-encoding}

\section{SCALE Codec}\label{sect-scale-codec}

The Polkadot Host uses {\tmem{Simple Concatenated Aggregate Little-Endian''
(SCALE) codec}} to encode byte arrays as well as other data structures. SCALE
provides a canonical encoding to produce consistent hash values across their
implementation, including the Merkle hash proof for the State Storage.

\begin{definition}
  \label{defn-scale-byte-array}The {\tmstrong{SCALE codec}} for
  {\tmstrong{Byte array}} $A$ such that
  \[ A \assign b_1 b_2 \ldots b_n \]
  such that $n < 2^{536}$ is a byte array refered to $\tmop{Enc}_{\tmop{SC}}
  (A)$ and defined as:
  \[ \tmop{Enc}_{\tmop{SC}} (A) \assign \tmop{Enc}^{\tmop{Len}}_{\tmop{SC}}
     (\| A \|) | | A \]
  where $\tmop{Enc}_{\tmop{SC}}^{\tmop{Len}}$ is defined in Definition
  \ref{defn-sc-len-encoding}. 
\end{definition}

\begin{definition}
  \label{defn-scale-tuple}The {\tmstrong{SCALE codec}} for {\tmstrong{Tuple}}
  $T$ such that:
  \[ T \assign (A_1, \ldots, A_n) \]
  Where $A_i$'s are values of {\tmstrong{different types}}, is defined as:
  \[ \tmop{Enc}_{\tmop{SC}} (T) \assign \tmop{Enc}_{\tmop{SC}} (A_1) | |
     \tmop{Enc}_{\tmop{SC}} (A_2) | | \ldots | | \tmop{Enc}_{\tmop{SC}} (A_n)
  \]
\end{definition}

In case of a tuple (or struct), the knowledge of the shape of data is not
encoded even though it is necessary for decoding. The decoder needs to derive
that information from the context where the encoding/decoding is happenning.

\begin{definition}
  $\text{\text{}{\tmstrong{Dec\tmrsub{SC}\text{}(d)}}}$ refers to the decoding
  of a blob of data. Since the SCALE codec is not self-describing, it's up to
  the decoder to validate whether the blob of data can be deserialized into
  the given type or datastructure.
\end{definition}

\begin{definition}
  \label{defn-varrying-data-type}We define a {\tmstrong{varying data}} type to
  be an ordered set of data types
  \[ \mathcal{T}= \{ T_1, \ldots, T_n \} \]
  A value $\tmmathbf{A}$ of varying date type is a pair $(A_{\tmop{Type}},
  A_{\tmop{Value}})$ where $A_{\tmop{Type}} = T_i$ for some $T_i \in
  \mathcal{T}$ and $A_{\tmop{Value}}$ is its value of type $T_i$, which can be
  empty. We define $\tmop{idx} (T_i) = i - 1$, unless it is explicitly defined
  as another value in the definition of a particular varying data type.
\end{definition}

In particular, we define two specific varying data which are frequently used
in various part of Polkadot Protocol.

\begin{definition}
  $\label{defn-option-type}$The {\tmstrong{Option}} type is a varying data
  type of $\{\tmop{None}, T_2 \}$ which indicates if data of $T_2$ type is
  available (referred to as ``some'' state) or not (referred to as ``empty'',
  ``none'' or ``null'' state). The presence of type None, indicated by
  $\tmop{idx} (T_{\tmop{None}}) = 0$, implies that the data corresponding to
  $T_2$ type is not available and contains no additional data. Where as the
  presence of type $T_2$ indicated by $\tmop{idx} (T_2) = 1$ implies that the
  data is available.
\end{definition}

\begin{definition}
  \label{defn-result-type}The {\tmstrong{Result}} type is a varying data type
  of $\{ T_1, T_2 \}$ which is used to indicate if a certain operation or
  function was executed successfully (referred to as ``ok'' state) or not
  (referred to as ``err'' state). $T_1$ implies success, $T_2$ implies
  failure. Both types can either contain additional data or are defined as
  empty type otherwise.
\end{definition}

\begin{definition}
  \label{defn-scale-variable-type}Scale coded for value {\tmstrong{$A =
  (A_{\tmop{Type}}, A_{\tmop{Value}})$ of varying data type}} $\mathcal{T}= \{
  T_1, \ldots, T_n \}$
  \[ \tmop{Enc}_{\tmop{SC}} (A) \assign \tmop{Enc}_{\tmop{SC}} (\tmop{Idx}
     (A_{\tmop{Type}})) | | \tmop{Enc}_{\tmop{SC}} (A_{\tmop{Value}}) \]
  Where $\tmop{Idx}$ is encoded in a fixed length integer determining the type
  of $A$.
  
  In particular, for the optional type defined in Definition
  \ref{defn-varrying-data-type}, we have:
  \[ \tmop{Enc}_{\tmop{SC}} ((\tmop{None}, \phi)) \assign 0_{\mathbb{B}_1} \]
\end{definition}

SCALE codec does not encode the correspondence between the value of
$\tmop{Idx}$ defined in Definition \ref{defn-scale-variable-type} and the data
type it represents; the decoder needs prior knowledge of such correspondence
to decode the data.

\begin{definition}
  \label{defn-scale-list}The {\tmstrong{SCALE codec}} for
  {\tmstrong{sequence}} $S$ such that:
  \[ S \assign A_1, \ldots, A_n \]
  where $A_i$'s are values of {\tmstrong{the same type}} (and the decoder is
  unable to infer value of $n$ from the context) is defined as:
  \[ \tmop{Enc}_{\tmop{SC}} (S) \assign \tmop{Enc}^{\tmop{Len}}_{\tmop{SC}}
     (\| S \|) | \tmop{Enc}_{\tmop{SC}} (A_1) | \tmop{Enc}_{\tmop{SC}} (A_2) |
     \ldots | \tmop{Enc}_{\tmop{SC}} (A_n) \]
  where $\tmop{Enc}_{\tmop{SC}}^{\tmop{Len}}$ is defined in Definition
  \ref{defn-sc-len-encoding}.
\end{definition}

\begin{definition}
  SCALE codec for {\tmstrong{dictionary}} or {\tmstrong{hashtable}} D with
  key-value pairs $(k_i, v_i)$s such that:
  \[ D \assign \{ (k_1, v_1), \ldots, (k_1, v_n) \} \]
  is defined the SCALE codec of $D$ as a sequence of key value pairs (as
  tuples):
  \[ \tmop{Enc}_{\tmop{SC}} (D) \assign \tmop{Enc}^{\tmop{Size}}_{\tmop{SC}}
     (| | D | |) | \tmop{Enc}_{\tmop{SC}} ((k_1, v_1) ) |
     \tmop{Enc}_{\tmop{SC}} ((k_2, v_2)) | \ldots | \tmop{Enc}_{\tmop{SC}}
     ((k_n, v_n)) \]
  $\tmop{Enc}^{\tmop{Size}}_{\tmop{SC}}$ is encoded the same way as
  $\tmop{Enc}^{\tmop{Len}}_{\tmop{SC}}$ but argument $\tmop{size}$ refers to
  the number of key-value pairs rather than the length.
\end{definition}

\begin{definition}
  The {\tmstrong{SCALE codec}} for {\tmstrong{boolean value}} $b$ defined as a
  byte as follows:
  \[ \begin{array}{ll}
       \tmop{Enc}_{\tmop{SC}} : & \{ \tmop{False}, \tmop{True} \} \rightarrow
       \mathbb{B}_1\\
       & b \rightarrow \left\{ \begin{array}{lcl}
         0 &  & b = \tmop{False}\\
         1 &  & b = \tmop{True}
       \end{array} \right.
     \end{array} \]
\end{definition}

\begin{definition}
  \label{defn-scale-fixed-length}The {\tmstrong{SCALE codec,
  $\tmop{Enc}_{\tmop{SC}}$}} for other types such as fixed length integers not
  defined here otherwise, is equal to little endian encoding of those values
  defined in Definition \ref{defn-little-endian}. 
\end{definition}

\begin{definition}
  \label{defn-scale-empty}The {\tmstrong{SCALE codec,
  $\tmop{Enc}_{\tmop{SC}}$}} for an empty type is defined to a byte array of
  zero length and depicted as {\tmstrong{$\phi$}}.
\end{definition}

\subsection{Length and Compact Encoding}\label{sect-int-encoding}

{\tmem{SCALE Length encoding}} is used to encode integer numbers of variying
sizes prominently in an encoding length of arrays:

\begin{definition}
  \label{defn-sc-len-encoding}{\tmstrong{SCALE Length Encoding,
  $\tmop{Enc}^{\tmop{Len}}_{\tmop{SC}}$}} also known as compact encoding of a
  non-negative integer number $n$ is defined as follows:
  \[ \begin{array}{ll}
       \tmop{Enc}^{\tmop{Len}}_{\tmop{SC}} : & \mathbb{N} \rightarrow
       \mathbb{B}\\
       & n \rightarrow b \assign \left\{ \begin{array}{lll}
         l^{\nosymbol}_1 &  & 0 \leqslant n < 2^6\\
         i^{\nosymbol}_1 i^{\nosymbol}_2 &  & 2^6 \leqslant n < 2^{14}\\
         j^{\nosymbol}_1 j^{\nosymbol}_2 j_3 &  & 2^{14} \leqslant n <
         2^{30}\\
         k_1^{\nosymbol} k_2^{\nosymbol} \ldots k_m^{\nosymbol}  &  & 2^{30}
         \leqslant n
       \end{array} \right.
     \end{array} \]
  in where the least significant bits of the first byte of byte array b are
  defined as follows:
  \[ \begin{array}{lcc}
       l^1_1 l_1^0 & = & 00\\
       i^1_1 i_1^0 & = & 01\\
       j^1_1 j_1^0 & = & 10\\
       k^1_1 k_1^0 & = & 11
     \end{array} \]
  and the rest of the bits of $b$ store the value of $n$ in little-endian
  format in base-2 as follows:
  \[ \left. \begin{array}{lll}
       l^7_1 \ldots l^3_1 l^2_1 &  & n < 2^6\\
       i_2^7 \ldots i_2^0 i_1^7 {\ldots i^2_1}^{\nosymbol} &  & 2^6 \leqslant
       n < 2^{14}\\
       j_4^7 \ldots j_4^0 j_3^7 \ldots j_1^7 \ldots j^2_1 &  & 2^{14}
       \leqslant n < 2^{30}\\
       k_2 + k_3 2^8 + k_4 2^{2 \cdot 8} + \cdots + k_m 2^{(m - 2) 8} &  &
       2^{30} \leqslant n
     \end{array} \right\} \assign n \]
  such that:
  \[ k^7_1 \ldots k^3_1 k^2_1 : = m - 4 \]
\end{definition}

\section{Hex Encoding}

Practically, it is more convenient and efficient to store and process data
which is stored in a byte array. On the other hand, the Trie keys are broken
into 4-bits nibbles. Accordingly, we need a method to encode sequences of
4-bits nibbles into byte arrays canonically:

\begin{definition}
  \label{defn-hex-encoding}Suppose that $\tmop{PK} = (k_1, \ldots, k_n)$ is a
  sequence of nibbles, then
  
  \begin{tabular}{l}
    $\tmop{Enc}_{\tmop{HE}} (\tmop{PK}) \assign$\\
    $\left\{ \begin{array}{lll}
      \tmop{Nibbles}_4 & \rightarrow & \mathbb{B}\\
      \tmop{PK} = (k_1, \ldots, k_n) & \mapsto & \left\{ \begin{array}{l}
        \begin{array}{ll}
          (16 k_1 + k_2, \ldots, 16 k_{2 i - 1} + k_{2 i}) & n = 2 i\\
          (k_1, 16 k_2 + k_3, \ldots, 16 k_{2 i} + k_{2 i + 1}) & n = 2 i + 1
        \end{array}
      \end{array} \right.
    \end{array} \right.$
  \end{tabular}
\end{definition}

\

\begin{flushright}
  {\qed}
\end{flushright}

\

\chapter{Genesis State Specification}\label{sect-genesis-block}

The genesis state is a set of key-value pairs representing the intial state of
the Polkadot state storage. It can be retrieved from
{\cite{paritytech_genesis_state}}. While each of those key-value pairs offers
important identifyable information to the Runtime, to the Polkadot Host they
are a transparent set of arbitrary chain- and network-dependent keys and
values. The only exception to this are the \tmverbatim{:code} and
\tmverbatim{:heappages} keys as described in Section
\ref{sect-loading-runtime-code} and \ref{sect-memory-management}, which are
used by the Polkadot Host to initialize the WASM environment and its Runtime.
The other keys and values are unspecifed and soley depend on the chain and
respectively its corresponding Runtime. On initialization the data should be
inserted into the state storage with the \tmverbatim{set\_storage} Host API,
as defined in Section \ref{sect-storage-set}.

\

As such, Polkadot does not defined a formal genesis block. Nonetheless for
the compatibility reasons in several algorithms, the Polkadot Host defines the
{\tmem{genesis header}} according to Definition \ref{defn-genesis-header}. By
the abuse of terminalogy, ``{\tmem{genesis block}}'' refers to the
hypothetical parent of block number 1 which holds genisis header as its
header.

\begin{definition}
  \label{defn-genesis-header}The Polkadot genesis header is a data structure
  conforming to block header format described in section
  \ref{defn-block-header}. It contains the values depicted in Table
  \ref{tabl-genesis-header}:
  
  \begin{table}[h]
    \begin{tabular}{ll}
      \hline
      Block header field & Genesis Header Value\\
      \hline
      \tmverbatim{}{\tmsamp{parent\_hash}} & 0\\
      {\tmsamp{number}} & 0\\
      \tmverbatim{state\_root} & Merkle hash of the state storage trie as
      defined in Definition \ref{defn-merkle-value} \\
      & after inserting the genesis state in it.\\
      {\tmsamp{extrinsics\_root}} & 0\\
      {\tmsamp{digest}} & 0\\
      \hline
    \end{tabular}
    \caption{\label{tabl-genesis-header}Genesis header values}
  \end{table}
\end{definition}

\

\begin{flushright}
  {\qed}
\end{flushright}

\

\chapter{Polkadot Host API}\label{sect-host-api}

The Polkadot Host API is a set of functions that the Polkadot Host exposes to
Runtime to access external functions needed for various reasons, such as the
Storage of the content, access and manipulation, memory allocation, and also
efficiency. The encoding of each data type is specified or referenced in this
section. If the encoding is not mentioned, then the default Wasm encoding is
used, such as little-endian byte ordering for integers.

\begin{notation}
  \label{nota-host-api-at-state}By $\mathcal{R}\mathcal{E}_B$ we refer to the
  API exposed by the Polkadot Host which interact, manipulate and response
  based on the state storage whose state is set at the end of the execution of
  block $B$.
\end{notation}

\begin{definition}
  \label{defn-runtime-pointer}The \tmtextbf{Runtime pointer} type is a
  \tmverbatim{i32} integer representing a pointer to data in memory. This
  pointer is the primary way to exchange data of fixed/known size between the
  Runtime and Polkadot Host.
\end{definition}

\begin{definition}
  \label{defn-runtime-pointer-size}The {\tmstrong{Runtime pointer-size}} type
  is an \tmverbatim{i64} integer, representing two consecutive
  \tmverbatim{i32} integers. The least significant is a pointer to the data in
  memory. The most significant provides the size of the data in bytes. This
  representation is the primary way to exchange data of arbitrary/dynamic
  sizes between the Runtime and the Polkadot Host.
\end{definition}

\begin{definition}
  \label{defn-lexicographic-ordering}{\tmstrong{Lexicographic ordering}}
  refers to the ascending ordering of bytes or byte arrays, such as:
  \[ [0, 0, 2] < [0, 1, 1] < [0, 2, 0] < [1] < [1, 1, 0] < [2] < [\ldots] \]
\end{definition}

The functions are specified in each subsequent subsection for each category
of those functions.

\section{Storage}

Interface for accessing the storage from within the runtime.

\subsection{\tmverbatim{ext\_storage\_set}}\label{sect-storage-set}

Sets the value under a given key into storage.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} containing the key.
  
  \item \tmverbatim{value}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} containing the value.
\end{itemize}

\subsection{\tmverbatim{ext\_storage\_get}}

Retrieves the value associated with the given key from storage.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} containing the key.
  
  \item \tmverbatim{result}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} returning the SCALE encoded
  \tmverbatim{Option} as defined in Definition \ref{defn-option-type}
  containing the value.
\end{itemize}

\subsection{\tmverbatim{ext\_storage\_read}}

Gets the given key from storage, placing the value into a buffer and returning
the number of bytes that the entry in storage has beyond the offset.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} containing the key.
  
  \item \tmverbatim{value\_out}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} containing the buffer to which the value
  will be written to. This function will never write more then the length of
  the buffer, even if the value's length is bigger.
  
  \item \tmverbatim{offset}: an u32 integer containing the offset beyond the
  value should be read from.
  
  \item \tmverbatim{result}: a pointer-size (Definition
  \ref{defn-runtime-pointer-size}) pointing to a SCALE encoded
  \tmverbatim{Option} (Definition \ref{defn-option-type}) containing an
  unsinged 32-bit interger representing the number of bytes left at supplied
  \tmverbatim{offset}. Returns \tmverbatim{None} if the entry does not exists.
\end{itemize}

\subsection{\tmverbatim{ext\_storage\_clear}}

Clears the storage of the given key and its value.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} containing the key.
\end{itemize}

\subsection{\tmverbatim{ext\_storage\_exists}}

Checks whether the given key exists in storage.

\subsubsection{Version 1 - Prototype}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} containing the key.
  
  \item \tmverbatim{return}: an i32 integer value equal to \tmverbatim{1} if
  the key exists or a value equal to \tmverbatim{0} if otherwise.
\end{itemize}

\subsection{\tmverbatim{ext\_storage\_clear\_prefix}}

Clear the storage of each key/value pair where the key starts with the given
prefix.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{prefix}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} containing the prefix.
\end{itemize}

\subsection{\tmverbatim{ext\_storage\_append}}

Append the SCALE encoded value to a SCALE encoded sequence (Definition
\ref{defn-scale-list}) at the given key. This function assumes that the
existing storage item is either empty or a SCALE encoded sequence and that the
value to append is also SCALE encoded and of the same type as the items in the
existing sequence.

\

To improve performance, this function is allowed to skip decoding the entire
SCALE encoded sequence and instead can just append the new item to the end of
the existing data and increment the length prefix
$\tmop{Enc}^{\tmop{Len}}_{\tmop{SC}}$.

\

{\tmstrong{Warning}}: If the storage item does not exist or is not SCALE
encoded, the storage item will be set to the specified value, represented as a
SCALE encoded byte array.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} containing the key.
  
  \item \tmverbatim{value}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} containing the value to be appended.
\end{itemizedot}

\subsection{\tmverbatim{ext\_storage\_root}}

Compute the storage root.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{return}: a 32-bit pointer to the buffer containing the
  256-bit Blake2 storage root.
\end{itemize}
\subsection{\tmverbatim{ext\_storage\_changes\_root}}\label{sect-ext-storage-changes-root}

Compute the root of the Changes Trie as described in Section
\ref{sect-changes-trie}. The parent hash is a SCALE encoded block hash.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{parent\_hash}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer-size} indicating the SCALE encoded
  block hash.
  
  \item \tmverbatim{return}: a 32-bit pointer to the buffer containing the
  256-bit Blake2 changes root.
\end{itemize}

\subsection{\tmverbatim{ext\_storage\_next\_key}}

Get the next key in storage after the given one in lexicographic order
(Definition \ref{defn-lexicographic-ordering}). The key provided to this
function may or may not exist in storage.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the key.
  
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the SCALE encoded
  \tmverbatim{Option} as defined in Definition \ref{defn-option-type}
  containing the next key in lexicographic order.
\end{itemize}
\subsection{\tmverbatim{ext\_storage\_start\_transaction}}\label{sect-ext-storage-start-transaction}

Start a new nested transaction. This allows to either commit or roll back all
changes that are made after this call. For every transaction there must be a
matching call to either \tmverbatim{ext\_storage\_rollback\_transaction}
(\ref{sect-ext-storage-rollback-transaction}) or
\tmverbatim{ext\_storage\_commit\_transaction}
(\ref{sect-ext-storage-commit-transaction}). This is also effective for all
values manipulated using the child storage API (\ref{sect-child-storage-api}).

\

{\tmstrong{Warning}}: This is a low level API that is potentially dangerous
as it can easily result in unbalanced transactions. Runtimes should use high
level storage abstractions.

\subsubsection{Version 1 - Prototype}

\tmverbatim{(func \$ext\_storage\_start\_transaction\_version\_1)}

\

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item None.
\end{itemizedot}
\subsection{\tmverbatim{ext\_storage\_rollback\_transaction}}\label{sect-ext-storage-rollback-transaction}

Rollback the last transaction started by
\tmverbatim{ext\_storage\_start\_transaction}
(\ref{sect-ext-storage-start-transaction}). Any changes made during that
transaction are discarded.

\

{\tmstrong{Warning}}: Panics if there is no open transaction
(\tmverbatim{ext\_storage\_start\_transaction}
(\ref{sect-ext-storage-start-transaction}) was not called)

\subsubsection{Version 1 - Prototype}

\tmverbatim{(func \$ext\_storage\_rollback\_transaction\_version\_1)}

\

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item None.
\end{itemizedot}
\subsection{\tmverbatim{ext\_storage\_commit\_transaction}}\label{sect-ext-storage-commit-transaction}

Commit the last transaction started by
\tmverbatim{ext\_storage\_start\_transaction}
(\ref{sect-ext-storage-start-transaction}). Any changes made during that
transaction are committed to the main state.

\

{\tmstrong{Warning}}: Panics if there is no open transaction
(\tmverbatim{ext\_storage\_start\_transaction}
(\ref{sect-ext-storage-start-transaction}) was not called)

\subsubsection{Version 1 - Prototype}

\tmverbatim{(func \$ext\_storage\_commit\_transaction\_version\_1)}

\

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item None.
\end{itemizedot}
\section{Child Storage}\label{sect-child-storage-api}

Interface for accessing the child storage from within the runtime.

\begin{definition}
  \label{defn-child-storage-type}{\tmstrong{Child storage}} key is a
  unprefixed location of the child trie in the main trie.
\end{definition}

\subsection{\tmverbatim{ext\_default\_child\_storage\_set}}

Sets the value under a given key into the child storage.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{child\_storage\_key}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer-size} indicating the child storage key
  as defined in Definition \ref{defn-child-storage-type}.
  
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the key.
  
  \item \tmverbatim{value}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the value.
\end{itemize}

\subsection{\tmverbatim{ext\_default\_child\_storage\_get}}

Retrieves the value associated with the given key from the child storage.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{child\_storage\_key}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer-size} indicating the child storage key
  as defined in Definition \ref{defn-child-storage-type}.
  
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the key.
  
  \item \tmverbatim{result}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the SCALE encoded
  \tmverbatim{Option} as defined in Definition \ref{defn-option-type}
  containing the value.
\end{itemize}

\subsection{\tmverbatim{ext\_default\_child\_storage\_read}}

Gets the given key from storage, placing the value into a buffer and returning
the number of bytes that the entry in storage has beyond the offset.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{child\_storage\_key}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer-size} indicating the child storage key
  as defined in Definition \ref{defn-child-storage-type}.
  
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the key.
  
  \item \tmverbatim{value\_out}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the buffer to which the value
  will be written to. This function will never write more then the length of
  the buffer, even if the value's length is bigger.
  
  \item \tmverbatim{offset}: an u32 integer containing the offset beyond the
  value should be read from.
  
  \item \tmverbatim{result}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the SCALE encoded
  \tmverbatim{Option} as defined in Definition \ref{defn-option-type}
  containing the number of bytes written into the {\tmstrong{value\_out}}
  buffer. Returns \tmverbatim{None} if the entry does not exists.
\end{itemize}

\subsection{\tmverbatim{ext\_default\_child\_storage\_clear}}

Clears the storage of the given key and its value from the child storage.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{child\_storage\_key}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer-size} indicating the child storage key
  as defined in Definition \ref{defn-child-storage-type}.
  
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the key.
\end{itemize}

\subsection{\tmverbatim{ext\_default\_child\_storage\_storage\_kill}}

Clears an entire child storage.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{child\_storage\_key}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer-size} indicating the child storage key
  as defined in Definition \ref{defn-child-storage-type}.
\end{itemize}

\subsection{\tmverbatim{ext\_default\_child\_storage\_exists}}

Checks whether the given key exists in the child storage.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{child\_storage\_key}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer-size} indicating the child storage key
  as defined in Defintion \ref{defn-child-storage-type}.
  
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the key.
  
  \item \tmverbatim{return}: an i32 integer value equal to \tmverbatim{1} if
  the key exists or a value equal to \tmverbatim{0} if otherwise.
\end{itemize}

\subsection{\tmverbatim{ext\_default\_child\_storage\_clear\_prefix}}

Clears the child storage of each key/value pair where the key starts with the
given prefix.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{child\_storage\_key}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer-size} indicating the child storage key
  as defined in Definition \ref{defn-child-storage-type}.
  
  \item \tmverbatim{prefix}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the prefix.
\end{itemize}

\subsection{\tmverbatim{ext\_default\_child\_storage\_root}}

Commits all existing operations and computes the resulting child storage root.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{child\_storage\_key}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer-size} indicating the child storage key
  as defined in Definition \ref{defn-child-storage-type}.
  
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the SCALE encoded storage root.
\end{itemize}

\subsection{\tmverbatim{ext\_default\_child\_storage\_next\_key}}

Gets the next key in storage after the given one in lexicographic order
(Definition \ref{defn-lexicographic-ordering}). The key provided to this
function may or may not exist in storage.

\subsubsection{Version 1 - Prototype}


{\tmstrong{\tmverbatim{}Arguments}}:
\begin{itemize}
  \item \tmverbatim{child\_storage\_key}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer-size} indicating the child storage key
  as defined in Definition \ref{defn-child-storage-type}.
  
  \item {\tmstrong{}}\tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the key.
  
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the SCALE encoded
  \tmverbatim{Option} as defined in Definition \ref{defn-option-type}
  containing the next key in lexicographic order. Returns \tmverbatim{None} if
  the entry cannot be found.
\end{itemize}

\section{Crypto}

Interfaces for working with crypto related types from within the runtime.

\begin{definition}
  \label{defn-key-type-id}Cryptographic keys are stored in seperate key stores
  based on their intended use case. The seperate key stores are identified by
  a 4-byte ASCII {\tmstrong{key type identifier}}. The following known types
  are available:
  
  \begin{table}[h]
    \begin{tabular}{ll}
      {\tmstrong{Id}} & {\tmstrong{Description}}\\
      \hline
      acco & Key type for the controlling accounts\\
      babe & Key type for the Babe module\\
      gran & Key type for the Grandpa module\\
      imon & Key type for the ImOnline module\\
      audi & Key type for the AuthorityDiscovery module\\
      para & Key type for the Parachain Validator Key\\
      asgn & Key type for the Parachain Assignment Key
    \end{tabular}
    \caption{Table of known key type identifiers}
  \end{table}
\end{definition}

\begin{definition}
  \label{defn-ecdsa-verify-error}{\tmstrong{EcdsaVerifyError}} is a varying
  data type as defined in Definition \ref{defn-varrying-data-type} and
  specifies the error type when using ECDSA recovery functionality. Following
  values are possible:
  
  \begin{table}[h]
    \begin{tabular}{ll}
      {\tmstrong{Id}} & {\tmstrong{Description}}\\
      0 & Incorrect value of R or S\\
      1 & Incorrect value of V\\
      2 & Invalid signature
    \end{tabular}
    \caption{Table of error types in ECDSA recovery}
  \end{table}
\end{definition}

\subsection{\tmverbatim{ext\_crypto\_ed25519\_public\_keys}}

Returns all \tmverbatim{ed25519} public keys for the given key identifier from
the keystore.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{key\_type\_id}: a 32-bit pointer to the key
  type identifier as defined in Defintion \ref{defn-key-type-id}.
  
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} to an SCALE encoded \ 256-bit public keys.
\end{itemize}

\subsection{\tmverbatim{ext\_crypto\_ed25519\_generate}}

Generates an \tmverbatim{ed25519} key for the given key type using an optional
BIP-39 seed and stores it in the keystore.

\

{\tmstrong{Warning}}: Panics if the key cannot be generated, such as when an
invalid key type or invalid seed was provided.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{key\_type\_id}: a 32-bit pointer to the key
  type identifier as defined in Definition \ref{defn-key-type-id}.
  
  \item \tmverbatim{seed}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the SCALE encoded
  \tmverbatim{Option} as defined in Definition \ref{defn-option-type}
  containing the BIP-39 seed which must be valid UTF8.
  
  \item \tmverbatim{return}: a 32-bit pointer to the buffer containing the
  256-bit public key.
\end{itemize}

\subsection{\tmverbatim{ext\_crypto\_ed25519\_sign}}

Signs the given message with the \tmverbatim{ed25519} key that corresponds to
the given public key and key type in the keystore.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{key\_type\_id}: a 32-bit pointer to the key
  type identifier as defined in Definition \ref{defn-key-type-id}.
  
  \item \tmverbatim{key}: a 32-bit pointer to the buffer containing the
  256-bit public key.
  
  \item \tmverbatim{msg}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the message that is to be signed.
  
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the SCALE encoded
  \tmverbatim{Option} as defined in Definition \ref{defn-option-type}
  containing the 64-byte signature. This function returns \tmverbatim{None} if
  the public key cannot be found in the key store.
\end{itemize}
\subsection{\tmverbatim{ext\_crypto\_ed25519\_verify}}\label{sect-ext-crypto-ed25519-verify}

Verifies an \tmverbatim{ed25519} signature. Returns \tmverbatim{true} when the
verification is either successful or batched. If no batching verification
extension is registered, this function will fully verify the signature and
return the result. If batching verification is registered, this function will
push the data to the batch and return immediately. The caller can then get the
result by calling \tmverbatim{ext\_crypto\_finish\_batch\_verify}
(\ref{sect-ext-crypto-finish-batch-verify}).

\

The verification extension is explained more in detail in
\tmverbatim{ext\_crypto\_start\_batch\_verify}
(\ref{sect-ext-crypto-start-batch-verify}).

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{sig}: a 32-bit pointer to the buffer
  containing the 64-byte signature.
  
  \item \tmverbatim{msg}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the message that is to be
  verified.
  
  \item \tmverbatim{key}: a 32-bit pointer to the buffer containing the
  256-bit public key.
  
  \item \tmverbatim{return}: a i32 integer value equal to \tmverbatim{1} if
  the signature is valid or batched or a value equal to \tmverbatim{0} if
  otherwise.
\end{itemize}

\subsection{\tmverbatim{ext\_crypto\_sr25519\_public\_keys}}

Returns all \tmverbatim{sr25519} public keys for the given key id from the
keystore.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{key\_type\_id}: a 32-bit pointer to the key
  type identifier as defined in \ref{defn-key-type-id}.
  
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the SCALE encoded 256-bit public
  keys.
\end{itemize}

\subsection{\tmverbatim{ext\_crypto\_sr25519\_generate}}

Generates an \tmverbatim{sr25519} key for the given key type using an optional
BIP-39 seed and stores it in the keystore.

\

{\tmstrong{Warning}}: Panics if the key cannot be generated, such as when an
invalid key type or invalid seed was provided.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{key\_type\_id}: a 32-bit pointer to the key
  identifier as defined in Definition \ref{defn-key-type-id}.
  
  \item \tmverbatim{seed}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the SCALE encoded
  \tmverbatim{Option} as defined in Definition \ref{defn-option-type}
  containing the BIP-39 seed which must be valid UTF8.
  
  \item \tmverbatim{return}: a 32-bit pointer to the buffer containing the
  256-bit public key.
\end{itemize}

\subsection{\tmverbatim{ext\_crypto\_sr25519\_sign}}

Signs the given message with the \tmverbatim{sr25519} key that corresponds to
the given public key and key type in the keystore.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{key\_type\_id}: a 32-bit pointer to the key
  identifier as defined in Definition \ref{defn-key-type-id}
  
  \item \tmverbatim{key}: a 32-bit pointer to the buffer containing the
  256-bit public key.
  
  \item \tmverbatim{msg}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the message that is to be signed.
  
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the SCALE encoded
  \tmverbatim{Option} as defined in Definition \ref{defn-option-type}
  containing the 64-byte signature. This function returns \tmverbatim{None} if
  the public key cannot be found in the key store.
\end{itemize}
\subsection{\tmverbatim{ext\_crypto\_sr25519\_verify}}\label{sect-ext-crypto-sr25519-verify}

Verifies an \tmverbatim{sr25519} signature. Only version 1 of this function
supports deprecated Schnorr signatures introduced by the {\tmem{schnorrkel}}
Rust library version 0.1.1 and should only be used for backward compatibility.

\

Returns \tmverbatim{true} when the verification is either successful or
batched. If no batching verification extension is registered, this function
will fully verify the signature and return the result. If batching
verification is registered, this function will push the data to the batch and
return immediately. The caller can then get the result by calling
\tmverbatim{ext\_crypto\_finish\_batch\_verify}
(\ref{sect-ext-crypto-finish-batch-verify}).

\

The verification extension is explained more in detail in
\tmverbatim{ext\_crypto\_start\_batch\_verify}
(\ref{sect-ext-crypto-start-batch-verify}).

\subsubsection{Version 2 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{sig}: a 32-bit pointer to the buffer
  containing the 64-byte signature.
  
  \item \tmverbatim{msg}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the message that is to be
  verified.
  
  \item \tmverbatim{key}: a 32-bit pointer to the buffer containing the
  256-bit public key.
  
  \item \tmverbatim{return}: a i32 integer value equal to \tmverbatim{1} if
  the signature is valid or a value equal to \tmverbatim{0} if otherwise.
\end{itemize}

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{sig}: a 32-bit pointer to the buffer
  containing the 64-byte signature.
  
  \item \tmverbatim{msg}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the message that is to be
  verified.
  
  \item \tmverbatim{key}: a 32-bit pointer to the buffer containing the
  256-bit public key.
  
  \item \tmverbatim{return}: a i32 integer value equal to \tmverbatim{1} if
  the signature is valid or a value equal to \tmverbatim{0} if otherwise.
\end{itemize}

\subsection{\tmverbatim{ext\_crypto\_ecdsa\_public\_keys}}

Returns all \tmverbatim{ecdsa} public keys for the given key id from the
keystore.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{key\_type\_id}: a 32-bit pointer to the key
  type identifier as defined in \ref{defn-key-type-id}.
  
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the SCALE encoded 33-byte
  compressed public keys.
\end{itemize}

\subsection{\tmverbatim{ext\_crypto\_ecdsa\_generate}}

Generates an \tmverbatim{ecdsa} key for the given key type using an optional
BIP-39 seed and stores it in the keystore.

\

{\tmstrong{Warning}}: Panics if the key cannot be generated, such as when an
invalid key type or invalid seed was provided.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{key\_type\_id}: a 32-bit pointer to the key
  identifier as defined in Definition \ref{defn-key-type-id}.
  
  \item \tmverbatim{seed}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the SCALE encoded
  \tmverbatim{Option} as defined in Definition \ref{defn-option-type}
  containing the BIP-39 seed which must be valid UTF8.
  
  \item \tmverbatim{return}: a 32-bit pointer to the buffer containing the
  33-byte compressed public key.
\end{itemize}

\subsection{\tmverbatim{ext\_crypto\_ecdsa\_sign}}

Signs the given message with the \tmverbatim{ecdsa} key that corresponds to
the given public key and key type in the keystore.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{key\_type\_id}: a 32-bit pointer to the key
  identifier as defined in Definition \ref{defn-key-type-id}
  
  \item \tmverbatim{key}: a 32-bit pointer to the buffer containing the
  33-byte compressed public key.
  
  \item \tmverbatim{msg}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the message that is to be signed.
  
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the SCALE encoded
  \tmverbatim{Option} as defined in Definition \ref{defn-option-type}
  containing the signature. The signature is 65-bytes in size, where the first
  512-bits represent the signature and the other 8 bits represent the recovery
  ID. This function returns \tmverbatim{None} if the public key cannot be
  found in the key store.
\end{itemize}
\subsection{\tmverbatim{ext\_crypto\_ecdsa\_verify}}\label{sect-ext-crypto-ecdsa-verify}

Verifies an \tmverbatim{ecdsa} signature. Returns \tmverbatim{true} when the
verification is either successful or batched. If no batching verification
extension is registered, this function will fully verify the signature and
return the result. If batching verification is registered, this function will
push the data to the batch and return immediately. The caller can then get the
result by calling \tmverbatim{ext\_crypto\_finish\_batch\_verify}
(\ref{sect-ext-crypto-finish-batch-verify}).

\

The verification extension is explained more in detail in
\tmverbatim{ext\_crypto\_start\_batch\_verify}
(\ref{sect-ext-crypto-start-batch-verify}).

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{sig}: a 32-bit pointer to the buffer
  containing the 65-byte signature. The signature is 65-bytes in size, where
  the first 512-bits represent the signature and the other 8 bits represent
  the recovery ID.
  
  \item \tmverbatim{msg}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the message that is to be
  verified.
  
  \item \tmverbatim{key}: a 32-bit pointer to the buffer containing the
  33-byte compressed public key.
  
  \item \tmverbatim{return}: a i32 integer value equal to \tmverbatim{1} if
  the signature is valid or a value equal to \tmverbatim{0} if otherwise.
\end{itemize}

\subsection{\tmverbatim{ext\_crypto\_secp256k1\_ecdsa\_recover}}

Verify and recover a \tmverbatim{secp256k1} ECDSA signature.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{sig}: a 32-bit pointer to the buffer
  containing the 65-byte signature in RSV format. V should be either
  \tmverbatim{0/1} or \tmverbatim{27/28}.
  
  \item \tmverbatim{msg}: a 32-bit pointer to the buffer containing the
  256-bit Blake2 hash of the message.
  
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the SCALE encoded
  \tmverbatim{Result} as defined in Definition \ref{defn-result-type}. On
  success it contains the 64-byte recovered public key or an error type as
  defined in Definition \ref{defn-ecdsa-verify-error} on failure.
\end{itemize}

\subsection{\tmverbatim{ext\_crypto\_secp256k1\_ecdsa\_recover\_compressed}}

Verify and recover a \tmverbatim{secp256k1} ECDSA signature.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{sig}: a 32-bit pointer to the buffer
  containing the 65-byte signature in RSV format. V should be either
  \tmverbatim{0/1} or \tmverbatim{27/28}.
  
  \item \tmverbatim{msg}: a 32-bit pointer to the buffer containing the
  256-bit Blake2 hash of the message.
  
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the SCALE encoded
  \tmverbatim{Result} as defined in Definiton \ref{defn-result-type}. On
  success it contains the 33-byte recovered public key in compressed form on
  success or an error type as defined in Definition
  \ref{defn-ecdsa-verify-error} on failure.
\end{itemize}
\subsection{\tmverbatim{ext\_crypto\_start\_batch\_verify}}\label{sect-ext-crypto-start-batch-verify}

Starts the verification extension. The extension is a separate background
process and is used to parallel-verify signatures which are pushed to the
batch with \tmverbatim{ext\_crypto\_ed25519\_verify}
(\ref{sect-ext-crypto-ed25519-verify}),
\tmverbatim{ext\_crypto\_sr25519\_verify}
(\ref{sect-ext-crypto-sr25519-verify}) or
\tmverbatim{ext\_crypto\_ecdsa\_verify} (\ref{sect-ext-crypto-ecdsa-verify}).
Verification will start immediatly and the Runtime can retrieve the result
when calling \tmverbatim{ext\_crypto\_finish\_batch\_verify}
(\ref{sect-ext-crypto-finish-batch-verify}).

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item None.
\end{itemizedot}
\subsection{\tmverbatim{ext\_crypto\_finish\_batch\_verify}}\label{sect-ext-crypto-finish-batch-verify}

Finish verifying the batch of signatures since the last call to this function.
Blocks until all the signatures are verified. Panics if the verification
extension was not registered \tmverbatim{(ext\_crypto\_start\_batch\_verify}
(\ref{sect-ext-crypto-start-batch-verify}) was not called).

\

{\tmstrong{Warning}}: Panics if no verification extension is registered
\tmverbatim{(ext\_crypto\_start\_batch\_verify}
(\ref{sect-ext-crypto-start-batch-verify}) was not called.)

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item \tmverbatim{return}: an i32 integer value equal to \tmverbatim{1} if
  all the signatures are valid or a value equal to \tmverbatim{0} if one or
  more of the signatures are invalid.
\end{itemizedot}

\section{Hashing}

Interface that provides functions for hashing with different algorithms.

\subsection{\tmverbatim{ext\_hashing\_keccak\_256}}

Conducts a 256-bit Keccak hash.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{data}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer-size} indicating the data to be hashed.
  
  \item \tmverbatim{return}: a 32-bit pointer to the buffer containing the
  256-bit hash result.
\end{itemize}

\subsection{\tmverbatim{ext\_hashing\_keccak\_512}}

Conducts a 512-bit Keccak hash.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{data}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer-size} indicating the data to be hashed.
  
  \item \tmverbatim{return}: a 32-bit pointer to the buffer containing the
  512-bit hash result.
\end{itemize}

\subsection{\tmverbatim{ext\_hashing\_sha2\_256}}

Conducts a 256-bit Sha2 hash.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{data}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer-size} indicating the data to be hashed.
  
  \item \tmverbatim{return}: a 32-bit pointer to the buffer containing the
  256-bit hash result.
\end{itemize}

\subsection{\tmverbatim{ext\_hashing\_blake2\_128}}

Conducts a 128-bit Blake2 hash.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{data}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer-size} indicating the data to be hashed.
  
  \item \tmverbatim{return}: a 32-bit pointer to the buffer containing the
  128-bit hash result.
\end{itemize}

\subsection{\tmverbatim{ext\_hashing\_blake2\_256}}

Conducts a 256-bit Blake2 hash.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{data}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer-size} indicating the data to be hashed.
  
  \item \tmverbatim{return}: a 32-bit pointer to the buffer containing the
  256-bit hash result.
\end{itemize}

\subsection{\tmverbatim{ext\_hashing\_twox\_64}}

Conducts a 64-bit xxHash hash.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{data}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer-size} indicating the data to be hashed.
  
  \item \tmverbatim{return}: a 32-bit pointer to the buffer containing the
  64-bit hash result.
\end{itemize}

\subsection{\tmverbatim{ext\_hashing\_twox\_128}}

Conducts a 128-bit xxHash hash.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{data}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer-size} indicating the data to be hashed.
  
  \item \tmverbatim{return}: a 32-bit pointer to the buffer containing the
  128-bit hash result.
\end{itemize}

\subsection{\tmverbatim{ext\_hashing\_twox\_256}}

Conducts a 256-bit xxHash hash.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{data}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer-size} indicating the data to be hashed.
  
  \item \tmverbatim{return}: a 32-bit pointer to the buffer containing the
  256-bit hash result.
\end{itemize}

\section{Trie}

Interface that provides trie related functionality.

\subsection{\tmverbatim{ext\_trie\_blake2\_256\_root}}

Compute a 256-bit Blake2 trie root formed from the iterated items.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the iterated items from which the
  trie root gets formed. The items consist of a SCALE encoded array containing
  arbitrary key/value pairs.
  
  \item \tmverbatim{result}: a 32-bit pointer to the buffer containing the
  256-bit trie root.
\end{itemize}

\subsection{\tmverbatim{ext\_trie\_blake2\_256\_ordered\_root}}

Compute a 256-bit Blake2 trie root formed from the enumerated items.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the enumerated items from which
  the trie root gets formed. The items consist of a SCALE encoded array
  containing only values, where the corresponding key of each value is the
  index of the item in the array, starting at 0. The keys are compact encoded
  integers as described in Definition \ref{defn-sc-len-encoding}.
  
  \item \tmverbatim{result}: a 32-bit pointer to the buffer containing the
  256-bit trie root result.
\end{itemize}

\subsection{\tmverbatim{ext\_trie\_keccak\_256\_root}}

Compute a 256-bit Keccak trie root formed from the iterated items.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item \tmverbatim{data}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the iterated items from which the
  trie root gets formed. The items consist of a SCALE encoded array containing
  arbitrary key/value pairs.
  
  \item result: a 32-bit pointer to the buffer containing the 256-bit trie
  root.
\end{itemizedot}

\subsection{\tmverbatim{ext\_trie\_keccak\_256\_ordered\_root}}

Compute a 256-bit Keccak trie root formed from the enumerated items.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the enumerated items from which
  the trie root gets formed. The items consist of a SCALE encoded array
  containing only values, where the corresponding key of each value is the
  index of the item in the array, starting at 0. The keys are compact encoded
  integers as described in Definition \ref{defn-sc-len-encoding}.
  
  \item \tmverbatim{result}: a 32-bit pointer to the buffer containing the
  256-bit trie root result.
\end{itemize}

\section{Miscellaneous}

Interface that provides miscellaneous functions for communicating between the
runtime and the node.

\subsection{\tmverbatim{ext\_misc\_chain\_id}}

Returns the current relay chain identifier.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{result}: the current relay chain identifier.
\end{itemize}

\subsection{\tmverbatim{ext\_misc\_print\_num}}

Print a number.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{value}: the number to be printed.
\end{itemize}

\subsection{\tmverbatim{ext\_misc\_print\_utf8}}

Print a valid \tmverbatim{UTF8} buffer.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the valid \tmverbatim{UTF8}
  buffer to be printed.
\end{itemize}

\subsection{\tmverbatim{ext\_misc\_print\_hex}}

Print any buffer in hexadecimal representation.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the buffer to be printed.
\end{itemize}

\subsection{\tmverbatim{ext\_misc\_runtime\_version}}

Extract the Runtime version of the given Wasm blob by calling
\tmverbatim{Core\_version} as defined in Definition
\ref{defn-rt-core-version}. Returns the SCALE encoded runtime version or
\tmverbatim{None} as defined in Definition \ref{defn-option-type} if the call
fails. This function gets primarily used when upgrading Runtimes.

\

{\tmstrong{Warning}}: Calling this function is very expensive and should only
be done very occasionally. For getting the runtime version, it requires
instantiating the Wasm blob as described in Section
\ref{sect-loading-runtime-code} and calling a function in this blob.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the Wasm blob.
  
  \item \tmverbatim{result}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the SCALE encoded
  \tmverbatim{Option} as defined in Definition \ref{defn-option-type}
  containing the Runtime version of the given Wasm blob.
\end{itemize}
\section{Allocator}\label{sect-ext-allocator}

The Polkadot Runtime does not include a memory allocator and relies on the
Host API for all heap allocations. The beginning of this heap is marked by the
\tmverbatim{\_\_heap\_base} symbol exported by the Polkadot Runtime. No memory
should be allocated below that address, to avoid clashes with the stack and
data section. The same allocator made accessible by this Host API should be
used for any other WASM memory allocations and deallocations outside the
runtime e.g. when passing the SCALE-encoded parameters to Runtime API calls.

\subsection{\tmverbatim{ext\_allocator\_malloc}}

Allocates the given number of bytes and returns the pointer to that memory
location.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{size}: the size of the buffer to be allocated.
  
  \item \tmverbatim{result}: a 32-bit pointer to the allocated buffer.
\end{itemize}

\subsection{\tmverbatim{ext\_allocator\_free}}

Free the given pointer.

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{ptr}: a 32-bit pointer to the memory buffer to be freed.
\end{itemize}

\section{Logging}

Interface that provides functions for logging from within the runtime.

\begin{definition}
  \label{defn-logging-log-level}{\tmstrong{Log Level}} is a varying data type
  as defined in Definition \ref{defn-varrying-data-type} and implies the
  emergency of the log. Possible levels and it's identifiers are defined in
  the following table.
  
  \begin{table}[h]
    \begin{tabular}{ll}
      {\tmstrong{Id}} & {\tmstrong{Level}} \\
      \hline
      0 & Error = 1\\
      1 & Warn = 2\\
      2 & Info = 3\\
      3 & Debug = 4\\
      4 & Trace = 5
    \end{tabular}
    \caption{Log Levels for the logging interface}
  \end{table}
\end{definition}

\subsection{\tmverbatim{ext\_logging\_log}}

Request to print a log message on the host. Note that this will be only
displayed if the host is enabled to display log messages with given level and
target.

\

\subsubsection{Version 1 - Prototype}

{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{level}: the log level as defined in Definition
  \ref{defn-logging-log-level}.
  
  \item \tmverbatim{target}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the string which contains the
  path, module or location from where the log was executed.
  
  \item \tmverbatim{message}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer-size} indicating the log message.
\end{itemize}


\begin{flushright}
  {\qed}
\end{flushright}

\

\chapter{Polkadot Runtime API}\label{sect-runtime-entries}

\section{General Information}

The Polkadot Host assumes that at least the constants and functions described
in this Chapter are implemented in the Runtime Wasm blob.

It should be noted that the API can change through the Runtime updates.
Therefore, a host should check the API versions of each module returned in the
\tmverbatim{api} field by \tmverbatim{Core\_version} (Section
\ref{defn-rt-core-version}) after every Runtime upgrade and warn if an updated
API is encountered and that this might require an update of the host.

\subsection{JSON-RPC API for external services}\label{sect-json-rpc-api}

Polkadot Host implementers are encouraged to implement an API in order for
external, third-party services to interact with the node. The
\href{https://github.com/w3f/PSPs/blob/master/PSPs/drafts/psp-6.md}{JSON-RPC
Interface for Polkadot Nodes} (PSP Number 006) is a Polkadot Standard Proposal
for such an API and makes it easier to integrate the node with existing tools
available in the Polkadot ecosystem, such as
\href{https://polkadot.js.org/}{polkadot.js.org}. The Runtime API has a few
modules designed specifically for use in the official RPC API.

\section{Runtime Constants}

\subsection{\tmverbatim{\_\_heap\_base}}

This constant indicates the beginning of the heap in memory. The space below
is reserved for the stack and the data section. For more details please refer
to Section \ref{sect-ext-allocator}.

\section{Runtime Functions}

In this section, we describe all Runtime API functions alongside their
arguments and the return values. The functions are organized into modules with
each being versioned independently.

\begin{definition}
  \label{defn-runtime-api-convention}The \tmtextbf{Runtime API Call
  Convention} describes that all functions receive and return SCALE-encoded
  data and as a result have the following prototype signature:
  
  
  where \tmverbatim{ptr} points to the SCALE encoded tuple of the parameters
  passed to the function and \tmverbatim{len} is the length of this data,
  while \tmverbatim{result} is a pointer-size (Definition
  \ref{defn-runtime-pointer-size}) to the SCALE-encoded return data.
\end{definition}

See Section \ref{sect-code-executor} for more information about the behaviour
of the Wasm Runtime. Do note that any state changes created by calling any of
the Runtime functions are not necessarily to be persisted after the call is
ended. See Section \ref{sect-handling-runtime-state-update} for more
information.

\subsection{Core Module (Version 3)}\label{sect-runtime-core-module}

\subsubsection{\tmverbatim{Core\_version}}\label{defn-rt-core-version}

Returns the version identifiers of the Runtime. This function can be used by
the Polkadot Host implementation when it seems appropriate, such as for the
JSON-RPC API as described in Section \ref{sect-json-rpc-api}.

\

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item None
\end{itemizedot}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item A datastructure of the following format:
  
  \
  
  \begin{table}[h]
    \begin{tabular}{lll}
      \hline
      Name & Type & Description\\
      \hline
      \tmverbatim{spec\_name} & String & Runtime identifier\\
      \tmverbatim{impl\_name} & String & the name of the implementation (e.g.
      C++)\\
      \tmverbatim{authoring\_version} & UINT32 & the version of the authorship
      interface\\
      \tmverbatim{spec\_version} & UINT32 & the version of the Runtime
      specification\\
      \tmverbatim{impl\_version} & UINT32 & the v\tmverbatim{}ersion of the
      Runtime implementation\\
      \tmverbatim{apis} & ApisVec (\ref{defn-rt-apisvec}) & List of supported
      APIs along with their version\\
      \tmverbatim{transaction\_version} & UINT32 & the version of the
      transaction format\\
      \hline
    \end{tabular}
    \caption{Details of the version that the data type returns from the
    Runtime \tmverbatim{version} function.}
  \end{table}
  
  \begin{definition}
    \label{defn-rt-apisvec}{\tmstrong{ApisVec}} is a specialized type for the
    \tmverbatim{Core\_version} (\ref{defn-rt-core-version}) function entry. It
    represents an array of tuples, where the first value of the tuple is an
    array of 8-bytes containing the Blake2b hash of the API name. The second
    value of the tuple is the version number of the corresponding API.
    \begin{eqnarray*}
      \tmop{ApiVec} & \assign & (T_0, \ldots, T_n)\\
      T & \assign & ((b_0, \ldots, b_7), \tmop{UINT} 32)
    \end{eqnarray*}
  \end{definition}
\end{itemizedot}
Requires \tmverbatim{Core\_intialize\_block} to be called beforehand.

\subsubsection{\tmverbatim{Core\_execute\_block}}\label{sect-rte-core-execute-block}

This function executes a full block and all its extrinsics and updates the
state accordingly. Additionally, some integrity checks are executed such as
validating if the parent hash is correct and that the transaction root
represents the transactions. Internally, this function performs an operation
similar to the process described in Algorithm \ref{algo-build-block}, by
calling \tmverbatim{Core\_initialize\_block},
\tmverbatim{BlockBuilder\_apply\_extrinsics} and
\tmverbatim{BlockBuilder\_finalize\_block}.

\

This function should be called when a fully complete block is available that
is not actively being built on, such as blocks received from other peers.
State changes resulted from calling this function are usually meant to persist
when the block is imported successfully.

\

Additionally, the seal digest in the block header, as described in Section
\ref{defn-digest}, must be removed by the Polkadot host before submitting the
block.

\

{\tmstrong{Arguments}}:
\begin{itemize}
  \item A block represented as a tuple consisting of a block header, as
  described in Section \ref{defn-block-header}, and the block body, as
  described in Section \ref{defn-block-body}.
\end{itemize}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item None.
\end{itemizedot}
\subsubsection{\tmverbatim{Core\_initialize\_block}}\label{sect-rte-core-initialize-block}

Sets up the environment required for building a new block as described in
Algorithm \ref{algo-build-block}.

\

{\tmstrong{Arguments}}:
\begin{itemize}
  \item The header of the new block as defined in \ref{defn-block-header}. The
  values $H_r, H_e \tmop{and} H_d$ are left empty.
\end{itemize}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item None.
\end{itemizedot}
\subsection{Metadata Module (Version 1)}\label{sect-runtime-metadata-module}

\subsubsection{\tmverbatim{Metadata\_metadata}}

Returns native Runtime metadata in an opaque form. This function can be used
by the Polkadot Host implementation when it seems appropriate, such as for the
JSON-RPC API as described in Section \ref{sect-json-rpc-api}. and returns all
the information necessary to build valid transactions.

\

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item None.
\end{itemizedot}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item A byte array of varying size containing the metadata in an opaque
  form.
\end{itemizedot}
\subsection{BlockBuilder Module (Version
4)}\label{sect-runtime-blockbuilder-module}

All calls in this module require \tmverbatim{Core\_intialize\_block} (Section
\ref{sect-rte-core-initialize-block}) to be called beforehand.

\subsubsection{\tmverbatim{BlockBuilder\_apply\_extrinsic}}
\label{sect-rte-apply-extrinsic}

Apply the extrinsic outside of the block execution function. This does not
attempt to validate anything regarding the block, but it builds a list of
transaction hashes.

\

{\tmstrong{Arguments}}:
\begin{itemize}
  \item A byte array of varying size containing the opaque extrinsic.
\end{itemize}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item Returns the varying datatype \tmverbatim{ApplyExtrinsicResult} as
  defined in Definition \ref{defn-rte-apply-extrinsic-result}. This structure
  lets the block builder know whether an extrinsic should be included into the
  block or rejected.
  
  \ 
\end{itemizedot}
\begin{definition}
  \label{defn-rte-apply-extrinsic-result}\tmverbatim{ApplyExtrinsicResult} is
  the varying data type \tmverbatim{Result} as defined in Definition
  \ref{defn-result-type}. This structure can contain multiple nested
  structures, indicating either module dispatch outcomes or transaction
  invalidity errors.
  
  \begin{table}[h]
    \begin{tabular}{lll}
      {\tmstrong{Id}} & {\tmstrong{Description}} & {\tmstrong{Type}}\\
      \hline
      0 & Outcome of dispatching the extrinsic. & DispatchOutcome
      (\ref{defn-rte-dispatch-outcome})\\
      \hline
      1 & Possible errors while checking the & TransactionValidityError
      (\ref{defn-rte-transaction-validity-error})\\
      & validity of a transaction. & \\
      \hline
    \end{tabular}
    \caption{Possible values of varying data type
    {\tmstrong{ApplyExtrinsicResult}}.}
  \end{table}
\end{definition}

\begin{note}
  As long as a \tmverbatim{DispatchOutcome} (\ref{defn-rte-dispatch-outcome})
  is returned, the extrinsic is always included in the block, even if the
  outcome is a dispatch error. Dispatch errors do not invalidate the block and
  all state changes are persisted.
\end{note}

\begin{definition}
  \label{defn-rte-dispatch-outcome}{\tmstrong{DispatchOutcome}} is the varying
  data type \tmverbatim{Result} as defined in Definition
  \ref{defn-result-type}.
  
  \begin{table}[h]
    \begin{tabular}{lll}
      {\tmstrong{Id}} & {\tmstrong{Description}} & {\tmstrong{Type}}\\
      \hline
      0 & Extrinsic is valid and was submitted successfully. & None\\
      \hline
      1 & Possible errors while dispatching the extrinsic. & DispatchError
      (\ref{defn-rte-dispatch-error})\\
      \hline
    \end{tabular}
    \caption{Possible values of varying data type
    {\tmstrong{DispatchOutcome}}.}
  \end{table}
\end{definition}

\begin{definition}
  \label{defn-rte-dispatch-error}{\tmstrong{DispatchError}} is a varying data
  type as defined in Definition \ref{defn-varrying-data-type}. Indicates
  various reasons why a dispatch call failed.
  
  \begin{table}[h]
    \begin{tabular}{lll}
      {\tmstrong{Id}} & {\tmstrong{Description}} & {\tmstrong{Type}}\\
      \hline
      0 & Some unknown error occurred. & SCALE encoded byte array contain-\\
      &  & ing a valid UTF-8 sequence.\\
      \hline
      1 & Failed to lookup some data. & None\\
      \hline
      2 & A bad origin. & None\\
      \hline
      3 & A custom error in a module. & CustomModuleError
      (\ref{defn-rte-custom-module-error})\\
      \hline
    \end{tabular}
    \caption{Possible values of varying data type {\tmstrong{DispatchError}}.}
  \end{table}
\end{definition}

\begin{definition}
  \label{defn-rte-custom-module-error}{\tmstrong{CustomModuleError}} is a
  tuple appended after a possible error in \tmverbatim{DispatchError} as
  defined in Defintion \ref{defn-rte-dispatch-error}.
  
  \begin{table}[h]
    \begin{tabular}{lll}
      {\tmstrong{Name}} & {\tmstrong{Description}} & {\tmstrong{Type}}\\
      \hline
      Index & Module index matching the & Unsigned 8-bit integer.\\
      & metadata module index. & \\
      \hline
      Error & Module specific error value. & Unsigned 8-bit integer\\
      &  & \\
      \hline
      Message & Optional error message. & Varying data type
      {\tmstrong{Option}} (\ref{defn-option-type}).\\
      &  & The optional value is a SCALE\\
      &  & encoded byte array containing a\\
      &  & valid UTF-8 sequence.\\
      \hline
    \end{tabular}
    \caption{Possible values of varying data type
    {\tmstrong{CustomModuleError}}.}
  \end{table}
\end{definition}

\begin{note}
  Whenever \tmverbatim{TransactionValidityError}
  (\ref{defn-rte-transaction-validity-error}) is returned, the contained error
  type will indicate whether an extrinsic should be outright rejected or
  requested for a later block. This behaviour is clarified further in
  Definition \ref{defn-rte-invalid-transaction} respectively Definition
  \ref{defn-rte-unknown-transaction}.
\end{note}

\begin{definition}
  \label{defn-rte-transaction-validity-error}{\tmstrong{TransactionValidityError}}
  is a varying data type as defined in Definition
  \ref{defn-varrying-data-type}. It indicates possible errors that can occur
  while checking the validity of a transaction.
  
  \begin{table}[h]
    \begin{tabular}{lll}
      {\tmstrong{Id}} & {\tmstrong{Description}} & {\tmstrong{Type}}\\
      \hline
      0 & Transaction is invalid. & InvalidTransaction
      (\ref{defn-rte-invalid-transaction})\\
      \hline
      1 & Transaction validity can't be determined. & UnknownTransaction
      (\ref{defn-rte-unknown-transaction})\\
      \hline
    \end{tabular}
    \caption{Possible values of varying data type
    {\tmstrong{TransactionValidityError}}.}
  \end{table}
\end{definition}

\begin{definition}
  \label{defn-rte-invalid-transaction}{\tmstrong{InvalidTransaction}} is a
  varying data type as defined in Definition \ref{defn-varrying-data-type} and
  specifies the invalidity of the transaction in more detail.
  
  \begin{table}[h]
    \begin{tabular}{llll}
      {\tmstrong{Id}} & {\tmstrong{Description}} & {\tmstrong{Type}} &
      {\tmstrong{Reject}}\\
      \hline
      0 & Call of the transaction is not expected. & None & Yes\\
      \hline
      1 & General error to do with the inability to pay & None & Yes\\
      & some fees (e.g. account balance too low). &  & \\
      \hline
      2 & General error to do with the transaction & None & No\\
      & not yet being valid (e.g. nonce too high). &  & \\
      \hline
      3 & General error to do with the transaction being & None & Yes\\
      & outdated (e.g. nonce too low). &  & \\
      \hline
      4 & General error to do with the transactions' & None & Yes\\
      & proof (e.g. signature) &  & \\
      \hline
      5 & The transaction birth block is ancient. & None & Yes\\
      \hline
      6 & The transaction would exhaust the resources & None & No\\
      & of the current block. &  & \\
      \hline
      7 & Some unknown error occured. & Unsigned & Yes\\
      &  & 8-bit integer & \\
      \hline
      8 & An extrinsic with mandatory dispatch resulted & None & Yes\\
      & in an error. &  & \\
      \hline
      9 & A transaction with a mandatory dispatch (only in- & None & Yes\\
      & herents are allowed to have mandatory dispatch). &  & \\
      \hline
    \end{tabular}
    \caption{Possible values of varying data type
    {\tmstrong{InvalidTransaction}}.}
  \end{table}
\end{definition}

\begin{definition}
  \label{defn-rte-unknown-transaction}{\tmstrong{UnknownTransaction}} is a
  varying data type as defined in Definition \ref{defn-varrying-data-type} and
  specifies the unknown invalidity of the transaction in more detail.
  
  \begin{table}[h]
    \begin{tabular}{llll}
      {\tmstrong{Id}} & {\tmstrong{Description}} & {\tmstrong{Type}} &
      {\tmstrong{Reject}}\\
      \hline
      0 & Could not lookup some information that is required to & None & Yes\\
      & validate the transaction. &  & \\
      \hline
      1 & No validator found for the given unsigned transaction. & None &
      Yes\\
      \hline
      2 & Any other custom unknown validity that is not covered & Unsigned &
      Yes\\
      & by this type. & 8-bit integer & \\
      \hline
    \end{tabular}
    \caption{Possible values of varying data type
    {\tmstrong{UnknownTransaction}}.}
  \end{table}
\end{definition}

\subsubsection{\tmverbatim{BlockBuilder\_finalize\_block}}\label{defn-rt-blockbuilder-finalize-block}

Finalize the block - it is up to the caller to ensure that all header fields
are valid except for the state root. State changes resulting from calling this
function are usually meant to persist upon successful execution of the
function and appending of the block to the chain.

\

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item None.
\end{itemizedot}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item The header of the new block as defined in \ref{defn-block-header}.
\end{itemizedot}
\subsubsection{\tmverbatim{BlockBuilder\_inherent\_extrinsics}}\label{defn-rt-builder-inherent-extrinsics}

Generates the inherent extrinsics, which are explained in more detail in
Section \ref{sect-inherents}. This function takes a SCALE-encoded hash table
as defined in Section \ref{defn-scale-list} and returns an array of
extrinsics. The Polkadot Host must submit each of those to the
\tmverbatim{BlockBuilder\_apply\_extrinsic}, described in Section
\ref{sect-rte-apply-extrinsic}. This procedure is outlined in Algorithm
\ref{algo-build-block}.

\

{\tmstrong{Arguments}}:
\begin{itemize}
  \item A {\tmname{Inherents-Data}} structure as defined in
  \ref{defn-inherent-data}.
\end{itemize}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item A byte array of varying size containing extrinisics. Each extrinsic is
  a byte array of varying size.
\end{itemizedot}

\subsubsection{\tmverbatim{BlockBuilder\_check\_inherents}}

Checks whether the provided inherent is valid. This function can be used by
the Polkadot Host when deemed appropriate, e.g. during the block-building
process.

\

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item A block represented as a tuple consisting of a block header as
  described in Section \ref{defn-block-header} and the block body as described
  in Section \ref{defn-block-body}.
  
  \item A {\tmname{Inherents-Data}} structure as defined in
  \ref{defn-inherent-data}.
\end{itemizedot}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item A datastructure of the following format:
  \[ (o, f_e, e) \]
  where
  \begin{itemizedot}
    \item $o$ is a boolean indicating whether the check was successful.
    
    \item $f_e$ is a boolean indicating whether a fatal error was encountered.
    
    \item $e$ is a {\tmname{Inherents-Data}} structure as defined in
    \ref{defn-inherent-data} containing any errors created by this Runtime
    function.
  \end{itemizedot}
\end{itemizedot}
\subsection{TaggedTransactionQueue (Version
2)}\label{sect-runtime-txqueue-module}

All calls in this module require \tmverbatim{Core\_intialize\_block} (Section
\ref{sect-rte-core-initialize-block}) to be called beforehand.

\subsubsection{\tmverbatim{TaggedTransactionQueue\_validate\_transaction}}\label{sect-rte-validate-transaction}

This entry is invoked against extrinsics submitted through a transaction
network message \ref{sect-msg-transactions} or by an offchain worker through
the \tmverbatim{ext\_offchain\_submit\_transaction} Host API (Section
\ref{sect-ext-offchain-submit-transaction}). It indicates if the submitted
blob represents a valid extrinsics, the order in which it should be applied
and if it should be gossiped to other peers. Furthermore this function gets
called internally when executing blocks with the
\tmverbatim{Core\_execute\_block} runtime function as described in Section
\ref{sect-rte-core-execute-block}.

\

{\tmstrong{Arguments}}:
\begin{itemize}
  \item The source of the transaction as defined in Definition
  \ref{defn-transaction-source}.
  
  \item A byte array that contains the transaction.
  
  \ 
\end{itemize}
\begin{definition}
  \label{defn-transaction-source}\tmtextbf{TransactionSource} is an enum
  describing the source of a transaction and can have one of the following
  values:
  
  \begin{table}[h]
    \begin{tabular}{lll}
      Id & Name & Description\\
      \hline
      0 & \tmtextit{InBlock} & Transaction is already included in a block.\\
      \hline
      1 & \tmtextit{Loc\tmtextup{}al} & Transaction is coming from a local
      source, e.g. off-chain worker.\\
      \hline
      2 & \tmtextit{External{\underline{}}} & Transaction has been received
      externally, e.g. over the network.\\
      \hline
    \end{tabular}
    \caption{The \tmverbatim{TransactionSource} enum }
  \end{table}
\end{definition}

{\tmstrong{Return}}: This function returns a \tmverbatim{Result} as defined in
Definition \ref{defn-result-type} which contains the type
{\tmem{\tmverbatim{ValidTransaction}}} as defined in Definition
\ref{defn-valid-transaction} on success and the type
{\tmem{\tmverbatim{TransactionValidityError}}} as defined in Definition
\ref{defn-rte-transaction-validity-error} on failure.

\begin{definition}
  \label{defn-valid-transaction}{\tmstrong{ValidTransaction}} is a tuple that
  contains information concerning a valid transaction.
  
  \
  
  \begin{table}[h]
    \begin{tabular}{lll}
      {\tmstrong{Name}} & {\tmstrong{Description}} & {\tmstrong{Type}}\\
      \hline
      Priority & Determines the ordering of two transactions that have &
      Unsigned 64bit\\
      & all their dependencies (required tags) are satisfied. & integer\\
      \hline
      Requires & List of tags specifying extrinsics which should be applied  &
      Array containing\\
      & before the current exrinsics can be applied. & inner arrays\\
      \hline
      Provides & Informs Runtime of the extrinsics depending on the tags in &
      Array containing\\
      & the list that can be applied after current extrinsics are being
      applied. & inner arrays\\
      & Describes the minimum number of blocks for the validity to be correct
      & \\
      \hline
      Longevity & After this period, the transaction should be removed from
      the  & Unsigned 64bit\\
      & pool or revalidated. & integer\\
      \hline
      Propagate & A flag indicating if the transaction should be gossiped to 
      & Boolean\\
      & other peers. & 
    \end{tabular}
    \caption{The tuple provided by
    \tmverbatim{TaggedTransactionQueue\_transaction\_validity}
    in the case the transaction is judged to be valid.}
  \end{table}
\end{definition}

{\tmstrong{Note}}: If {\tmem{Propagate}} is set to \tmverbatim{false} the
transaction will still be considered for inclusion in blocks that are authored
on the current node, but should not be gossiped to other peers.

\

{\tmstrong{Note}}: If this function gets called by the Polkadot Host in order
to validate a transaction received from peers, the Polkadot Host disregards
and rewinds state changes resulting in such a call.

\subsection{OffchainWorkerApi Module (Version
2)}\label{sect-runtime-offchainapi-module}

Does not require \tmverbatim{Core\_intialize\_block} (Section
\ref{sect-rte-core-initialize-block}) to be called beforehand.

\subsubsection{\tmverbatim{OffchainWorkerApi\_offchain\_worker}}

Starts an off-chain worker and generates extrinsics. {\todo{when is this
called?}}

\

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item The block header as defined in \ref{defn-block-header}.
\end{itemizedot}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item None.
\end{itemizedot}

\subsection{ParachainHost Module (Version 1)}

\subsubsection{\tmverbatim{ParachainHost\_validators}}

{\todo{future-reserved}}

\subsubsection{\tmverbatim{ParachainHost\_validator\_groups}}

{\todo{future-reserved}}

\subsubsection{\tmverbatim{ParachainHost\_availability\_cores}}

{\todo{future-reserved}}

\subsubsection{\tmverbatim{ParachainHost\_persisted\_validation\_data}}

{\todo{future-reserved}}

\subsubsection{\tmverbatim{ParachainHost\_check\_validation\_outputs}}

{\todo{future-reserved}}

\subsubsection{\tmverbatim{ParachainHost\_session\_index\_for\_child}}

{\todo{future-reserved}}

\subsubsection{\tmverbatim{ParachainHost\_session\_info}}

{\todo{future-reserved}}

\subsubsection{\tmverbatim{ParachainHost\_validation\_code}}

{\todo{future-reserved}}

\subsubsection{\tmverbatim{ParachainHost\_historical\_validation\_code}}

{\todo{future-reserved}}

\subsubsection{\tmverbatim{ParachainHost\_candidate\_pending\_availability}}

{\todo{future-reserved}}

\subsubsection{\tmverbatim{ParachainHost\_candidate\_events}}

{\todo{future-reserved}}

\subsubsection{\tmverbatim{ParachainHost\_dmq\_contents}}

{\todo{future-reserved}}

\subsubsection{\tmverbatim{ParachainHost\_inbound\_hrmp\_channel\_contents}}

{\todo{future-reserved}}

\subsection{GrandpaApi Module (Version 2)}

All calls in this module require \tmverbatim{Core\_intialize\_block} (Section
\ref{sect-rte-core-initialize-block}) to be called beforehand.

\subsubsection{\tmverbatim{GrandpaApi\_grandpa\_authorities}}\label{sect-rte-grandpa-auth}

This entry fetches the list of GRANDPA authorities according to the genesis
block and is used to initialize an authority list at genesis, defined in
Definition \ref{defn-authority-list}. Any future authority changes get tracked
via Runtime-to-consensus engine messages, as described in Section
\ref{sect-consensus-message-digest}.

\

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item None.
\end{itemizedot}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item An authority list as defined in Definition \ref{defn-authority-list}.
\end{itemizedot}
\subsubsection{\tmverbatim{GrandpaApi\_submit\_report\_equivocation\_unsigned\_extrinsic}}\label{sect-grandpaapi_submit_report_equivocation_unsigned_extrinsic}

A GRANDPA equivocation occurs when a validator votes for multiple blocks
during one voting subround, as described further in Section
\ref{defn-equivocation}. The Polkadot Host is expected to identify
equivocators and report those to the Runtime by calling this function.

\

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item The equivocation proof of the following format:
  \begin{eqnarray*}
    G_{\tmop{Ep}} & = & (\tmop{id}_{\mathbb{V}}, e, r, A_{\tmop{id}}, B^1_h,
    B^1_n A^1_{\tmop{sig}}, B^2_h, B^2_n, A^2_{\tmop{sig}})\\
    e & = & \left\{\begin{array}{l}
      0 \quad \text{{\tmem{Equivocation at prevote stage.}}}\\
      \text{1\quad{\tmem{Equivocation at precommit stage}}}
    \end{array}\right.
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $\tmop{id}_{\mathbb{V}}$ is the authority set as defined in Section
    \ref{defn-authority-set-id}.
    
    \item $e$ indicates the stage at which the equivocation occurred.
    
    \item $r$ is the round number the equivocation occurred.
    
    \item $A_{\tmop{id}}$ is the public key of the equivocator.
    
    \item $B^1_h$ is the block hash of the first block the equivocator voted
    for.
    
    \item $B^1_n$ is the block number of the first block the equivocator voted
    for.
    
    \item $A^1_{\tmop{sig}}$ is the equivocators signature of the first vote.
    
    \item $B^2_h$ is the block hash of the second block the equivocator voted
    for.
    
    \item $B^2_n$ is the block number of the second block the equivocator
    voted for.
    
    \item $A^2_{\tmop{sig}}$ is the equivocators signature of the second vote.
  \end{itemizedot}
  \item A proof of the key owner in an opaque form as described in Section
  \ref{sect-grandpaapi_generate_key_ownership_proof}.
\end{itemizedot}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item A SCALE encoded \tmverbatim{Option} as defined in Definition
  \ref{defn-option-type} containing an empty value on success.
\end{itemizedot}
\subsubsection{\tmverbatim{GrandpaApi\_generate\_key\_ownership\_proof}}\label{sect-grandpaapi_generate_key_ownership_proof}

Generates proof of the membership of a key owner in the specified block state.
The returned value is used to report equivocations as described in Section
\ref{sect-grandpaapi_submit_report_equivocation_unsigned_extrinsic}.

\

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item The authority set Id as defined in Definition
  \ref{defn-authority-set-id}.
  
  \item The 256-bit public key of the authority.
\end{itemizedot}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item A SCALE encoded \tmverbatim{Option} as defined in Definition
  \ref{defn-option-type} containing the proof in an opaque form.
\end{itemizedot}

\subsection{BabeApi Module (Version 2)}

All calls in this module require \tmverbatim{Core\_intialize\_block} (Section
\ref{sect-rte-core-initialize-block}) to be called beforehand.

\subsubsection{\tmverbatim{BabeApi\_configuration}}\label{sect-rte-babeapi-epoch}

This entry is called to obtain the current configuration of the BABE consensus
protocol.

\

{\tmstrong{Arguments}}:
\begin{itemize}
  \item None.
\end{itemize}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item A tuple containing configuration data used by the Babe consensus
  engine.
\end{itemizedot}
\begin{table}[h]
  \begin{tabular}{lll}
    \hline
    {\tmstrong{Name}} & {\tmstrong{Description}} & {\tmstrong{Type}}\\
    \hline
    SlotDuration & The slot duration in milliseconds. Currently, only the
    value provided & Unsigned 64bit\\
    & by this type at genesis will be used. Dynamic slot duration may be &
    integer\\
    & supported in the future. & \\
    \hline
    EpochLength & The duration of epochs in slots. & Unsigned 64bit\\
    &  & integer\\
    \hline
    Constant & A constant value that is used in the threshold calculation
    formula & Tuple containing\\
    & as defined in definition \ref{defn-babe-constant}. & two unsigned\\
    &  & 64bit integers\\
    &  & \\
    \hline
    Genesis & The authority list for the genesis epoch as defined in
    Definition \ref{defn-authority-list}.  & Array of tuples\\
    Authorities &  & containing a 256-bit\\
    &  & byte array and a\\
    &  & unsigned 64bit\\
    &  & integer\\
    \hline
    Randomness & The randomness for the genesis epoch & 32-byte array\\
    \hline
    SecondarySlot & Whether this chain should run with secondary slots and
    wether & 8bit enum\\
    & they are assigned in a round-robin manner or via a second VRF. & \\
    \hline
  \end{tabular}
  \caption{The tuple provided by {\tmstrong{BabeApi\_configuration}}.}
\end{table}

\subsubsection{\tmverbatim{BabeApi\_current\_epoch\_start}}

Finds the start slot of the current epoch.

\

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item None.
\end{itemizedot}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item A unsigned 64-bit integer indicating the slot number.
\end{itemizedot}
\subsubsection{\tmverbatim{BabeApi\_current\_epoch}}\label{sect-babeapi_current_epoch}

Produces information about the current epoch.

\

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item None.
\end{itemizedot}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item A datastructure of the following format:
  \[ (e_i, s_s, d, A, r) \]
  where:
  \begin{itemizedot}
    \item $e_i$ is a unsigned 64-bit integer representing the epoch index.
    
    \item $s_s$ is a unsigned 64-bit integer representing the starting slot of
    the epoch.
    
    \item $d$ is a unsigned 64-bit integer representing the duration of the
    epoch.
    
    \item $A$ is an authority list as defined in Definition
    \ref{defn-authority-list}.
    
    \item $r$ is an 256-bit array containing the randomness for the epoch as
    defined in Definition \ref{defn-epoch-randomness}.
  \end{itemizedot}
\end{itemizedot}

\subsubsection{\tmverbatim{BabeApi\_next\_epoch}}

Produces information about the next epoch.

\

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item None.
\end{itemizedot}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item Returns the same datastructure as described in Section
  \ref{sect-babeapi_current_epoch}.
\end{itemizedot}
\subsubsection{\tmverbatim{BabeApi\_generate\_key\_ownership\_proof}}\label{sect-babeapi_generate_key_ownership_proof}

Generates a proof of the membership of a key owner in the specified block
state. The returned value is used to report equivocations as described in
Section \ref{sect-babeapi_submit_report_equivocation_unsigned_extrinsic}.

\

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item The unsigned 64-bit integer indicating the slot number.
  
  \item The 256-bit public key of the authority.
\end{itemizedot}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item A SCALE encoded \tmverbatim{Option} as defined in Definition
  \ref{defn-option-type} containing the proof in an opaque form.
\end{itemizedot}
\subsubsection{\tmverbatim{BabeApi\_submit\_report\_equivocation\_unsigned\_extrinsic}}\label{sect-babeapi_submit_report_equivocation_unsigned_extrinsic}

A BABE equivocation occurs when a validator produces more than one block at
the same slot. The proof of equivocation are the given distinct headers that
were signed by the validator and which include the slot number. The Polkadot
Host is expected to identify equivocators and report those to the Runtime
using this function.

\begin{note}
  If there are more than two blocks which cause an equivocation, the
  equivocation only needs to be reported once i.e. no additional equivocations
  must be reported for the same slot. 
\end{note}

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item The equivocation proof of the following format:
  \begin{eqnarray*}
    B_{\tmop{Ep}} & = & (A_{\tmop{id}}, s, h_1, h_2)
  \end{eqnarray*}
  where
  \begin{itemizedot}
    \item $A_{\tmop{id}}$ is the public key of the equivocator.
    
    \item $s$ is the slot as described in Section \ref{sect-babe} at which the
    equivocation occurred.
    
    \item $h_1$ is the block header of the first block produced by the
    equivocator.
    
    \item $h_2$ is the block header of the second block produced by the
    equivocator.
  \end{itemizedot}
  Unlike during block execution, the Seal in both block headers is not removed
  before submission. The block headers are submitted in its full form.
  
  \item An proof of the key owner in an opaque form as described in Section
  \ref{sect-babeapi_generate_key_ownership_proof}.
\end{itemizedot}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item A SCALE encoded \tmverbatim{Option} as defined in Definition
  \ref{defn-option-type} containing an empty value on success.
\end{itemizedot}

\subsection{AuthorityDiscoveryApi Module (Version 1)}

All calls in this module require \tmverbatim{Core\_intialize\_block} (Section
\ref{sect-rte-core-initialize-block}) to be called beforehand.

\subsubsection{\tmverbatim{AuthorityDiscoveryApi\_authorities}}

A function which helps to discover authorities.

\

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item None.
\end{itemizedot}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item A byte array of varying size containing 256-bit pulic keys of the
  authorities.
\end{itemizedot}
\subsection{SessionKeys Module (Version
1)}\label{sect-runtime-sessionkeys-module}

All calls in this module require \tmverbatim{Core\_intialize\_block} (Section
\ref{sect-rte-core-initialize-block}) to be called beforehand.

\subsubsection{\tmverbatim{SessionKeys\_generate\_session\_keys}}

Generates a set of session keys with an optional seed. The keys should be
stored within the keystore exposed by the Host Api. The seed needs to be valid
and UTF-8 encoded.

\

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item A SCALE-encoded \tmverbatim{Option} as defined in Definition
  \ref{defn-option-type} containing an array of varying sizes indicating the
  seed.
\end{itemizedot}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item A byte array of varying size containg the encoded session keys.
\end{itemizedot}

\subsubsection{\tmverbatim{SessionKeys\_decode\_session\_keys}}

Decodes the given public session keys. Returns a list of raw public keys
including their key type.

\

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item An array of varying size containing the encoded public session keys.
\end{itemizedot}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item An array of varying size containing tuple pairs of the following
  format:
  \[ (k, k_{\tmop{id}}) \]
  where $k$ is an array of varying sizes containg the raw public key and
  $k_{\tmop{id}}$ is a 4-byte array indicating the key type.
\end{itemizedot}

\subsection{AccountNonceApi Module (Version 1)}

All calls in this module require \tmverbatim{Core\_intialize\_block} (Section
\ref{sect-rte-core-initialize-block}) to be called beforehand.

\subsubsection{\tmverbatim{AccountNonceApi\_account\_nonce}}\label{sect-accountnonceapi-account-nonce}

Get the current nonce of an account. This function can be used by the Polkadot
Host implementation when it seems appropriate, such as for the JSON-RPC API as
described in Section \ref{sect-json-rpc-api}.

\

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item The 256-bit public key of the account.
\end{itemizedot}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item A 32-bit unsigned integer indicating the nonce of the account.
\end{itemizedot}

\subsection{TransactionPaymentApi Module (Version 1)}

All calls in this module require \tmverbatim{Core\_intialize\_block} (Section
\ref{sect-rte-core-initialize-block}) to be called beforehand.

\subsubsection{\tmverbatim{TransactionPaymentApi\_query\_info}}

Returns information of a given extrinsic. This function is not aware of the
internals of an extrinsic, but only interprets the extrinsic as some encoded
value and accounts for its weight and length, the Runtime's extrinsic base
weight and the current fee multiplier.

\

This function can be used by the Polkadot Host implementation when it seems
appropriate, such as for the JSON-RPC API as described in Section
\ref{sect-json-rpc-api}.

\

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item A byte array of varying sizes containing the extrinsic.
  
  \item The length of the extrinsic. {\todo{why is this needed?}}
\end{itemizedot}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item A data structure of the following format:
  \[ (w, c, f) \]
  where:
  \begin{itemizedot}
    \item $w$ is the weight of the extrinsic.
    
    \item $c$ is the ``class'' of the extrinsic, where class is a varying data
    type defined as:
    \[ c = \left\{\begin{array}{l}
         0 \quad \tmop{Normal} \tmop{extrinsic}\\
         1 \quad \tmop{Operational} \tmop{extrinsic}\\
         2 \quad \tmop{Mandatory} \tmop{extrinsic}, \tmop{which} \tmop{is}
         \tmop{always} \tmop{included}
       \end{array}\right. \]
    \item $f$ is the inclusion fee of the extrinsic. This does not include a
    tip or anything else that depends on the signature.
  \end{itemizedot}
\end{itemizedot}

\subsubsection{\tmverbatim{TransactionPaymentApi\_query\_fee\_details}}

Query the detailed fee of a given extrinsic. This function can be used by the
Polkadot Host implementation when it seems appropriate, such as for the
JSON-RPC API as described in Section \ref{sect-json-rpc-api}.

\

{\tmstrong{Arguments}}:
\begin{itemizedot}
  \item A byte array of varying sizes containing the extrinsic.
  
  \item The length of the extrinsic.
\end{itemizedot}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item A data structure of the following format:
  \[ (f, t) \]
  where
  \begin{itemizedot}
    \item $f$ is a SCALE encoded \tmverbatim{Option} as defined in Definition
    \ref{defn-option-type} containing the following datastructure:
    \[ (f_b, f_l, f_a) \]
    where
    \begin{itemizedot}
      \item $f_b$ is the minimum required fee for an extrinsic.
      
      \item $f_l$ is the length fee, the amount paid for the encoded length
      (in bytes) of the extrinsic.
      
      \item $f_a$ is the ``adjusted weight fee'', which is a multiplication of
      the fee multiplier and the weight fee. The fee multiplier varies
      depending on the usage of the network.
    \end{itemizedot}
    \item $t$ is the tip for the block author.
  \end{itemizedot}
\end{itemizedot}


\begin{flushright}
  {\qed}
\end{flushright}

\

\

\chapter*{Glossary}

\begin{theglossary}{gly}
  
\end{theglossary}

\

\begin{thebibliography}{}
  
\end{thebibliography}

\

\printindex

\end{document}
