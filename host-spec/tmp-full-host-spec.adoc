= Polkadot Specification
:description: Polkadot Specification
:doctype: book
:toc: left
:stem:
:sectnums: all
:xrefstyle: full

== Background

=== Introduction

Formally, Polkadot is a replicated sharded state machine designed to
resolve the scalability and interoperability among blockchains. In
Polkadot vocabulary, shards are called _parachains_ and Polkadot _relay
chain_ is part of the protocol ensuring global consensus among all the
parachains. The Polkadot relay chain protocol, henceforward called
_Polkadot protocol_, can itself be considered as a replicated state
machine on its own. As such, the protocol can be specified by
identifying the state machine and the replication strategy.

 

From a more technical point of view, the Polkadot protocol has been
divided into two parts, the _Runtime_ and the _Host_. The Runtime
comprises the state transition logic for the Polkadot protocol and is
designed and be upgradable via the consensus engine without requiring
hard forks of the blockchain. The Polkadot Host provides the
functionality for the Runtime to execute its state transition logic,
such as an execution environment, I/O and consensus, shared mostly among
peer-to-peer decentralized cryptographically-secured transaction
systems, i.e. blockchains whose consensus system is based on the
proof-of-stake. The Polkadot Host is planned to be stable and static for
the lifetime duration of the Polkadot protocol.

 

With the current document, we aim to specify the Polkadot Host part of
the Polkadot protocol as a replicated state machine. After defining the
basic terms in Chapter 1, we proceed to specify the representation of a
valid state of the Protocol in Chapter link:#chap-state-spec[2]. In
Chapter link:#chap-state-transit[3], we identify the protocol states, by
explaining the Polkadot state transition and discussing the detail based
on which the Polkadot Host interacts with the state transition function,
i.e. Runtime. Following, we specify the input messages triggering the
state transition and the system behaviour. In Chapter
link:#sect-networking[4], we specify the communication protocols and
network messages required for the Polkadot Host to communicate with
other nodes in the network, such as exchanging blocks and consensus
messages. In Chapter link:#chap-consensu[6], we specify the consensus
protocol, which is responsible for keeping all the replica in the same
state. Finally, the initial state of the machine is identified and
discussed in Appendix link:#sect-genesis-block[11]. A Polkadot Host
implementation which conforms with this part of the specification should
successfully be able to sync its states with the Polkadot network.

[[sect-defn-conv]]
=== Definitions and Conventions

[#defn-state-machine]##[defn-state-machine]##A *Discrete State Machine
(DSM)* is a state transition system whose set of states and set of
transitions are countable and admits a starting state. Formally, it is a
tuple of

[latexmath]
++++
\[(\Sigma, S, s_0, \delta)\]
++++
where [#defn-runtime]#[defn-runtime]#

* latexmath:[$\Sigma$] is the countable set of all possible transitions.
* latexmath:[$S$] is a countable set of all possible states.
* latexmath:[$s_0 \in S$] is the initial state.
* latexmath:[$\delta$] is the state-transition function, known as
*Runtime* in the Polkadot vocabulary, such that
+
[latexmath]
++++
\[\delta : S \times \Sigma \rightarrow S\]
++++

[#defn-path-graph]##[defn-path-graph]##A *path graph* or a *path* of
latexmath:[$n$] nodes formally referred to as
[#autolab1]##[autolab1]##*latexmath:[$P_n$]*, is a tree with two nodes
of vertex degree 1 and the other n-2 nodes of vertex degree 2.
Therefore, latexmath:[$P_n$] can be represented by sequences of
latexmath:[$(v_1, \ldots,
  v_n)$] where latexmath:[$e_i = (v_i, v_{i + 1})$] for
latexmath:[$1 \leqslant i \leqslant n - 1$] is the edge which connect
latexmath:[$v_i$] and latexmath:[$v_{i + 1}$].

[#defn-radix-tree]##[defn-radix-tree]##*Radix-r tree* is a variant of  a
trie in which:

* Every node has at most latexmath:[$r$] children where
latexmath:[$r = 2^x$] for some latexmath:[$x$];
* Each node that is the only child of a parent, which does not represent
a valid key is merged with its parent.

As a result, in a radix tree, any path whose interior vertices all have
only one child and does not represent a valid key in the data set, is
compressed into a single edge. This improves space efficiency when the
key space is sparse.

By a *sequences of bytes* or a *byte array*, latexmath:[$b$], of length
latexmath:[$n$], we refer to

[latexmath]
++++
\[b :=(b_0, b_1, ..., b_{n - 1})  \text{such that } 0 \leqslant b_i
     \leqslant 255\]
++++
We define [#autolab2]##[autolab2]##latexmath:[$\mathbb{B}_n$] to be the
*set of all byte arrays of length latexmath:[$n$]*. Furthermore, we
define:

[latexmath]
++++
\[\mathbb{B} :=\bigcup^{\infty}_{i = 0} \mathbb{B}_i\]
++++

We represent the concatenation of byte arrays
latexmath:[$a :=(a_0, \ldots, a_n)$] and
latexmath:[$b :=(b_0, \ldots, b_m)$] by:

[latexmath]
++++
\[a || b :=(a_0, \ldots, a_n, b_0, \ldots, b_m)\]
++++

[#defn-bit-rep]##[defn-bit-rep]##For a given byte latexmath:[$b$] the
*bitwise representation* of latexmath:[$b$] is defined as

[latexmath]
++++
\[b :=b^7 \ldots b^0\]
++++
where

[latexmath]
++++
\[b = 2^0 b^0 + 2^1 b^1 + \cdots + 2^7 b^7\]
++++

[#defn-little-endian]##[defn-little-endian]##By the *little-endian*
representation of a non-negative integer, [#autolab3]##[autolab3]##I,
represented as

[latexmath]
++++
\[I = (B_n \ldots B_0)_{256}\]
++++
in base 256, we refer to a byte array
[#autolab4]##[autolab4]##latexmath:[$B = (b_0, b_1,
  \ldots, b_n)$] such that

[latexmath]
++++
\[b_i :=B_i\]
++++
Accordingly, we define the function
[#autolab5]##[autolab5]##latexmath:[$\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{LE}}}$]:

[latexmath]
++++
\[\begin{array}{llll}
       \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{LE}}} : & \mathbb{Z}^+ & \rightarrow & \mathbb{B}\\
       & (B_n \ldots B_0)_{256} & \mapsto & (B_{0,} B_1, \ldots , B_n)
     \end{array}\]
++++

By ** we refer to a non-negative integer stored in a byte array of
length 4 using little-endian encoding format.

A [#autolab6]##[autolab6]##*blockchain* latexmath:[$C$] is a directed
path graph. Each node of the graph is called
[#autolab7]##[autolab7]##*Block* and indicated by *latexmath:[$B$]*. The
unique sink of latexmath:[$C$] is called
[#autolab8]##[autolab8]##*Genesis Block*, and the source is called the
[#autolab9]##[autolab9]##*Head* of C. For any vertex
latexmath:[$(B_1, B_2)$] where latexmath:[$B_1 \rightarrow B_2$] we say
latexmath:[$B_2$] is the [#autolab10]##[autolab10]##*parent* of
latexmath:[$B_1$] and we indicate it by

[latexmath]
++++
\[B_2 :=P (B_1)\]
++++

[#defn-unix-time]##[defn-unix-time]##By *UNIX time*, we refer to the
unsigned, little-endian encoded 64-bit integer which stores the number
of *milliseconds* that have elapsed since the Unix epoch, that is the
time 00:00:00 UTC on 1 January 1970, minus leap seconds. Leap seconds
are ignored, and every day is treated as if it contained exactly 86’400
seconds.

==== Block Tree

In the course of formation of a (distributed) blockchain, it is possible
that the chain forks into multiple subchains in various block positions.
We refer to this structure as a _block tree:_

[#defn-block-tree]##[defn-block-tree]##The
[#autolab11]##[autolab11]##*block tree* of a blockchain, denoted by
latexmath:[$\ensuremath{\operatorname{BT}}$] is the union of all
different versions of the blockchain observed by the Polkadot Host such
that every block is a node in the graph and latexmath:[$B_1$] is
connected to latexmath:[$B_2$] if latexmath:[$B_1$] is a parent of
latexmath:[$B_2$].

When a block in the block tree gets finalized, there is an opportunity
to prune the block tree to free up resources into branches of blocks
that do not contain all of the finalized blocks or those that can never
be finalized in the blockchain. For a definition of finality, see
Section link:#sect-finality[6.3].

[#defn-pruned-tree]##[defn-pruned-tree]##By
[#autolab12]##[autolab12]##*Pruned Block Tree*, denoted by
latexmath:[$\ensuremath{\operatorname{PBT}}$], we refer to a subtree of
the block tree obtained by eliminating all branches which do not contain
the most recent finalized blocks, as defined in Definition
link:#defn-finalized-block[[defn-finalized-block]]. By
[#autolab13]##[autolab13]##*pruning*, we refer to the procedure of
latexmath:[$\ensuremath{\operatorname{BT}} \leftarrow \ensuremath{\operatorname{PBT}}$].
When there is no risk of ambiguity and is safe to prune BT, we use
latexmath:[$\ensuremath{\operatorname{BT}}$] to refer to
latexmath:[$\ensuremath{\operatorname{PBT}}$].

Definition link:#defn-chain-subchain[[defn-chain-subchain]] gives the
means to highlight various branches of the block tree.

[#defn-chain-subchain]##[defn-chain-subchain]##Let
[#autolab14]##[autolab14]##latexmath:[$G$] be the root of the block tree
and latexmath:[$B$] be one of its nodes. By
[#autolab15]##[autolab15]##*Chain(latexmath:[$B$])*, we refer to the
path graph from latexmath:[$G$] to latexmath:[$B$] in
(P)latexmath:[$\ensuremath{\operatorname{BT}}$]. Conversely, for a chain
latexmath:[$C$]=Chain(B), we define [#autolab16]##[autolab16]##*the head
of latexmath:[$C$]* to be latexmath:[$B$], formally noted as
latexmath:[$B :=$]Head(latexmath:[$C$]). We define
[#autolab17]##[autolab17]##latexmath:[$| C |$], the length of
latexmath:[$C$]as a path graph. If latexmath:[$B'$] is another node on
Chain(latexmath:[$B$]), then by
[#autolab18]##[autolab18]##SubChain(latexmath:[$B', B$]) we refer to the
subgraph of Chain(latexmath:[$B$]) path graph which contains both
latexmath:[$B$] and latexmath:[$B'$] and by
SubChain(latexmath:[$B', B$]) we refer to its length. Accordingly,
[#autolab19]##[autolab19]##latexmath:[$\mathbb{C}_{B'} ((P) \ensuremath{\operatorname{BT}})$]
is the set of all subchains of
latexmath:[$(P) \ensuremath{\operatorname{BT}}$] rooted at
latexmath:[$B'$]. The set of all chains of
latexmath:[$(P) \ensuremath{\operatorname{BT}}$],
latexmath:[$\mathbb{C}_G ((P) \ensuremath{\operatorname{BT}})$] is
denoted by latexmath:[$\mathbb{C}$]((P)BT) or simply
[#autolab20]##[autolab20]##latexmath:[$\mathbb{C}$], for the sake of
brevity.

[#defn-longest-chain]##[defn-longest-chain]##We define the following
complete order over latexmath:[$\mathbb{C}$] such that for
latexmath:[$C_1, C_2 \in \mathbb{C}$] if latexmath:[$| C_1 | \neq | C_2
  |$] we say latexmath:[$C_1 > C_2$] if and only if
latexmath:[$| C_1 | > | C_2 |$].

If latexmath:[$| C_1 | = | C_2 |$] we say latexmath:[$C_1 > C_2$] if and
only if the block arrival time of
latexmath:[$\ensuremath{\operatorname{Head}} (C_1)$] is less than the
block arrival time of
latexmath:[$\ensuremath{\operatorname{Head}} (C_2)$] as defined in
Definition link:#defn-block-time[[defn-block-time]]. We define the
[#autolab21]##[autolab21]##*Longest-Chain(latexmath:[$\ensuremath{\operatorname{BT}}$])*
to be the maximum chain given by this order.

[#autolab22]##[autolab22]##Longest-Path(latexmath:[$\ensuremath{\operatorname{BT}}$])
returns the path graph of
latexmath:[$(P) \ensuremath{\operatorname{BT}}$] which is the longest
among all paths in latexmath:[$(P) \ensuremath{\operatorname{BT}}$] and
has the earliest block arrival time as defined in Definition
link:#defn-block-time[[defn-block-time]]. [#autolab23]#[autolab23]#
Deepest-Leaf(latexmath:[$\ensuremath{\operatorname{BT}}$]) returns the
head of Longest-Path(latexmath:[$\ensuremath{\operatorname{BT}}$])
chain.

Because every block in the blockchain contains a reference to its
parent, it is easy to see that the block tree is de facto a tree. A
block tree naturally imposes partial order relationships on the blocks
as follows:

We say *B is descendant of latexmath:[$B'$]*, formally noted as
*latexmath:[$B
  > B'$]* if latexmath:[$B$] is a descendant of latexmath:[$B'$] in the
block tree.

 

latexmath:[$\Box$]

 

[[chap-state-spec]]
== State Specification

[[sect-state-storage]]
=== State Storage and Storage Trie

For storing the state of the system, Polkadot Host implements a hash
table storage where the keys are used to access each data entry. There
is no assumption either on the size of the key nor on the size of the
data stored under them, besides the fact that they are byte arrays with
specific upper limits on their length. The limit is imposed by the
encoding algorithms to store the key and the value in the storage trie.

==== Accessing System Storage 

The Polkadot Host implements various functions to facilitate access to
the system storage for the Runtime. See Section
link:#sect-entries-into-runtime[3.1] for a an explaination of those
functions. Here we formalize the access to the storage when it is being
directly accessed by the Polkadot Host (in contrast to Polkadot
runtime).

[#defn-stored-value]##[defn-stored-value]##The
[#autolab24]##[autolab24]##*StoredValue* function retrieves the value
stored under a specific key in the state storage and is formally defined
as :

[latexmath]
++++
\[\begin{array}{cc}
       \ensuremath{\operatorname{StoredValue}} : & \mathcal{K} \rightarrow \mathcal{V}\\
       & k \mapsto \left\{ \begin{array}{cc}
         v & \text{if (k,v) exists in state storage}\\
         \phi & \ensuremath{\operatorname{otherwise}}
       \end{array} \right.
     \end{array}\]
++++
where latexmath:[$\mathcal{K} \subset \mathbb{B}$] and
latexmath:[$\mathcal{V} \subset \mathbb{B}$] are respectively the set of
all keys and values stored in the state storage.

 

==== The General Tree Structure

In order to ensure the integrity of the state of the system, the stored
data needs to be re-arranged and hashed in a _modified Merkle Patricia
Tree_, which hereafter we refer to as the _*Trie*_. This rearrangment is
necessary to be able to compute the Merkle hash of the whole or part of
the state storage, consistently and efficiently at any given time.

The Trie is used to compute the _state root_, latexmath:[$H_r$], (see
Definition link:#defn-block-header[[defn-block-header]]), whose purpose
is to authenticate the validity of the state database. Thus, the
Polkadot Host follows a rigorous encoding algorithm to compute the
values stored in the trie nodes to ensure that the computed Merkle hash,
latexmath:[$H_r$], matches across the Polkadot Host implementations.

The Trie is a _radix-16_ tree as defined in Definition
link:#defn-radix-tree[[defn-radix-tree]]. Each key value identifies a
unique node in the tree. However, a node in a tree might or might not be
associated with a key in the storage.

When traversing the Trie to a specific node, its key can be
reconstructed by concatenating the subsequences of the key which are
stored either explicitly in the nodes on the path or implicitly in their
position as a child of their parent.

To identify the node corresponding to a key value, latexmath:[$k$],
first we need to encode latexmath:[$k$] in a consistent with the Trie
structure way. Because each node in the trie has at most 16 children, we
represent the key as a sequence of 4-bit nibbles:

For the purpose of labeling the branches of the Trie, the key
latexmath:[$k$] is encoded to
latexmath:[$k_{\ensuremath{\operatorname{enc}}}$] using KeyEncode
functions:

[latexmath]
++++
\[k_{\ensuremath{\operatorname{enc}}} :=(k_{\ensuremath{\operatorname{enc}}_1}, \ldots, k_{\ensuremath{\operatorname{enc}}_{2 n}})
    :=\ensuremath{\operatorname{KeyEncode}} (k) \label{key-encode-in-trie}\]
++++
such that:

[latexmath]
++++
\[\ensuremath{\operatorname{KeyEncode}} (k) : \left\{ \begin{array}{lll}
       \mathbb{B}^{} & \rightarrow & \ensuremath{\operatorname{Nibbles}}^4\\
       k :=(b_1, \ldots, b_n) :=& \mapsto & (b^1_1, b^2_1, b_2^1,
       b^2_2, \ldots, b^1_n, b^2_n)\\
       &  & :=(k_{\ensuremath{\operatorname{enc}}_1}, \ldots, k_{\ensuremath{\operatorname{enc}}_{2 n}})
     \end{array} \right.\]
++++
where latexmath:[$\ensuremath{\operatorname{Nibble}}^4$] is the set of
all nibbles of 4-bit arrays and latexmath:[$b^1_i$] and
latexmath:[$b^2_i$] are 4-bit nibbles, which are the big endian
representations of latexmath:[$b_i$]:

[latexmath]
++++
\[(b^1_i, b^2_i) :=(b_i / 16, b_i \ensuremath{\operatorname{mod}} 16)\]
++++
where mod is the remainder and / is the integer division operators.

By looking at latexmath:[$k_{\ensuremath{\operatorname{enc}}}$] as a
sequence of nibbles, one can walk the radix tree to reach the node
identifying the storage value of latexmath:[$k$].

[[sect-state-storage-trie-structure]]
==== Trie Structure

In this subsection, we specify the structure of the nodes in the Trie as
well as the Trie structure:

We refer to the *set of the nodes of Polkadot state trie* by
latexmath:[$\mathcal{N}.$] By latexmath:[$N \in \mathcal{N}$] to refer
to an individual node in the trie.

[#defn-nodetype]##[defn-nodetype]##The State Trie is a radix-16 tree.
Each Node in the Trie is identified with a unique key latexmath:[$k_N$]
such that:

* latexmath:[$k_N$] is the shared prefix of the key of all the
descendants of latexmath:[$N$] in the Trie.

and, at least one of the following statements holds:

* latexmath:[$(k_N, v)$] corresponds to an existing entry in the State
Storage.
* N has more than one child.

Conversely, if latexmath:[$(k, v)$] is an entry in the State Trie then
there is a node latexmath:[$N \in \mathcal{N}$] such that
latexmath:[$k_N$]=k.

A *branch* node is a node which has one child or more. A branch node can
have at most 16 children. A *leaf* node is a childless node.
Accordingly:

[latexmath]
++++
\[\begin{array}{c}
       \mathcal{N}_b :=\left\{ N \in \mathcal{N}|N \text{is a branch
       node} \right\}\\
       \mathcal{N}_l :=\left\{ N \in \mathcal{N}|N \text{is a leaf node}
       \right\}
     \end{array}\]
++++

For each node, part of latexmath:[$k_N$] is built while the trie is
traversed from root to latexmath:[$N$] part of latexmath:[$k_N$] is
stored in latexmath:[$N$] as formalized in Definition
link:#defn-node-key[[defn-node-key]].

[#defn-node-key]##[defn-node-key]##For any
latexmath:[$N \in \mathcal{N}$], its key latexmath:[$k_N$] is divided
into an *aggregated prefix key*,
*latexmath:[$\ensuremath{\operatorname{pk}}_N^{\ensuremath{\operatorname{Agr}}}$]*,
aggregated by Algorithm link:#algo-aggregate-key[[algo-aggregate-key]]
and a *partial key*, *latexmath:[$\ensuremath{\operatorname{pk}}_N$]* of
length
latexmath:[$0 \leqslant l_{\ensuremath{\operatorname{pk}}_N} \leqslant
  65535$] in nibbles such that:

[latexmath]
++++
\[\ensuremath{\operatorname{pk}}_N :=(k_{\ensuremath{\operatorname{enc}}_i}, \ldots, k_{\ensuremath{\operatorname{enc}}_{i +
     l_{\ensuremath{\operatorname{pk}}_N}}})\]
++++
where latexmath:[$\ensuremath{\operatorname{pk}}_N$] is a suffix
subsequence of latexmath:[$k_N$]; latexmath:[$i$] is the length of
latexmath:[$\ensuremath{\operatorname{pk}}_N^{\ensuremath{\operatorname{Agr}}}$]
in nibbles and so we have:

[latexmath]
++++
\[\ensuremath{\operatorname{KeyEncode}} (k_N) = \ensuremath{\operatorname{pk}}_N^{\ensuremath{\operatorname{Agr}}} | | \ensuremath{\operatorname{pk}}_N =
     (k_{\ensuremath{\operatorname{enc}}_1}, \ldots, k_{\ensuremath{\operatorname{enc}}_{i - 1}}, k_{\ensuremath{\operatorname{enc}}_i},
     k_{\ensuremath{\operatorname{enc}}_{i + l_{\ensuremath{\operatorname{pk}}_N}}})\]
++++

Part of
latexmath:[$\ensuremath{\operatorname{pk}}_N^{\ensuremath{\operatorname{Agr}}}$]
is explicitly stored in latexmath:[$N$]’s ancestors. Additionally, for
each ancestor, a single nibble is implicitly derived while traversing
from the ancestor to its child included in the traversal path using the
latexmath:[$\ensuremath{\operatorname{Index}}_N$] function defined in
Definition link:#defn-index-function[[defn-index-function]].

[#defn-index-function]##[defn-index-function]##For
latexmath:[$N \in \mathcal{N}_b$] and latexmath:[$N_c$] child of N, we
define *latexmath:[$\ensuremath{\operatorname{Index}}_N$]* function as:

[latexmath]
++++
\[\begin{array}{cc}
       \ensuremath{\operatorname{Index}}_N : & \left\{ N_c \in \mathcal{N}|N_c  \text{is a child of
       N} \right\} \rightarrow \ensuremath{\operatorname{Nibbles}}^4_1\\
       & N_c \mapsto i 
     \end{array}\]
++++
such that

[latexmath]
++++
\[k_{N_c} = k_N | | i | | \ensuremath{\operatorname{pk}}_{N_c}\]
++++

Assuming that latexmath:[$P_N$] is the path (see Definition
link:#defn-path-graph[[defn-path-graph]]) from the Trie root to node
latexmath:[$N$], Algorithm
link:#algo-aggregate-key[[algo-aggregate-key]] rigorously demonstrates
how to build
latexmath:[$\ensuremath{\operatorname{pk}}^{\ensuremath{\operatorname{Agr}}}_N$]
while traversing latexmath:[$P_N$].

*Algorithm*

{empty}[#algo-aggregate-key]##[algo-aggregate-key]##Aggregate-Keylatexmath:[$(P_N : =
      (\ensuremath{\operatorname{TrieRoot}} = N_1, \ldots, N_j = N))$]

[#defn-node-value]##[defn-node-value]##A node
latexmath:[$N \in \mathcal{N}$] stores the *node value*,
*latexmath:[$v_N$]*, which consists of the following concatenated data:

[latexmath]
++++
\[\begin{array}{|l|l|l|}
       \hline
       \ensuremath{\operatorname{Node}} \ensuremath{\operatorname{Header}} & \ensuremath{\operatorname{Partial}} \ensuremath{\operatorname{key}} & \ensuremath{\operatorname{Node}}
       \ensuremath{\operatorname{Subvalue}}\\
       \hline
     \end{array}\]
++++
Formally noted as:

[latexmath]
++++
\[v_N :=\ensuremath{\operatorname{Head}}_N | | \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{HE}}} (\ensuremath{\operatorname{pk}}_N) | |
     \ensuremath{\operatorname{sv}}_N\]
++++
where latexmath:[$\ensuremath{\operatorname{Head}}_N$],
latexmath:[$\ensuremath{\operatorname{pk}}_N$],
latexmath:[$\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{nibbles}}}$]
and latexmath:[$\ensuremath{\operatorname{sv}}_N$] are defined in
Definitions link:#defn-node-header[[defn-node-header]],
link:#defn-node-key[[defn-node-key]],
link:#defn-hex-encoding[[defn-hex-encoding]] and
link:#defn-node-subvalue[[defn-node-subvalue]], respectively.

[#defn-node-header]##[defn-node-header]##The *node header* of node
latexmath:[$N$], latexmath:[$\ensuremath{\operatorname{Head}}_N$],
consists of latexmath:[$l + 1 \geqslant 1$] bytes
latexmath:[$\ensuremath{\operatorname{Head}}_{N, 1},
  \ldots, \ensuremath{\operatorname{Head}}_{N, l + 1}$] such that:

[latexmath]
++++
\[\begin{array}{ll}
       \hline
       \ensuremath{\operatorname{Node}} \ensuremath{\operatorname{Type}} & \ensuremath{\operatorname{pk}} \ensuremath{\operatorname{length}}\\
       \hline
       {\ensuremath{\operatorname{Head}}_{N, 1}^{6 - 7}}   & {\ensuremath{\operatorname{Head}}_{N, 1}^{0 - 5}}  
     \end{array}  \begin{array}{|l|}
       \hline
       \ensuremath{\operatorname{pk}} \ensuremath{\operatorname{length}} \ensuremath{\operatorname{extra}} \ensuremath{\operatorname{byte}} 1\\
       \hline
       {\ensuremath{\operatorname{Head}}_{N, 2}} \\
       \hline
     \end{array}  \begin{array}{|l|}
       \hline
       \ensuremath{\operatorname{pk}} \ensuremath{\operatorname{key}} \ensuremath{\operatorname{length}} \ensuremath{\operatorname{extra}} \ensuremath{\operatorname{byte}} 2\\
       \hline
       \ldots .\\
       \hline
     \end{array} \ldots \begin{array}{|l|}
       \hline
       \ensuremath{\operatorname{pk}} \ensuremath{\operatorname{length}} \ensuremath{\operatorname{extra}} \ensuremath{\operatorname{byte}} l\\
       \hline
       {\ensuremath{\operatorname{Head}}_{N, l + 1} } \\
       \hline
     \end{array}\]
++++

In which
latexmath:[${\ensuremath{\operatorname{Head}}_{N, 1}^{6 - 7}}$], the two
most significant bits of the first byte of
latexmath:[$\ensuremath{\operatorname{Head}}_N$] are determined as
follows:

[latexmath]
++++
\[{\ensuremath{\operatorname{Head}}_{N, 1}^{6 - 7}}   :=\left\{ \begin{array}{ll}
       00 & \ensuremath{\operatorname{Special}} \ensuremath{\operatorname{case}}\\
       01 & \ensuremath{\operatorname{Leaf}} \ensuremath{\operatorname{Node}}\\
       10 & \ensuremath{\operatorname{Branch}} \ensuremath{\operatorname{Node}} \ensuremath{\operatorname{with}} k_N \not\in\mathcal{K}\\
       11 & \ensuremath{\operatorname{Branch}} \ensuremath{\operatorname{Node}} \ensuremath{\operatorname{with}} k_N \in \mathcal{K}
     \end{array} \right.\]
++++
where latexmath:[$\mathcal{K}$] is defined in Definition
link:#defn-stored-value[[defn-stored-value]].

latexmath:[${\ensuremath{\operatorname{Head}}_{N, 1}^{0 - 5}}$], the 6
least significant bits of the first byte of
latexmath:[$\ensuremath{\operatorname{Head}}_N$] are defined to be:

[latexmath]
++++
\[{\ensuremath{\operatorname{Head}}_{N, 1}^{0 - 5}}   :=\left\{ \begin{array}{ll}
       \| \ensuremath{\operatorname{pk}}_N \|_{\ensuremath{\operatorname{nib}}} & \| \ensuremath{\operatorname{pk}}_N \|_{\ensuremath{\operatorname{nib}}} < 63\\
       63 & \| \ensuremath{\operatorname{pk}}_N \|_{\ensuremath{\operatorname{nib}}} \geqslant 63
     \end{array} \right.\]
++++
In which
*latexmath:[$\| \ensuremath{\operatorname{pk}}_N \|_{\ensuremath{\operatorname{nib}}}$]*
is the length of latexmath:[$\ensuremath{\operatorname{pk}}_N$] in
number nibbles.
latexmath:[$\ensuremath{\operatorname{Head}}_{N, 2}, \ldots,
  \ensuremath{\operatorname{Head}}_{N, l + 1}$] bytes are determined by
Algorithm link:#algo-pk-length[[algo-pk-length]].

*Algorithm*

{empty}[#algo-pk-length]##[algo-pk-length]##Partial-Key-Length-Encodinglatexmath:[$\left(
      {\ensuremath{\operatorname{Head}}_{N, 1}^{6 - 7}}  , \ensuremath{\operatorname{pk}}_N \right)$]

[[sect-merkl-proof]]
==== Merkle Proof

To prove the consistency of the state storage across the network and its
modifications both efficiently and effectively, the Trie implements a
Merkle tree structure. The hash value corresponding to each node needs
to be computed rigorously to make the inter-implementation data
integrity possible.

 

The Merkle value of each node should depend on the Merkle value of all
its children as well as on its corresponding data in the state storage.
This recursive dependancy is encompassed into the subvalue part of the
node value which recursively depends on the Merkle value of its
children. Additionally, as Section
link:#sect-child-trie-structure[2.2.1] clarifies, the Merkle proof of
each *child trie* must be updated first before the final Polkadot state
root can be calculated.

We use the auxilary function introduced in Definition
link:#defn-children-bitmap[[defn-children-bitmap]] to encode and decode
information stored in a branch node.

[#defn-children-bitmap]##[defn-children-bitmap]##Suppose
latexmath:[$N_b, N_c \in \mathcal{N}$] and latexmath:[$N_c$] is a child
of latexmath:[$N_b$]. We define where bit latexmath:[$b_i : = 1$] if
latexmath:[$N$] has a child with partial key latexmath:[$i$], therefore
we define *ChildrenBitmap* functions as follows:

[latexmath]
++++
\[\begin{array}{cc}
       \ensuremath{\operatorname{ChildrenBitmap}} : & \mathcal{N}_b \rightarrow \mathbb{B}_2\\
       & N \mapsto (b_{15}, \ldots, b_8, b_7, \ldots b_0)_2
     \end{array}\]
++++
where

[latexmath]
++++
\[b_i :=\left\{ \begin{array}{cc}
       1 & \exists N_c \in \mathcal{N}: k_{N_c} = k_{N_b} | | i | |
       \ensuremath{\operatorname{pk}}_{N_c}\\
       0 & \text{otherwise}
     \end{array} \right.\]
++++

[#defn-node-subvalue]##[defn-node-subvalue]##For a given node
latexmath:[$N$], the *subvalue* of latexmath:[$N$], formally referred to
as latexmath:[$\ensuremath{\operatorname{sv}}_N$], is determined as
follows:

[latexmath]
++++
\[\begin{array}{l}
         \ensuremath{\operatorname{sv}}_N :=\\
         \left\{ \begin{array}{c}
           \ensuremath{\operatorname{StoredValue}}_{\ensuremath{\operatorname{SC}}}\\
           \ensuremath{\operatorname{Enc}} _{\ensuremath{\operatorname{SC}}} (\ensuremath{\operatorname{ChildrenBitmap}} (N)) \|
           \ensuremath{\operatorname{StoredValue}}_{\ensuremath{\operatorname{SC}}} \| \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}}
           (H (N_{C_1})) \ldots \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (H (N_{C_n})) 
         \end{array} \right.\\
         \\
         \text{where the first variant is a leaf node and the second variant
         is a branch node.}\\
         \\
         \ensuremath{\operatorname{StoredValue}}_{\ensuremath{\operatorname{SC}}} :=\left\{ \begin{array}{lll}
           \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (\ensuremath{\operatorname{StoredValue}} (k_N)) &  & \text{if
           StoredValue(k\_N)=v}\\
           \ensuremath{\boldsymbol{\phi}} &  & \text{if
           StoredValue(k\_N)=\ensuremath{\ensuremath{\boldsymbol{{\phi}}}}}
         \end{array} \right.
       \end{array}\]
++++

latexmath:[$N_{C_1} \ldots N_{C_n}$] with latexmath:[$n \leqslant 16$]
are the children nodes of the branch node latexmath:[$N$] and
Enclatexmath:[$_{\textrm{SC}}$],
latexmath:[$\ensuremath{\operatorname{StoredValue}}$], latexmath:[$H$],
and latexmath:[$\ensuremath{\operatorname{ChildrenBitmap}} (N)$] are
defined in Definitions link:#sect-scale-codec[10.1],
link:#defn-stored-value[[defn-stored-value]],
link:#defn-merkle-value[[defn-merkle-value]] and
link:#defn-children-bitmap[[defn-children-bitmap]] respectively.

 

The Trie deviates from a traditional Merkle tree where node value,
latexmath:[$v_N$] (see Definition
link:#defn-node-value[[defn-node-value]]) is presented instead of its
hash if it occupies less space than its hash.

[#defn-merkle-value]##[defn-merkle-value]##For a given node
latexmath:[$N$], the *Merkle value* of latexmath:[$N$], denoted by
latexmath:[$H (N)$] is defined as follows:

[latexmath]
++++
\[\begin{array}{ll}
       & H : \mathbb{B} \rightarrow \cup_{i \rightarrow 0}^{32}
       \mathbb{B}_{32}\\
       & H (N) : \left\{ \begin{array}{lcl}
         v_N &  & \|v_N \|< 32 \text{ and }N \neq R\\
         \ensuremath{\operatorname{Blake}} 2 b (v_N) &  & \|v_N \| \geqslant 32 \text{ or }N = R
       \end{array} \right.
     \end{array}\]
++++
Where latexmath:[$v_N$] is the node value of latexmath:[$N$] defined in
Definition link:#defn-node-value[[defn-node-value]] and latexmath:[$R$]
is the root of the Trie. The *Merkle hash* of the Trie is defined to be
latexmath:[$H (R)$].

[[sect-child-storages]]
=== Child Storage

As clarified in Section link:#sect-state-storage[2.1], the Polkadot
state storage implements a hash table for inserting and reading
key-value entries. The child storage works the same way but is stored in
a separate and isolated environment. Entries in the child storage are
not directly accessible via querying the main state storage.

 

The Polkadot Host supports as many child storages as required by Runtime
and identifies each separate child storage by its unique identifying
key. Child storages are usually used in situations where Runtime deals
with multiple instances of a certain type of objects such as Parachains
or Smart Contracts. In such cases, the execution of the Runtime entry
might result in generating repeated keys across multiple instances of
certain objects. Even with repeated keys, all such instances of
key-value pairs must be able to be stored within the Polkadot state.

 

In these situations, the child storage can be used to provide the
isolation necessary to prevent any undesired interference between the
state of separated instances. The Polkadot Host makes no assumptions
about how child storages are used, but provides the functionality for
it. This is described in more detail in the Host API, as described in
Section link:#sect-child-storages[2.2].

[[sect-child-trie-structure]]
==== Child Tries

The child trie specification is the same as the one described in Section
link:#sect-state-storage-trie-structure[2.1.3]. Child tries have their
own isolated environment. Nonetheless, the main Polkadot state trie
depends on them by storing a node (latexmath:[$K_N, V_N$]) which
corresponds to an individual child trie. Here, latexmath:[$K_N$] is the
child storage key associated to the child trie, and latexmath:[$V_N$] is
the Merkle value of its corresponding child trie computed according to
the procedure described in Section link:#sect-merkl-proof[2.1.4]

 

The Polkadot Host APIs as defined in link:#sect-child-storages[2.2]
allows the Runtime to provide the key latexmath:[$K_N$] in order to
identify the child trie, followed by a second key in order to identify
the value within that child trie. Every time a child trie is modified,
the Merkle proof latexmath:[$V_N$] of the child trie stored in the
Polkadot state must be updated first. After that, the final Merkle proof
of the Polkadot state can be computed. This mechanism provides a proof
of the full Polkadot state including all its child states.

 

latexmath:[$\Box$]

 

[[chap-state-transit]]
== State Transition

Like any transaction-based transition system, Polkadot’s state is
changed by executing an ordered set of instructions. These instructions
are known as _extrinsics_. In Polkadot, the execution logic of the
state-transition function is encapsulated in a Runtime as defined in
Definition link:#defn-state-machine[[defn-state-machine]]. For easy
upgradability this Runtime is presented as a Wasm blob. Nonetheless, the
Polkadot Host needs to be in constant interaction with the Runtime. The
detail of such interaction is further described in Section
link:#sect-entries-into-runtime[3.1].

In Section link:#sect-extrinsics[3.2], we specify the procedure of the
process where the extrinsics are submitted, pre-processed and validated
by Runtime and queued to be applied to the current state.

To make state replication feasible, Polkadot journals and batches series
of its extrinsics together into a structure known as a _block_, before
propagating them to other nodes, similar to most other prominent
distributed ledger systems. The specification of the Polkadot block as
well as the process of verifying its validity are both explained in
Section link:#sect-state-replication[3.3].

[[sect-entries-into-runtime]]
=== Interacting with the Runtime

The Runtime as defined in Definition link:#defn-runtime[[defn-runtime]]
is the code implementing the logic of the chain. This code is decoupled
from the Polkadot Host to make the the logic of the chain easily
upgradable without the need to upgrade the Polkadot Host itself. The
general procedure to interact with the Runtime is described in Algorithm
link:#algo-runtime-interaction[[algo-runtime-interaction]].

*Algorithm*

[#algo-runtime-interaction]##[algo-runtime-interaction]##Interact-With-Runtime(latexmath:[$F$]:
runtime entry to call,

latexmath:[$H_b (B)$]: Block hash indicating the state at the end of
latexmath:[$B$],

latexmath:[$A_1, A_2, \ldots, A_n$]: arguments to be passed to the
runtime entry)

In this section, we describe the details upon which the Polkadot Host is
interacting with the Runtime. In particular, Set-State-At and
Call-Runtime-Entry procedures called in Algorithm
link:#algo-runtime-interaction[[algo-runtime-interaction]] are explained
in Notation link:#nota-call-into-runtime[[nota-call-into-runtime]] and
Definition link:#defn-set-state-at[[defn-set-state-at]] respectively.
latexmath:[$R_B$] is the Runtime code loaded from
latexmath:[$\mathcal{S}_B$], as described in Notation
link:#nota-runtime-code-at-state[[nota-runtime-code-at-state]], and
latexmath:[$\mathcal{R}\mathcal{E}_B$] is the Polkadot Host API, as
described in Notation
link:#nota-host-api-at-state[[nota-host-api-at-state]].

[[sect-loading-runtime-code]]
==== Loading the Runtime Code

The Polkadot Host expects to receive the code for the Runtime of the
chain as a compiled WebAssembly (Wasm) Blob. The current runtime is
stored in the state database under the key represented as a byte array:

[latexmath]
++++
\[b :=\text{3A,63,6F,64,65}\]
++++
which is the ASCII byte representation of the string ``'' (see Section
link:#sect-genesis-block[11]). As a result of storing the Runtime as
part of the state, the Runtime code itself becomes state sensitive and
calls to Runtime can change the Runtime code itself. Therefore the
Polkadot Host needs to always make sure to provide the Runtime
corresponding to the state in which the entry has been called.
Accordingly, we introduce the following notation to refer to the Runtime
code at a specific state:

[#nota-runtime-code-at-state]##[nota-runtime-code-at-state]##By
latexmath:[$R_B$], we refer to the Runtime code stored in the state
storage at the end of the execution of block latexmath:[$B$].

The initial Runtime code of the chain is provided as part of the genesis
state (see Section link:#sect-genesis-block[11]) and subsequent calls to
the Runtime have the ability to, in turn, upgrade the Runtime by
replacing this Wasm blob with the help of the storage API (see Section
link:#sect-host-api[12]).

[[sect-code-executor]]
==== Code Executor

The Polkadot Host executes the calls of Runtime entries inside a Wasm
Virtual Machine (VM), which in turn provides the Runtime with access to
the Polkadot Host API. This part of the Polkadot Host is referred to as
the _*Executor*._

Definition link:#nota-call-into-runtime[[nota-call-into-runtime]]
introduces the notation for calling the runtime entry which is used
whenever an algorithm of the Polkadot Host needs to access the runtime.

[#nota-call-into-runtime]#[nota-call-into-runtime]# By

[latexmath]
++++
\[\text{{\textsc{Call-Runtime-Entry}}} \left( R, \mathcal{R}\mathcal{E},
     \text{\text{{\ttfamily{Runtime-Entry}}}}, A, A_{\ensuremath{\operatorname{len}}} \right)\]
++++
we refer to the task using the executor to invoke the while passing an
latexmath:[$A_1, \ldots, A_n$] argument to it and using the encoding
described in Section
link:#sect-runtime-send-args-to-runtime-enteries[3.1.2.2].

It is acceptable behavior that the Runtime panics during execution of a
function in order to indicate an error. The Polkadot Host must be able
to catch that panic and recover from it.

 

In this section, we specify the general setup for an Executor that calls
into the Runtime. In Section link:#sect-runtime-entries[13] we specify
the parameters and return values for each Runtime entry separately.

[[sect-memory-management]]
===== Memory Management

The Polkadot Host is responsible for managing the WASM heap memory
starting at the exported symbol as a part of implementing the allocator
Host API (see Section link:#sect-ext-allocator[12.7]) and the same
allocator should be used for any other heap allocation to be used by the
Polkadot Runtime.

The size of the provided WASM memory should be based on the value of the
storage key (an unsigned 64-bit integer), where each page has the size
of 64KB. This memory shoule be made available to the Polkadot Runtime
for import under the symbol name .

[[sect-runtime-send-args-to-runtime-enteries]]
===== Sending Data to a Runtime Entry 

In general, all data exchanged between the Polkadot Host and the Runtime
is encoded using SCALE codec described in Section
link:#sect-scale-codec[10.1]. Therefore all runtime entries have the
following identical Wasm function signatures:

 

 

In each invocation of a Runtime entry, the argument(s) which are
supposed to be sent to the entry, need to be SCALE encoded into a byte
array latexmath:[$B$] (see Definition link:#sect-scale-codec[10.1]) and
copied into a section of Wasm shared memory managed by the shared
allocator described in Section link:#sect-memory-management[3.1.2.1].

When the Wasm method , corresponding to the entry, is invoked, two
integers are passed as arguments. The first argument is set to the
memory adress of the byte array latexmath:[$B$] in Wasm memory. The
second argument sets the length of the encoded data stored in
latexmath:[$B$].

[[sect-runtime-return-value]]
===== Receiving Data from a Runtime Entry

The value which is returned from the invocation is an integer,
representing two consecutive integers in which the least significant one
indicates the pointer to the offset of the result returned by the entry
encoded in SCALE codec in the memory buffer. The most significant one
provides the size of the blob.

[[sect-handling-runtime-state-update]]
===== Handling Runtimes update to the State

In order for the Runtime to carry on various tasks, it manipulates the
current state by means of executing calls to various Polkadot Host APIs
(see Appendix link:#sect-host-api[12]). It is the duty of Host APIs to
determine the context in which these changes should persist. For
example, if Polkdot Host needs to validate a transaction using entry
(see Section link:#sect-rte-validate-transaction[13.3.4.1]), it needs to
sandbox the changes to the state just for that Runtime call and prevent
the global state of the system from being influence by the call to such
a Runtime entry. This includes reverting the state of function calls
which return errors or panic.

As a rule of thumb, any state changes resulting from Runtime enteries
are not persistant with the exception of state changes resulting from
calling (see Section link:#sect-rte-core-execute-block[13.3.1.2]) while
Polkadot Host is importing a block (see Section
link:#sect-block-validation[3.3.2]).

 

For more information on managing multiple variant of state see Section
link:#sect-managing-multiple-states[3.3.3].

[[sect-extrinsics]]
=== Extrinsics

The block body consists of an array of extrinsics. In a broad sense,
extrinsics are data from outside of the state which can trigger state
transitions. This section describes extrinsics and their inclusion into
blocks.

==== Preliminaries

The extrinsics are divided into two main categories defined as follows:

*Transaction extrinsics* are extrinsics which are signed using either of
the key types described in section link:#sect-cryptographic-keys[9.5]
and broadcasted between the nodes. *Inherent extrinsics* are unsigned
extrinsics which are generated by Polkadot Host and only included in the
blocks produced by the node itself. They are broadcasted as part of the
produced blocks rather than being gossiped as individual extrinsics.

The Polkadot Host does not specify or limit the internals of each
extrinsics and those are defined and dealt with by the Runtime (defined
in Definition link:#defn-runtime[[defn-runtime]]). From the Polkadot
Host point of view, each extrinsics is simply a SCALE-encoded blob as
defined in Section link:#sect-scale-codec[10.1].

==== Transactions

Transaction are submitted and exchanged through _Transactions_ network
messages (see Section link:#sect-msg-transactions[4.8.3]). Upon
receiving a Transactions message, the Polkadot Host decodes the
SCALE-encoded blob and splits it into individually SCALE-encoded
transactions.

Alternative transaction can be submitted to the host by offchain worker
through the Host API, defined in Section
link:#sect-ext-offchain-submit-transaction[[sect-ext-offchain-submit-transaction]].

Any new transaction should be submitted to the Runtime function, defined
in Section link:#sect-rte-validate-transaction[13.3.4.1]. This will
allow the Polkadot Host to check the validity of the received
transaction against the current stat and if it should be gossiped to
other peers. If considers the submitted transaction as valid, the
Polkadot Host should store it for inclusion in future blocks. The whole
process of handeling new transactions is described in more detail by
Algorithm
link:#algo-validate-transactions[[algo-validate-transactions]].

Additionally valid transactions that are supposed to be gossiped are
propagated to connected peers of the Polkadot Host. While doing so the
Polkadot Host should keep track of peers already aware of each
transaction. This includes peers which have already gossiped the
transaction to the node as well as those to whom the transaction has
already been sent. This behavior is mandated to avoid resending
duplicates and unnecessarily overloading the network. To that aim, the
Polkadot Host should keep a _transaction pool_ and a _transaction queue_
defined as follows:

[#defn-transaction-queue]##[defn-transaction-queue]##The *Transaction
Queue* of a block producer node, formally referred to as
latexmath:[$\ensuremath{\operatorname{TQ}}$] is a data structure which
stores the transactions ready to be included in a block sorted according
to their priorities (Definition link:#sect-msg-transactions[4.8.3]). The
*Transaction Pool*, formally referred to as
latexmath:[$\ensuremath{\operatorname{TP}}$], is a hash table in which
the Polkadot Host keeps the list of all valid transactions not in the
transaction queue.

Algorithm link:#algo-validate-transactions[[algo-validate-transactions]]
updates the transaction pool and the transaction queue according to the
received message:

*Algorithm*

[#algo-validate-transactions]##[algo-validate-transactions]##Validate-Transactions-and-Store(latexmath:[$M_T
      :$]Transaction Message)

In which

* latexmath:[$\text{{\textsc{Dec\ensuremath{_{\textrm{Sc}}}}}}$] decodes
the SCALE encoded message.
* Longest-Chain is defined in Definition
link:#defn-longest-chain[[defn-longest-chain]].
* is a Runtime entry specified in Section
link:#sect-rte-validate-transaction[13.3.4.1] and Requires(R),
Priority(R) and Propagate(R) refer to the corresponding fields in the
tuple returned by the entry when it deems that latexmath:[$T$] is valid.
* Provided-Tags(T) is the list of tags that transaction latexmath:[$T$]
provides. The Polkadot Host needs to keep track of tags that transaction
latexmath:[$T$] provides as well as requires after validating it.
* Insert-At(latexmath:[$\ensuremath{\operatorname{TQ}}, T, \ensuremath{\operatorname{Requires}} (R),
  \ensuremath{\operatorname{Priority}} (R)$]) places latexmath:[$T$]
into latexmath:[$\ensuremath{\operatorname{TQ}}$] approperietly such
that the transactions providing the tags which latexmath:[$T$] requires
or have higher priority than latexmath:[$T$] are ahead of
latexmath:[$T$].
* Maintain-Transaction-Pool is described in Algorithm
link:#algo-maintain-transaction-pool[[algo-maintain-transaction-pool]].
* ShouldPropagate indictes whether the transaction should be propagated
based on the field in the type as defined in Definition
link:#defn-valid-transaction[[defn-valid-transaction]], which is
returned by .
* Propagate(latexmath:[$T$]) sends latexmath:[$T$] to all connected
peers of the Polkadot Host who are not already aware of latexmath:[$T$].

*Algorithm*

[#algo-maintain-transaction-pool]##[algo-maintain-transaction-pool]##Maintain-Transaction-Pool

[[sect-inherents]]
==== Inherents

Inherents are unsigned extrinsic inserted into a block by the block
author and as a result are not stored in the transaction pool or
gossiped across the network. Instead they are generated by the Polkadot
Host by passing the required inherent data, as listed in Table
link:#tabl-inherent-data[3.1], to the Runtime method [.sans-serif]##
(Section link:#defn-rt-builder-inherent-extrinsics[13.3.3.3]). The then
returned extrinsics should be included in the current block as explained
in Algorithm link:#algo-build-block[[algo-build-block]]. [To do: define
uncles]

[[tabl-inherent-data]]
.[#tabl-inherent-data]##[tabl-inherent-data]##List of inherent data
[cols="<,<,<",options="header",]
|===
|Identifier |Value type |Description
|timstap0 |u64 |Unix epoch time in number of milliseconds

|uncles00 |array of block headers |Provides a list of potential uncle
block headerslatexmath:[$^{\ref{defn-block-header}}$] for a given block
|===

[#defn-inherent-data]##[defn-inherent-data]##Inherent-Data is a
hashtable (Definition link:#defn-scale-list[[defn-scale-list]]), an
array of key-value pairs consisting of the inherent 8-byte identifier
and its value, representing the totality of inherent extrinsics included
in each block. The entries of this hash table which are listed in Table
link:#tabl-inherent-data[3.1] are collected or generated by the Polkadot
Host and then handed to the Runtime for inclusion as dercribed in
Algorithm link:#algo-build-block[[algo-build-block]].

[[sect-state-replication]]
=== State Replication

Polkadot nodes replicate each other’s state by syncing the history of
the extrinsics. This, however, is only practical if a large set of
transactions are batched and synced at the time. The structure in which
the transactions are journaled and propagated is known as a block (of
extrinsics) which is specified in Section
link:#sect-block-format[3.3.1]. Like any other replicated state
machines, state inconsistency can occure between Polkadot replicas.
Section link:#sect-managing-multiple-states[3.3.3] is giving an overview
of how a Polkadot Host node manages multiple variants of the state.

[[sect-block-format]]
==== Block Format

A Polkadot block consists a (Section link:#sect-block-header[3.3.1.1])
and a (Section link:#sect-block-body[3.3.1.3]). The in turn is made up
out of a , which represent the generalization of the concept of
_transactions_. can contain any set of external data the underlying
chain wishes to validate and track.

[[sect-block-header]]
===== Block Header

The block header is designed to be minimalistic in order to allow
efficienct handeling by light clients. It is defined formally as
follows:

[#defn-block-header]##[defn-block-header]##The *header of block B*,
*latexmath:[$\ensuremath{\operatorname{Head}} (B)$]* is a 5-tuple
containing the following elements:

* formally indicated as
latexmath:[$\textbf{\text{H\ensuremath{_{\textrm{p}}}}}$], is the
32-byte Blake2b hash (Section link:#sect-blake2[9.2]) of the SCALE
encoded parent block header as defined in Definition
link:#defn-block-header-hash[[defn-block-header-hash]].
* *[.sans-serif]#number:#* formally indicated as *latexmath:[$H_i$]*, is
an integer, which represents the index of the current block in the
chain. It is equal to the number of the ancestor blocks. The genesis
state has number 0.
* *[.sans-serif]#state_root:#* formally indicated as
*latexmath:[$H_r$]*, is the root of the Merkle trie, whose leaves
implement the storage for the system.
* *[.sans-serif]#extrinsics_root:#* is the field which is reserved for
the Runtime to validate the integrity of the extrinsics composing the
block body. For example, it can hold the root hash of the Merkle trie
which stores an ordered list of the extrinsics being validated in this
block. The [.sans-serif]#extrinsics_root# is set by the runtime and its
value is opaque to the Polkadot Host. This element is formally referred
to as *latexmath:[$H_e$]*.
* *[.sans-serif]#digest:#* this field is used to store any
chain-specific auxiliary data, which could help the light clients
interact with the block without the need of accessing the full storage
as well as consensus-related data including the block signature. This
field is indicated as *latexmath:[$H_d$]* and its detailed format is
defined in Definition link:#defn-digest[[defn-digest]]

[#defn-digest]##[defn-digest]##The header *digest* of block
latexmath:[$B$] formally referred to by *latexmath:[$H_d (B)$]* is an
array of *digest items* latexmath:[$H^i_d$]’s , known as digest items of
varying data type (see Definition
link:#defn-varrying-data-type[[defn-varrying-data-type]]) such that

[latexmath]
++++
\[H_d (B) : = H^1_d, \ldots, H^n_d\]
++++
where each digest item can hold one of the type described in Table
link:#tabl-digest-items[[tabl-digest-items]]:

 

Where latexmath:[$E_{\ensuremath{\operatorname{id}}}$] is the unique
consensus engine identifier defined in Section
link:#defn-consensus-message-digest[[defn-consensus-message-digest]] and

* *Changes trie root* contains the root of the Changes Trie at block
latexmath:[$B$], as described in Section link:#sect-changes-trie[3.3.4].
Note that this is future-reserved and currently *not* used in Polkadot.
* *Pre-runtime* digest items represent messages from a consensus engine
to the Runtime (e.g. see Definition
link:#defn-babe-header[[defn-babe-header]]).
* *Consensus* digest items represent messages from the Runtime to the
consensus engine (see Section
link:#sect-consensus-message-digest[6.1.2]).
* *Seal* is the data produced by the consensus engine and proving the
authorship of the block producer. In particular, the Seal digest item
must be the last item in the digest array and must be stripped off by
the Polkadot Host before the block is submitted to any Runtime function
including for validation. The Seal must be added back to the digest
afterward. The detail of the Seal digest item is laid out in Definition
link:#defn-babe-seal[[defn-babe-seal]].

[#defn-block-header-hash]##[defn-block-header-hash]##The *block header
hash of block latexmath:[$B$]*, *latexmath:[$H_h (B)$]*, is the hash of
the header of block latexmath:[$B$] encoded by simple codec:

[latexmath]
++++
\[H_h (B) :=\ensuremath{\operatorname{Blake}} 2 b (\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (\ensuremath{\operatorname{Head}}
     (B)))\]
++++

[[sect-justified-block-header]]
===== Justified Block Header

The Justified Block Header is provided by the consensus engine and
presented to the Polkadot Host, for the block to be appended to the
blockchain. It contains the following parts:

* *[.sans-serif]#*block_header*#* the complete block header as defined
in Section link:#block[[block]] and denoted by
latexmath:[$\ensuremath{\operatorname{Head}} (B)$].
* *[.sans-serif]#justification#*: as defined by the consensus
specification indicated by
latexmath:[$\ensuremath{\operatorname{Just}} (B)$] as defined in
Definition
link:#defn-grandpa-justification[[defn-grandpa-justification]].
* *[.sans-serif]#authority Ids#*: This is the list of the Ids of
authorities, which have voted for the block to be stored and is formally
referred to as latexmath:[$A (B)$]. An authority Id is 256-bit.

[[sect-block-body]]
===== Block Body

The Block Body consists of an sequence of extrinsics, each encoded as a
byte array. The content of an extrinsic is completely opaque to the
Polkadot Host. As such, from the point of the Polkadot Host, and is
simply a SCALE encoded array of byte arrays. Formally:

[#defn-block-body]##[defn-block-body]##The *body of Block*
latexmath:[$B$] represented as
*latexmath:[$\ensuremath{\operatorname{Body}} (B)$]* is defined to be

[latexmath]
++++
\[\ensuremath{\operatorname{Body}} (B) :=\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (E_1, \ldots, E_n)\]
++++
Where each latexmath:[$E_i \in \mathbb{B}$] is a SCALE encoded
extrinsic.

[[sect-block-validation]]
==== Importing and Validating Block

[#sect-block-submission]#[sect-block-submission]#

Block validation is the process by which a node asserts that a block is
fit to be added to the blockchain. This means that the block is
consistent with the current state of the system and transitions to a new
valid state.

 

New blocks can be received by the Polkadot Host via other peers (see
Section link:#sect-msg-block-request[4.8.2]) or from the Host’s own
consensus engine (see Section
link:#sect-block-production[[sect-block-production]]). Both the Runtime
and the Polkadot Host then need to work together to assure block
validity. A block is deemed valid if the block author had authorship
rights for the slot in which the block was produce as well as if the
transactions in the block constitute a valid transition of states. The
former criterion is validated by the Polkadot Host according to the
block production consensus protocol. The latter can be verified by the
Polkadot Host invoking entry into the Runtime as defined in section
link:#sect-rte-core-execute-block[13.3.1.2] as a part of the validation
process. Any state changes created by this function on successful
execution are persisted.

 

The Polkadot Host implements the following procedure to assure the
validity of the block:

*Algorithm*

[#algo-import-and-validate-block]##[algo-import-and-validate-block]##Import-and-Validate-Block(latexmath:[$B,
      \ensuremath{\operatorname{Just}} (B)$])

In which

* Remove-Seal removes the Seal digest from the block as described in
Definition link:#defn-digest[[defn-digest]] before submitting it to the
Runtime.
* Add-Seal adds the Seal digest back to the block as described in
Definition link:#defn-digest[[defn-digest]] for later propagation.
* Persist-State implies the persistence of any state changes created by
on successful execution.
* PBT is the pruned block tree defined in Definition
link:#defn-block-tree[[defn-block-tree]].
* Verify-Authorship-Right is part of the block production consensus
protocol and is described in Algorithm
link:#algo-verify-authorship-right[[algo-verify-authorship-right]].
* and is defined in Section link:#sect-finality[6.3].

[[sect-managing-multiple-states]]
==== Managaing Multiple Variants of State

Unless a node is committed to only update its state according to the
finalized block (See Definition
link:#defn-finalized-block[[defn-finalized-block]]), it is inevitable
for the node to store multiple variants of the state (one for each
block). This is, for example, necessary for nodes participating in the
block production and finalization.

While the state trie structure described in Section
link:#sect-state-storage-trie-structure[2.1.3] facilitates and optimizes
storing and switching between multiple variants of the state storage,
the Polkadot Host does not specify how a node is required to accomplish
this task. Instead, the Polkadot Host is required to implement
Set-State-At operation which behaves as defined in Definition
link:#defn-set-state-at[[defn-set-state-at]]:

[#defn-set-state-at]##[defn-set-state-at]##The function

[latexmath]
++++
\[\text{{\textsc{{\textbf{Set-State-At($\ensuremath{\boldsymbol{B}}$)}}}}}\]
++++
in which latexmath:[$B$] is a block in the block tree (See Definition
link:#defn-block-tree[[defn-block-tree]]), sets the content of state
storage equal to the resulting state of executing all extrinsics
contained in the branch of the block tree from genesis till block B
including those recorded in Block B.

For the definition of the state storage see Section
link:#sect-state-storage[2.1].

[[sect-changes-trie]]
==== Changes Trie

{empty}[To do: NOTE: Changes Tries are still work-in-progress and are
currently *not* used in Polkadot. Additionally, the implementation of
Changes Tries might change considerably.]

 

Polkadot focuses on light client friendliness and therefore implements
functionalities that allows identifying changes in the state of the
blockchain without the requirement to search through the entire chain.
The *Changes Trie* is a radix-16 tree data structure as defined in
Definition link:#defn-radix-tree[[defn-radix-tree]] and maintained by
the Polkadot Host. It stores different types of storage changes made by
each individual block separately.

 

The primary method for generating the Changes Trie is provided to the
Runtime with the Host API as described in Section
link:#sect-ext-storage-changes-root[12.1.9]. The Runtime calls that
function shortly before finalizing the block, the Polkadot Host must
then generate the Changes Trie based on the storage changes which
occured during block production or execution. In order to provide this
API function, it is imperative that the Polkadot Host implements a
mechanism to keep track of the changes created by individual blocks, as
mentioned in Sections link:#sect-state-storage[2.1] and
link:#sect-managing-multiple-states[3.3.3].

The Changes Trie stores three different types of changes.

The *inserted key-value pair stored in the nodes of Changes Trie* is
formally defined as:

[latexmath]
++++
\[(K_C, V_C)\]
++++
Where latexmath:[$K_C$] is a SCALE-encoded Tuple

[latexmath]
++++
\[\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{sc}}} \left( \left( {{\ensuremath{\operatorname{Type}}_{V_C}} } , H_i (B_i), K
   \right) \right)\]
++++
and

[latexmath]
++++
\[V_C = \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (C_{\ensuremath{\operatorname{value}}})\]
++++
is a SCALE encoded byte array.

Furthermore, latexmath:[$K$] represents the changed storage key,
latexmath:[$H_i (B_i)$] refers to the block number at which this key is
inserted into the Changes Trie (See Definition
link:#defn-block-header[[defn-block-header]]) and
latexmath:[$\ensuremath{\operatorname{Type}}_{V_C}$] is an index
defining the type  latexmath:[$C_{\ensuremath{\operatorname{Value}}}$]
according to Table link:#table-changes-trie-key-types[3.2].

[[table-changes-trie-key-types]]
.[#table-changes-trie-key-types]##[table-changes-trie-key-types]##Possible
types of keys of mappings in the Changes Trie
[cols="<,<,<",options="header",]
|===
|*Type* |*Description*
|*latexmath:[$C_{\ensuremath{\operatorname{Value}}}$]*
|1 |list of extrinsics indices (section
link:#sect-changes-trie-extrinsics-pairs[3.3.4.1])
|latexmath:[$\{ e_i, \ldots, e_k \}$]

| |where latexmath:[$e_i$] refers to the index of the extrinsic within
the block |

|2 |list of block numbers (section
link:#sect-changes-trie-block-pairs[3.3.4.2])
|latexmath:[$\{ H_i (B_k), \ldots, H_i (B_m) \}$]

|3 |Child Changes Trie (section
link:#sect-changes-trie-child-trie-pair[3.3.4.3])
|latexmath:[$H_r \left( \text{{\textsc{Child-Changes-Trie}}} \right)$]
|===

 

The Changes Trie itself is not part of the block, but a separately
maintained database by the Polkadot Host. The Merkle proof of the
Changes Trie must be included in the block digest as described in
Definition link:#defn-digest[[defn-digest]] and gets calculated as
described in section link:#sect-merkl-proof[2.1.4]. The root calculation
only considers pairs which were generated on the individual block and
does not consider pairs which were generated at previous blocks.

 

{empty}[To do: This seperately maintained database by the Polkadot Host
is intended to be used by ``proof servers'', where its implementation
and behavior has not been fully defined yet. This is considered
future-reserved]

 

As clarified in the individual sections of each type, not all of those
types get generated on every block. But if conditions apply, all those
different types of pairs get inserted into the same Changes Trie,
therefore only one Changes Trie Root gets generated for each block.

[[sect-changes-trie-extrinsics-pairs]]
===== Key to extrinsics pairs

This key-value pair stores changes which occure in an individual block.
Its value is a SCALE encoded array containing the indices of the
extrinsics that caused any changes to the specified key. The key-value
pair is defined as (clarified in section
link:#sect-changes-trie[3.3.4]):

[latexmath]
++++
\[(1, H_i (B_i), K) \rightarrow \{ e_i, \ldots, e_k \}\]
++++
The indices are unsigned 32-bit integers and their values are based on
the order in which each extrinsics appears in the block (indexing starts
at 0). The Polkadot Host generates those pairs for every changed key on
each and every block. Child storages have their own Changes Trie, as
described in section link:#sect-changes-trie-child-trie-pair[3.3.4.3].

 

{empty}[To do: clarify special key value of 0xffffffff]

[[sect-changes-trie-block-pairs]]
===== Key to block pairs

This key-value pair stores changes which occured in a certain range of
blocks. Its value is a SCALE encoded array containing block numbers in
which extrinsics caused any changes to the specified key. The key-value
pair is defined as (clarified in section
link:#sect-changes-trie[3.3.4]):

[latexmath]
++++
\[(2, H_i (B_i), K) \rightarrow \{ H_i (B_k), \ldots, H_i (B_m) \}\]
++++
The block numbers are represented as unsigned 32-bit integers. There are
multiple ``levels'' of those pairs, and the Polkadot Host does *not*
generate those pairs on every block. The genesis state contains the key
where its unsigned 64-bit value is a tuple of two 32-bit integers:

* - The interval (in blocks) at which those pairs should be created. If
this value is less or equal to 1 it means that those pairs are not
created at all.
* - The maximum number of ``levels'' in the hierarchy. If this value is
0 it means that those pairs are not created at all.

For each level from 1 to , the Polkadot Host creates those pairs on
every -nth block, formally applied as:

*Algorithm*

Key-To-Block-Pairs(latexmath:[$B_i$], latexmath:[$I$]: interval,
latexmath:[$L :$]levels

* latexmath:[$B_i$] implies the block at which those pairs gets inserted
into the Changes Trie.
* Insert-Blocks - Inserts every block number within the range
latexmath:[$H_i (B_i) - I^l + 1$] to latexmath:[$H_i (B_i)$] in which
any extrinsic changed the specified key.

For example, let’s say is set at and is set at . This means there are
now three levels which get generated at three different occurences:

[arabic]
. *Level 1* - Those pairs are generated at every
latexmath:[$\text{{\textbf{4\textsuperscript{1}}}}$]-nth block, where
the pair value contains the block numbers of every block that changed
the specified storage key. This level only considers block numbers of
the last four (latexmath:[$= 4^1$]) blocks.
* Example: this level occurs at block 4, 8, 12, 16, 32, etc.
. *Level 2* - Those pairs are generated at every
latexmath:[$\text{{\textbf{4\textsuperscript{2}}}}$]-nth block, where
the pair value contains the block numbers of every block that changed
the specified storage key. This level only considers block numbers of
the last 16 (latexmath:[$= 4^2$]) blocks.
* Example: this level occurs at block 16, 32, 64, 128, 256, etc.
. *Level 3* - Those pairs are generated at every -nth block, where the
pair value contains the block numbers of every block that changed the
specified storage key. this level only considers block number of the
last 64 (latexmath:[$= 4^3$]) blocks.
* Example: this level occurs at block 64, 128, 196, 256, 320, etc.

[[sect-changes-trie-child-trie-pair]]
===== Key to Child Changes Trie pairs

The Polkadot Host generates a separate Changes Trie for each child
storage, using the same behavior and implementation as describe in
section link:#sect-changes-trie-extrinsics-pairs[3.3.4.1]. Additionally,
the changed child storage key gets inserted into the primary, non-Child
Changes Trie where its value is a SCALE encoded byte array containing
the Merkle root of the Child Changes Trie. The key-value pair is defined
as:

[latexmath]
++++
\[(3, H_i (B_i), K) \rightarrow H_r \left(
   \text{{\textsc{Child-Changes-Trie}}} \right)\]
++++
The Polkadot Host creates those pairs for every changes child key for
each and every block.

 

latexmath:[$\Box$]

 

[[sect-networking]]
== Networking

This chapter in its current form is incomplete and considered work in
progress. Authors appreciate receiving request for clarification or any
reports regarding deviation from the current Polkadot network protocol.
This can be done through filing an issue in Polkadot Specification
repository .

=== Introduction

The Polkadot network is decentralized and does not rely on any central
authority or entity for achieving its fullest potential of provided
functionality. The networking protocol is based on a family of open
protocols, including protocol implemented e.g. the distributed Kademlia
hash table which is used for peer discovery.

This chapter walks through the behaviour of the networking
implementation of the Polkadot Host and defines the network messages.
The implementation details of the protocols used are specified in
external sources as described in Section
link:#sect-networking-external-docs[4.2].

[[sect-networking-external-docs]]
=== External Documentation

Complete specification of the Polkadot networking protocol relies on the
following external protocols:

* https://github.com/libp2p/specs[libp2p] - is a modular peer-to-peer
networking stack composed of many modules and different parts. includes
the multiplexing protocols and .
* https://docs.libp2p.io/concepts/addressing/[libp2p addressing] - The
Polkadot Host uses the addressing system to identify and connect to
peers.
* https://en.wikipedia.org/wiki/Kademlia[Kademlia] - is a distributed
hash table for decentralized peer-to-peer networks. The Polkadot Host
uses Kademlia for peer discovery.
* https://noiseprotocol.org/[Noise] - The Noise protocol is a framework
for building cryptographic protocols. The Polkadot Host uses Noise to
establish the encryption layer to remote peers.
* https://docs.libp2p.io/concepts/stream-multiplexing/#mplex[mplex] - is
a multiplexing protocol developed by . The protocol allows dividing a
connection to a peer into multiple substreams, each substream serving a
specific purpose. Generally, Polkadot Host implementers are encouraged
to prioritize implementing , since it is the de-facto standard in
Polkadot. is only required to communicate with
https://github.com/libp2p/js-libp2p[js-lip2p].
* https://docs.libp2p.io/concepts/stream-multiplexing/#yamux[yamux] - is
a multiplexing protocol like and developed by HashiCorp. It is the
de-facto standard for the Polkadot Host. This protocol should be
prioritized over . Section link:#sect-protocols-substreams[4.7]
describes the subprotocol in more detail.
* https://developers.google.com/protocol-buffers/docs/reference/proto3-spec[Protocol
Buffers] - Protocol Buffers is a language-neutral, platform-neutral
mechanism for serializing structured data and is developed by Google.
The Polkadot Host uses Protocol Buffers to serialize specific messages,
as clarified in Section link:#sect-network-messages[4.8].

=== Node Identities

Each Polkadot Host node maintains an ED25519 key pair which is used to
identify the node. The public key is shared with the rest of the network
allowing the nodes to establish secure communication channels.

Each node must have its own unique ED25519 key pair. When two or more
nodes use the same key, the network will interpret those nodes as a
single node, which will result in undefined behaviour and can result in
equivocation. Furthermore, the node’s as defined in Definition
link:#defn-peer-id[[defn-peer-id]] is derived from its public key.
(link:#defn-peer-id[[defn-peer-id]]) is used to identify each node when
they are discovered in the course of the discovery mechanism described
in Section link:#sect-discovery-mechanism[4.4].

[#defn-peer-id]##[defn-peer-id]##The Polkadot node’s , formally referred
to as latexmath:[$P_{\ensuremath{\operatorname{id}}}$], is derived from
the ED25519 public key and is structured as defined in the libp2p
specification (https://docs.libp2p.io/concepts/peer-id/).

[[sect-discovery-mechanism]]
=== Discovery mechanism

The Polkadot Host uses various mechanisms to find peers within the
network, to establish and maintain a list of peers and to share that
list with other peers from the network as follows:

* *Bootstrap nodes* are hard-coded node identities and addresses
provided by the genesis state specification as described in Appendix
link:#sect-genesis-block[11].
* *mDNS* is a protocol that performs a broadcast to the local network.
Nodes that might be listening can respond to the broadcast.
https://github.com/libp2p/specs/blob/master/discovery/mdns.md[The libp2p
mDNS specification] defines this process in more detail. This protocol
is an optional implementation detail for Polkadot Host implementers and
is not required to participate in the Polkadot network.
* *Kademlia requests* invoking Kademlia requests, where nodes respond
with their list of available peers. Kademlia requests are performed on a
specific substream as described in Section
link:#sect-protocols-substreams[4.7].

[[sect-connection-establishment]]
=== Connection establishment

Polkadot nodes connect to peers by establishing a TCP connection. Once
established, the node initiates a handshake with the remote peers on the
encryption layer. An additional layer on top of the encryption layer,
known as the multiplexing layer, allows a connection to be split into
substreams, as described by the
https://docs.libp2p.io/concepts/stream-multiplexing/#yamux[yamux
specification], either by the local or remote node.

The Polkadot node supports two types of substream protocols. Section
link:#sect-protocols-substreams[4.7] describes the usage of each type in
more detail:

* *Request-Response substreams*: After the protocol is negotiated by the
multiplexing layer, the initiator sends a single message containing a
request. The responder then sends a response, after which the substream
is then immediately closed. The requests and responses are prefixed with
their https://en.wikipedia.org/wiki/LEB128[LEB128] encoded length.
* *Notification substreams*. After the protocol is negotiated, the
initiator sends a single handshake message. The responder can then
either accept the substream by sending its own handshake or reject it by
closing the substream. After the substream has been accepted, the
initiator can send an unbound number of individual messages. The
responder keeps its sending side of the substream open, despite not
sending anything anymore, and can later close it in order to signal to
the initiator that it no longer wishes to communicate.
+
Handshakes and messages are prefixed with their
https://en.wikipedia.org/wiki/LEB128[LEB128] encoded lengths. A
handshake can be empty, in which case the length prefix would be .

Connections are established by using the following protocols:

* - a protocol that is announced when a connection to a peer is
established.
* - a protocol that is announced when negotiating an encryption protocol
or a substream.
* - a protocol used during the or negotiation. See Section
link:#sect-protocols-substreams[4.7] for more information.

The Polkadot Host can establish a connection with any peer of which it
knows the address. The Polkadot Host supports multiple networking
protocols:

* *TCP/IP* with addresses in the form of to establish a TCP connection
and negotiate encryption and a multiplexing layer.
* *Websockets* with addresses in the form of to establish a TCP
connection and negotiate the Websocket protocol within the connection.
Additionally, encryption and multiplexing layer is negotiated within the
WebSocket connection.
* *DNS* addresses in form of and .

The addressing system is described in the
https://docs.libp2p.io/concepts/addressing/[libp2p addressing]
specification. After a base-layer protocol is established, the Polkadot
Host will apply the Noise protocol to establish the encryption layer as
described in Section link:#sect-encryption-layer[4.6].

[[sect-encryption-layer]]
=== Encryption Layer

Polkadot protocol uses the [.sans-serif]## Noise framework to build an
encryption protocol. The Noise protocol is a framework for building
encryption protocols. utilizes that protocol for establishing encrypted
communication channels. Refer to the
https://github.com/libp2p/specs/tree/master/noise[libp2p Secure Channel
Handshake] specification for a detailed description.

Polkadot nodes use the https://noiseexplorer.com/patterns/XX/[XX
handshake pattern] to establish a connection between peers. The three
following steps are required to complete the handshake process:

[arabic]
. The initiator generates a keypair and sends the public key to the
responder. The https://github.com/libp2p/specs/tree/master/noise[Noise
specification] and the
https://github.com/libp2p/specs/blob/master/peer-ids/peer-ids.md[libp2p
PeerId specification] describe keypairs in more detail.
. The responder generates its own key pair and sends its public key back
to the initiator. After that, the responder derives a shared secret and
uses it to encrypt all further communication. The responder now sends
its static Noise public key (which may change anytime and does not need
to be persisted on disk), its public key and a signature of the static
Noise public key signed with the public key.
. The initiator derives a shared secret and uses it to encrypt all
further communication. It also sends its static Noise public key, public
key and signature to the responder.

After these three steps, both the initiator and responder derive a new
shared secret using the static and session-defined Noise keys, which are
used to encrypt all further communication.

[[sect-protocols-substreams]]
=== Protocols and Substreams

After the node establishes a connection with a peer, the use of
multiplexing allows the Polkadot Host to open substreams. uses the
https://docs.libp2p.io/concepts/stream-multiplexing/#mplex[ protocol] or
the https://docs.libp2p.io/concepts/stream-multiplexing/#yamux[
protocol] to manage substreams and to allow the negotiation of , where
each protocol serves a specific utility.

The Polkadot Host uses multiple substreams whose usage depends on a
specific purpose. Each substream is either a _Request-Response
substream_ or a _Notification substream_, as described in Section
link:#sect-connection-establishment[4.5].

* - Open a standardized substream to a peer and initialize a ping to
verify if a connection is still alive. If the peer does not respond, the
connection is dropped. This is a _Request-Response substream_.
+
Further specification and reference implementation are available in the
https://docs.libp2p.io/concepts/protocols/#ping[libp2p documentation].
* - Open a standardized substream to a peer to ask for information about
that peer. This is a _Request-Response substream_.
+
Further specification and reference implementation are available in the
https://docs.libp2p.io/concepts/protocols/#ping[libp2p documentation].
* - Open a standardized substream for Kademlia requests. This is a
_Request-Response substream_, as defined by the standard.
+
Further specification and reference implementation are available on
https://en.wikipedia.org/wiki/Kademlia[Wikipedia] respectively the
https://github.com/libp2p/go-libp2p-kad-dht[golang Github repository].

* - a request and response protocol that allows a light client to
request information about the state. This is a _Request-Response
substream_.
+
{empty}[To do: light client messages are currently not documented]
* - a substream/notification protocol which sends blocks to connected
peers. This is a _Notification substream_.
+
The messages are specified in Section
link:#sect-msg-block-announce[4.8.1].
* - a request and response protocol that allows the Polkadot Host to
perform information about blocks. This is a _Request-Response
substream_.
+
The messages are specified in Section
link:#sect-msg-block-request[4.8.2].
* - a substream/notification protocol which sends transactions to
connected peers. This is a _Notification substream_.
+
The messages are specified in Section
link:#sect-msg-transactions[4.8.3].
* - a substream/notification protocol that sends GRANDPA votes to
connected peers. This is a _Notification substream_.
+
The messages are specified in Section link:#sect-msg-grandpa[4.8.4].
+
{empty}[To do: This substream will change in the future. See
https://github.com/paritytech/substrate/issues/7252[issue #7252].]
* - a substream/notification protocol which sends signed BEEFY
statements, as described in Section link:#sect-grandpa-beefy[6.5], to
connected peers. This is a _Notification_ substream.
+
The messages are specified in Section
link:#sect-msg-grandpa-beefy[4.8.4.5].

*Note*: the prefixes on those substreams are known as protocol
identifiers and are used to segregate communications to specific
networks. This prevents any interference with other networks. is used
exclusively for Polkadot. Kusama, for example, uses the protocol
identifier.

[[sect-network-messages]]
=== Network Messages

The Polkadot Host must actively communicate with the network in order to
participate in the validation process or act as a full node.

*Note*: The Polkadot network originally only used SCALE encoding for all
message formats. Meanwhile, Protobuf has been adopted for certain
messages. The encoding of each message is explicitly mentioned in their
corresponding definition. Encoding and message formats are subject to
change.

[[sect-msg-block-announce]]
==== Announcing blocks

When the node creates or receives a new block, it must be announced to
the network. Other nodes within the network will track this announcement
and can request information about this block. The mechanism for tracking
announcements and requesting the required data is
implementation-specific.

Block announcements, requests and responses are sent over the substream
as defined in Definition
link:#defn-block-announce-handshake[[defn-block-announce-handshake]].

[#defn-block-announce-handshake]##[defn-block-announce-handshake]##The
initializes a substream to a remote peer. Once established, all
messages, as defined in Definition
link:#defn-block-announce[[defn-block-announce]], and created by the
node are sent to the substream.

The is a SCALE-encoded structure of the following format:

[latexmath]
++++
\[\begin{aligned}
    \ensuremath{\operatorname{BA}}_h & = & \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (R, N_B, h_B, h_G)
  \end{aligned}\]
++++
where:

[latexmath]
++++
\[\begin{aligned}
    R & = & \left\{\begin{array}{ll}
      1 & \textit{The node is a full node}\\
      2 & \textit{The node is a light client}\\
      4 & \textit{The node is a validator}
    \end{array}\right.\\
    N_B & = & \textit{Best block number according to the node}\\
    h_B & = & \textit{Best block hash according to the node}\\
    h_G & = & \textit{Genesis block hash according to the node}
  \end{aligned}\]
++++

[#defn-block-announce]##[defn-block-announce]##The message is sent to
the specified substream and indicates to remote peers that the node has
either created or received a new block.

The message is a SCALE-encoded structure of the following format:

[latexmath]
++++
\[\begin{aligned}
    \ensuremath{\operatorname{BA}} & = & \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (\ensuremath{\operatorname{Head}} (B), b)
  \end{aligned}\]
++++
where:

[latexmath]
++++
\[\begin{aligned}
    \ensuremath{\operatorname{Head}} (B) & = & \textit{Header of the announced block}\\
    b & = & \left\{\begin{array}{ll}
      0 & \textit{Is not part of the best chain}\\
      1 & \textit{Is the best block according to the node}
    \end{array}\right.
  \end{aligned}\]
++++

[[sect-msg-block-request]]
==== Requesting blocks

Block requests can be used to retrieve a range of blocks from peers.
Those messages are sent over the substream.

The message is a Protobuf serialized structure of the following format:

. Protobuf message.
[cols="<,<,<,<",options="header",]
|===
|*Type* |*Id* |*Description* |*Value*
|uint32 |1 |Bits of block data to request |latexmath:[$B_f$]
|oneof | |Start from this block |latexmath:[$B_S$]
|bytes |4 |End at this block (optional) |latexmath:[$B_e$]
|Direction |5 |Sequence direction |
|uint32 |6 |Maximum amount (optional) |latexmath:[$B_m$]
|===

where

* latexmath:[$B_f$] indicates all the fields that should be included in
the request. Its *big-endian* encoded bitmask that applies to all
desired fields with bitwise OR operations. For example, the
latexmath:[$B_f$] value to request and is (17).
+
.Bits of block data to be requested.
[cols="<,<",options="header",]
|===
|*Field* |*Value*
|Header |0000 0001
|Body |0000 0010
|Justification |0001 0000
|===
* latexmath:[$B_s$] is a Protobuf structure indicating a varying data
type of the following values:
+
.Protobuf message indicating the block to start from.
[cols="<,<,<",options="header",]
|===
|*Type* |*Id* |*Description*
|bytes |2 |The block hash
|bytes |3 |The block number
|===
* latexmath:[$B_e$] is either the block hash or block number depending
on the value of latexmath:[$B_s$]. An implementation-defined maximum is
used when unspecified.
* is a Protobuf structure indicating the sequence direction of the
requested blocks. The structure is a varying data type, as defined in
Definition link:#defn-varrying-data-type[[defn-varrying-data-type]], of
the following format:
+
. Protobuf structure.
[cols="<,<",options="header",]
|===
|*Id* |*Description*
|0 |Enumerate in ascending order
| |(from child to parent)
|1 |Enumerate in descending order
| |(from parent to canonical child)
|===
* latexmath:[$B_m$] is the number of blocks to be returned. An
implementation defined maximum is used when unspecified.

The message is received after sending a message to a peer. The message
is a Protobuf serialized structure of the following format:

. Protobuf message.
[cols="<,<,<",options="header",]
|===
|*Type* |*Id* |*Description*
|repeated |1 |Block data for the requested sequence
|BlockData | |
|===

where is a Protobuf structure containing the requested blocks. Do note
that the optional values are either present or absent depending on the
requested fields (bitmask value). The structure has the following
format:

.*BlockData* Protobuf structure.
[cols="<,<,<,<",options="header",]
|===
|*Type* |*Id* |*Description* |*Value*
|bytes |1 |Block header hash |Def.
link:#defn-block-header-hash[[defn-block-header-hash]]

|bytes |2 |Block header (optional) |Def.
link:#defn-block-header[[defn-block-header]]

|repeated |3 |Block body (optional) |Def.
link:#defn-block-body[[defn-block-body]]

|bytes | | |

|bytes |4 |Block receipt (optional) |

|bytes |5 |Block message queue (optional) |

|bytes |6 |Justification (optional) |Def.
link:#defn-grandpa-justification[[defn-grandpa-justification]]

|bool |7 |Indicates whether the justification |

| | |is empty (i.e. should be ignored). |
|===

[[sect-msg-transactions]]
==== Transactions

Transactions, as defined and described in Section
link:#sect-extrinsics[3.2], are sent directly to peers with which the
Polkadot Host has an open transaction substream, as defined in
Definition link:#defn-transactions-message[[defn-transactions-message]].
Polkadot Host implementers should implement a mechanism that only sends
a transaction once to each peer and avoids sending duplicates. Sending
duplicate transactions might result in undefined consequences such as
being blocked for bad behaviour by peers.

The mechanism for managing transactions is further described in Section
link:#sect-extrinsics[3.2].

[#defn-transactions-message]##[defn-transactions-message]##The
*transactions message* is the structure of how the transactions are sent
over the network. It is represented by latexmath:[$M_T$] and is defined
as follows:

[latexmath]
++++
\[M_T :=\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (C_1, \ldots, C_n)\]
++++
in which:

[latexmath]
++++
\[C_i :=\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (E_i)\]
++++
Where each latexmath:[$E_i$] is a byte array and represents a separate
extrinsic. The Polkadot Host is agnostic about the content of an
extrinsic and treats it as a blob of data.

Transactions are sent over the substream.

[[sect-msg-grandpa]]
==== GRANDPA Messages

The exchange of GRANDPA messages is conducted on the substream. The
process for the creation and distributing these messages is described in
Section link:#sect-finality[6.3]. The underlying messages are specified
in this section.

[#defn-gossip-message]##[defn-gossip-message]##A *GRANDPA gossip
message* is a variant, as defined in Definition
link:#defn-varrying-data-type[[defn-varrying-data-type]], which
identifies the message type that is cast by a voter. This type, followed
by the sub-component, is sent to other validators.

.GRANDPA gossip message types
[cols="<,<,<,<",options="header",]
|===
|*Id* |*Type* | |
|0 |GRANDPA vote message
|link:#defn-grandpa-vote-msg[[defn-grandpa-vote-msg]] |yes

|1 |GRANDPA commit message
|link:#defn-grandpa-commit-msg[[defn-grandpa-commit-msg]] |yes

|2 |GRANDPA neighbor message
|link:#defn-grandpa-neighbor-msg[[defn-grandpa-neighbor-msg]] |no

|3 |GRANDPA catch-up request message
|link:#defn-grandpa-catchup-request-msg[[defn-grandpa-catchup-request-msg]]
|no

|4 |GRANDPA catch-up message
|link:#defn-grandpa-catchup-response-msg[[defn-grandpa-catchup-response-msg]]
|no
|===

[[sect-msg-grandpa-vote]]
===== GRANDPA Vote Messages

[#defn-grandpa-vote-msg]##[defn-grandpa-vote-msg]##A *GRANDPA vote
message* by voter latexmath:[$v$], , is gossip to the network by voter
latexmath:[$v$] with the following structure:

[latexmath]
++++
\[\begin{aligned}
    M^{r, \ensuremath{\operatorname{stage}}}_v (B) & :=& \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (r,
    \ensuremath{\operatorname{id}}_{\mathbb{V}}, \mathit{SigMsg})\\
    \mathit{SigMsg} & :=& (\mathit{msg}, \ensuremath{\operatorname{Sig}}^{r,
    \ensuremath{\operatorname{stage}}}_{v_i}, v_{\ensuremath{\operatorname{id}}})\\
    \mathit{msg} & :=& \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (\ensuremath{\operatorname{stage}}, V^{r,
    \ensuremath{\operatorname{stage}}}_v (B))
  \end{aligned}\]
++++
Where:

This message is the sub-component of the GRANDPA gossip message as
defined in Definition link:#defn-gossip-message[[defn-gossip-message]]
of type Id 0.

===== GRANDPA Commit Message

[#defn-grandpa-justifications-compact]##[defn-grandpa-justifications-compact]##The
is an optimized data structure to store a collection of pre-commits and
their signatures to be submitted as part of a commit message. Instead of
storing an array of justifications, it uses the following format:

[latexmath]
++++
\[J^{r, \ensuremath{\operatorname{comp}}}_{v_{0 \ldots n}} : = (\{ V^{r, \ensuremath{\operatorname{pc}}}_{v_0},
     \ldots, V^{r, \ensuremath{\operatorname{pc}}}_{v_n} \}, \{  (\ensuremath{\operatorname{Sig}}^{r, \ensuremath{\operatorname{pc}}}_{v_0},
     v_{\ensuremath{\operatorname{id}}_0}), \ldots, (\ensuremath{\operatorname{Sig}}_{v_n}^{r, \ensuremath{\operatorname{pc}}},
     v_{\ensuremath{\operatorname{id}}_n}) \})\]
++++
Where:

[#defn-grandpa-commit-msg]##[defn-grandpa-commit-msg]##A
*latexmath:[$\ensuremath{\boldsymbol{}} \ensuremath{\operatorname{GRANDPA}}$]
commit message* for block latexmath:[$B$] in round latexmath:[$r$]
*latexmath:[$M_v^{r,
  \ensuremath{\operatorname{Fin}}}$](B)* is a message broadcasted by
voter latexmath:[$v$] to the network indicating that voter
latexmath:[$v$] has finalized block latexmath:[$B$] in round
latexmath:[$r$]. It has the following structure:

[latexmath]
++++
\[M^{r, \ensuremath{\operatorname{Fin}}}_v (B) :=\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (r,
     \ensuremath{\operatorname{id}}_{\mathbb{V}}, V_v^r (B), J_{\tilde{v}_{0 \ldots n}}^{r,
     \ensuremath{\operatorname{comp}}})\]
++++
Where:

This message is the sub-component of the GRANDPA gossip message as
defined in Definition link:#defn-gossip-message[[defn-gossip-message]]
of type Id 1.

[[sect-grandpa-neighbor-msg]]
===== GRANDPA Neighbor Message

Neighbor messages are sent to all connected peers but they are not
repropagated on reception. A message should be send whenever the
messages values change and at least every 5 minutes. The sender should
take the recipients state into account and avoid sending messages to
peers that are using a different voter sets or are in a different round.
Messages received from a future voter set or round can be dropped and
ignored.

[#defn-grandpa-neighbor-msg]##[defn-grandpa-neighbor-msg]##A is defined
as

[latexmath]
++++
\[M^{\ensuremath{\operatorname{neigh}}} : = \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (\ensuremath{\operatorname{version}}, r,
     \ensuremath{\operatorname{id}}_{\mathbb{V}}, H_h (B_{\ensuremath{\operatorname{last}}}))\]
++++
Where:

This message is the sub-component of the GRANDPA gossip message as
defined in Definition link:#defn-gossip-message[[defn-gossip-message]]
of type Id 2.

[[sect-grandpa-catchup-messages]]
===== GRANDPA Catch-up Messages

Whenever a Polkadot node detects that it is lagging behind the finality
procedure, it needs to initiate a _catch-up_ procedure. GRANDPA Neighbor
messages (see Section
link:#defn-grandpa-neighbor-msg[[defn-grandpa-neighbor-msg]]) reveal the
round number for the last finalized GRANDPA round which the node’s peers
have observed. This provides the means to identify a discrepancy in the
latest finalized round number observed among the peers. If such a
discrepancy is observed, the node needs to initiate the catch-up
procedure explained in Section link:#sect-grandpa-catchup[6.4.1].

In particular, this procedure involves sending a _catch-up request_ and
processing _catch-up response_ messages specified here:

A
[#defn-grandpa-catchup-request-msg]##[defn-grandpa-catchup-request-msg]##*GRANDPA
catch-up request message* for round r,
*latexmath:[$M_{i, v}^{\ensuremath{\operatorname{Cat}} - q}
  (\ensuremath{\operatorname{id}}_{\mathbb{V}}, r)$]*, is a message sent
from node latexmath:[$i$] to its voting peer node latexmath:[$v$]
requesting the latest status of a GRANDPA round latexmath:[$r' >
  r$] of the authority set
latexmath:[$\mathbb{V}_{\ensuremath{\operatorname{id}}}$] along with the
justification of the status and has the following structure:

[latexmath]
++++
\[M_{i, v}^{r, \ensuremath{\operatorname{Cat}} - q} :=\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (r,
     \ensuremath{\operatorname{id}}_{\mathbb{V}})\]
++++
This message is the sub-component of the GRANDPA Gossip message as
defined in Definition link:#defn-gossip-message[[defn-gossip-message]]
of type Id 3.

[#defn-grandpa-catchup-response-msg]##[defn-grandpa-catchup-response-msg]##*GRANDPA
catch-up response message* for round,
*latexmath:[$M_{v, i}^{\ensuremath{\operatorname{Cat}} - s}
  (\ensuremath{\operatorname{id}}_{\mathbb{V}}, r)$]*, is a message sent
by a node latexmath:[$v$] to node i in response of a catch-up request
latexmath:[$M_{v, i}^{\ensuremath{\operatorname{Cat}} - q}
  (\ensuremath{\operatorname{id}}_{\mathbb{V}}, r')$] in which
latexmath:[$r \geqslant r'$] is the latest GRANDPA round which v has
prove of its finalization and has the following structure:

[latexmath]
++++
\[M_{v, i}^{r, \ensuremath{\operatorname{Cat}} - s} :=\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}}
     (\ensuremath{\operatorname{id}}_{\mathbb{V}}, r, J_{0 \ldots n}^{r, \ensuremath{\operatorname{pv}}} (B), J_{0
     \ldots m}^{r, \ensuremath{\operatorname{pc}}} (B), H_h (B'), H_i (B'))\]
++++
Where B is the highest block which latexmath:[$v$] believes to be
finalized in round latexmath:[$r$]. latexmath:[$B'$] is the highest
ancestor of all blocks voted on in the arrays of justifications
latexmath:[$J^{r, \ensuremath{\operatorname{pv}}}_{0 \ldots n} (B)$] and
latexmath:[$J_{0 \ldots m}^{r,
  \ensuremath{\operatorname{pc}}} (B)$] with the exception of the
equivocationary votes.

This message is the sub-component of the GRANDPA Gossip message as
defined in Definition link:#defn-gossip-message[[defn-gossip-message]]
of type Id 4.

[[sect-msg-grandpa-beefy]]
===== GRANDPA BEEFY

{empty}[To do: NOTE: The BEEFY protocol is currently in early
development and subject to change]

 

This section defines the messages required for the GRANDPA BEEFY
protocol as described in Section link:#sect-grandpa-beefy[6.5]. Those
messages are sent over the substream.

[#defn-grandpa-beefy-commitment]##[defn-grandpa-beefy-commitment]##A
commitment, latexmath:[$C$], contains the information extracted from the
finalized block at height latexmath:[$H_i
  (B_{\ensuremath{\operatorname{last}}})$] as specified in the message
body.

 

C is a datastructe of the following format:

[latexmath]
++++
\[\begin{aligned}
    C & = & (R_h, H_i (B_{\ensuremath{\operatorname{last}}}), \ensuremath{\operatorname{id}}_{\mathbb{V}})
  \end{aligned}\]
++++
where

* latexmath:[$R_h$] is the MMR root of all the block header hashes
leading up to the latest, finalized block.
* latexmath:[$H_i (B_{\ensuremath{\operatorname{last}}})$] is the block
number this commitment is for. Namely the latest, finalized block.
* latexmath:[$\ensuremath{\operatorname{id}}_{\mathbb{V}}$] is the
current authority set Id as defined in Definition
link:#defn-authority-set-id[[defn-authority-set-id]].

[#defn-msg-beefy-gossip]##[defn-msg-beefy-gossip]##A vote message,
latexmath:[$M_v$], is direct vote created by the Polkadot Host on every
BEEFY round and is gossiped to its peers. The message is a datastructure
of the following format:

[latexmath]
++++
\[\begin{aligned}
    M_v & = & \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} \left( C, A^{\ensuremath{\operatorname{bfy}}}_{\ensuremath{\operatorname{id}}} {,
    A_{\ensuremath{\operatorname{sig}}}}  \right)
  \end{aligned}\]
++++
where

* C is the commitment as defined in Definition
link:#defn-grandpa-beefy-commitment[[defn-grandpa-beefy-commitment]].
* latexmath:[$A^{\ensuremath{\operatorname{bfy}}}_{\ensuremath{\operatorname{id}}}$]
is the ECDSA public key of the Polkadot Host.
* latexmath:[$A_{\ensuremath{\operatorname{sig}}}$] is the signature
created with
latexmath:[$A^{\ensuremath{\operatorname{bfy}}}_{\ensuremath{\operatorname{id}}}$]
by signing the statement latexmath:[$R_h$] in latexmath:[$C$].

[#defn-grandpa-beefy-signed-commitment]##[defn-grandpa-beefy-signed-commitment]##A
signed commitment, latexmath:[$M_{\ensuremath{\operatorname{sc}}}$], is
a datastructure of the following format:

[latexmath]
++++
\[\begin{aligned}
    M_{\ensuremath{\operatorname{sc}}} & = & \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (C, S_n)\\
    S_n & = & (A^{\ensuremath{\operatorname{sig}}}_0, \ldots, A^{\ensuremath{\operatorname{sig}}}_n)
  \end{aligned}\]
++++
where

* latexmath:[$C$] is the commitment as defined in Definition
link:#defn-grandpa-beefy-commitment[[defn-grandpa-beefy-commitment]].
* latexmath:[$S_n$] is an array where its exact size matches the number
of validators in the current authority set as specified by
latexmath:[$\ensuremath{\operatorname{id}}_{\mathbb{V}}$] (Definition
link:#defn-authority-set-id[[defn-authority-set-id]]) in C. Individual
items are of the type as defined in Definition
link:#defn-option-type[[defn-option-type]] which can contain a signature
of a validator which signed the same statement (latexmath:[$R_h$] in
latexmath:[$C$]) and is active in the current authority set. It’s
critical that the signatures are sorted based on their corresponding
public key entry in the authority set.
+
 
+
For example, the signature of the validator at index 3 in the authority
set must be placed at index 3 in latexmath:[$S_n$]. If not signature is
available for that validator, then the variant is inserted. This sorting
allows clients to map public keys to their corresponding signatures.

[#defn-grandpa-beefy-signed-commitment-witness]##[defn-grandpa-beefy-signed-commitment-witness]##A
signed commitment witness,
latexmath:[$M^w_{\ensuremath{\operatorname{sc}}}$], is a light version
of the signed commitment as defined in Definition
link:#defn-grandpa-beefy-signed-commitment[[defn-grandpa-beefy-signed-commitment]].
Instead of containing the entire list of signatures, it only claims
which validator signed the statement.

 

The message is a datastructure of the following format:

[latexmath]
++++
\[\begin{aligned}
    M^w_{\ensuremath{\operatorname{sc}}} & = & \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (C, V_{0 \ldots n},
    R_{\ensuremath{\operatorname{sig}}})
  \end{aligned}\]
++++
where

* latexmath:[$C$] is the commitment as defined in Definition
link:#defn-grandpa-beefy-commitment[[defn-grandpa-beefy-commitment]].
* latexmath:[$V_{0 \ldots n}$] is an array where its exact size matches
the number of validators in the current authority set as specified by
latexmath:[$\ensuremath{\operatorname{id}}_{\mathbb{V}}$] in
latexmath:[$C$]. Individual items are booleans which indicate whether
the validator has signed the statement (true) or not (false). It’s
critical that the boolean indicators are sorted based on their
corresponding public key entry in the authority set.
+
 
+
For example, the boolean indicator of the validator at index 3 in the
authority set must be placed at index 3 in latexmath:[$V_n$]. This
sorting allows clients to map public keys to their corresponding boolean
indicators.
* latexmath:[$R_{\ensuremath{\operatorname{sig}}}$] is the MMR root of
the signatures in the original signed commitment as defined in
Definition
link:#defn-grandpa-beefy-signed-commitment[[defn-grandpa-beefy-signed-commitment]].

 

latexmath:[$\Box$]

 

[[chap-bootstrapping]]
== Bootstrapping

This chapter provides an overview over the tasks a Polkadot Host needs
to performs in order to join and participate in the Polkadot network.
While this chapter does not go into any new specifications of the
protocol, it has been included to provide implementors with a pointer to
what these steps are and where they are defined. In short, the following
steps should be taken by all bootstrapping nodes:

. The node needs to populate the state storage with the official Genesis
state which can be obtained from .
. The node should maintains a set of around 50 active peers at any time.
New peers can be found using the discovery protocols (Section
link:#sect-discovery-mechanism[4.4])
. The node should open and maintain the various required streams
(Section link:#sect-protocols-substreams[4.7]) with each of its active
peers.
. Furthermore, the node should send block requests (Section
link:#sect-msg-block-request[4.8.2]) to these peers to receive all
blocks in the chain and execute each of them.
. Exchange neighbor packets (Section
link:#sect-grandpa-neighbor-msg[4.8.4.3])
+
 

Validator nodes should take the following, additional steps.

. Verify that the Host’s session key is included in the current Epoch’s
authority set (Section link:#sect-authority-set[6.1.1]).
. Run the BABE lottery (Section
link:#sect-block-production[[sect-block-production]]) and wait for the
next assigned slot in order to produce a block.
. Gossip any produced blocks to all connected peers (Section
link:#sect-msg-block-announce[4.8.1]).
. Run the catch-up protocol (Section link:#sect-grandpa-catchup[6.4.1])
to make sure that the node is participating in the current round and not
a past round.
. Run the GRANDPA rounds protocol (Section link:#sect-finality[6.3]).

latexmath:[$\Box$]

 

[[chap-consensu]]
== Consensus

Consensus in the Polkadot Host is achieved during the execution of two
different procedures. The first procedure is the block-production and
the second is finality. The Polkadot Host must run these procedures if
(and only if) it is running on a validator node.

=== Common Consensus Structures

[[sect-authority-set]]
==== Consensus Authority Set

Because Polkadot is a proof-of-stake protocol, each of its consensus
engines has its own set of nodes represented by known public keys, which
have the authority to influence the protocol in pre-defined ways
explained in this Section. To verify the validity of each block, the
Polkadot node must track the current list of authorities for that block
as formalized in Definition
link:#defn-authority-list[[defn-authority-list]]

[#defn-authority-list]##[defn-authority-list]##The *authority list* of
block latexmath:[$\mathit{B}$] for consensus engine latexmath:[$C$]
noted as *latexmath:[$\ensuremath{\operatorname{Auth}}_C
  (B)$]* is an array that contains the following pair of types for each
of its authorities
latexmath:[$A \in \ensuremath{\operatorname{Auth}}_C (B)$]:

[latexmath]
++++
\[(\ensuremath{\operatorname{pk}}_A, w_A)\]
++++
latexmath:[$\ensuremath{\operatorname{pk}}_A$] is the session public key
of authority A as defined in Definition
link:#defn-session-key[[defn-session-key]]. And latexmath:[$w_A$] is a
value, indicating the authority weight. The value of
latexmath:[$\ensuremath{\operatorname{Auth}}_C (B)$] is part of the
Polkadot state. The value for
latexmath:[$\ensuremath{\operatorname{Auth}}_C (B_0)$] is set in the
genesis state (see Section link:#sect-genesis-block[11]) and can be
retrieved using a runtime entry corresponding to consensus engine
latexmath:[$C$].

In Polkadot, all authorities have the weight latexmath:[${w_A}  = 1$].
The weight latexmath:[$w_A$] in Definition
link:#defn-authority-list[[defn-authority-list]] exists for potential
improvements in the protocol and could have a use-case in the future.

[[sect-consensus-message-digest]]
==== Runtime-to-Consensus Engine Message

The authority list (see Definition
link:#defn-authority-list[[defn-authority-list]]) is part of the
Polkadot state and the Runtime has the authority to update this list in
the course of any state transitions. The Runtime informs the
corresponding consensus engine about the changes in the authority set by
adding the appropriate consensus message as defined in Definition
link:#defn-consensus-message-digest[[defn-consensus-message-digest]], in
the form of a digest item to the block header of block latexmath:[$B$]
which caused the transition in the authority set.

[#defn-consensus-message-digest]#[defn-consensus-message-digest]#
Consensus Message is a digest item of type 4 as defined in Definition
link:#defn-digest[[defn-digest]] and consists of the pair:

[latexmath]
++++
\[(E_{\ensuremath{\operatorname{id}}}, \ensuremath{\operatorname{CM}})\]
++++
Where latexmath:[$E_{\ensuremath{\operatorname{id}}} \in \mathbb{B}_4$]
is the consensus engine unique identifier which can hold the following
possible values

[latexmath]
++++
\[E_{\ensuremath{\operatorname{id}}} :=\left\{ \begin{array}{ccc}
       '' \ensuremath{\operatorname{BABE}}'' &  & \ensuremath{\operatorname{For}} \ensuremath{\operatorname{messages}} \ensuremath{\operatorname{related}}
       \ensuremath{\operatorname{to}} \ensuremath{\operatorname{BABE}} \ensuremath{\operatorname{protocol}} \ensuremath{\operatorname{referred}} \ensuremath{\operatorname{to}}
       \ensuremath{\operatorname{as}} E_{\ensuremath{\operatorname{id}}} (\ensuremath{\operatorname{BABE}})\\
       '' \ensuremath{\operatorname{FRNK}}'' &  & \ensuremath{\operatorname{For}} \ensuremath{\operatorname{messages}} \ensuremath{\operatorname{related}}
       \ensuremath{\operatorname{to}} \ensuremath{\operatorname{GRANDPA}} \ensuremath{\operatorname{protocol}} \ensuremath{\operatorname{referred}} \ensuremath{\operatorname{to}}
       \ensuremath{\operatorname{as}} E_{\ensuremath{\operatorname{id}}} (\ensuremath{\operatorname{FRNK}})
     \end{array} \right.\]
++++
and CM is of varying data type which can hold one of the types described
in Table
link:#tabl-consensus-messages-babe[[tabl-consensus-messages-babe]] or
link:#tabl-consensus-messages-grandpa[[tabl-consensus-messages-grandpa]]:
Where:

* Authlatexmath:[$_{\ensuremath{\operatorname{BABE}}}$] is the authority
list for the next epoch, as defined in definition
link:#defn-authority-list[[defn-authority-list]].
* latexmath:[$\mathcal{R}$] is the 32-byte randomness seed for the next
epoch, as defined in definition
link:#defn-epoch-randomness[[defn-epoch-randomness]]
* latexmath:[$\ensuremath{\operatorname{Auth}}_{\ensuremath{\operatorname{ID}}}$]
is an unsigned 64-bit integer pointing to an individual authority in the
current authority list.
* latexmath:[$c$] is the probability that a slot will not be empty, as
defined in definition link:#defn-babe-constant[[defn-babe-constant]]. It
is encoded as a tuple of two unsigned 64-bit integers
latexmath:[$(c_{\ensuremath{\operatorname{nominator}}}, c_{\ensuremath{\operatorname{denominator}}})$]
which are used to compute the rational latexmath:[$c =
    \frac{c_{\ensuremath{\operatorname{nominator}}}}{c_{\ensuremath{\operatorname{denominator}}}}$].
* latexmath:[$s_{2 \ensuremath{\operatorname{nd}}}$] is the second slot
configuration encoded as an 8-bit enum.

Where:

* Authlatexmath:[$_C$] is the authority list as defined in definition
link:#defn-authority-list[[defn-authority-list]].
* latexmath:[$N_{\ensuremath{\operatorname{delay}}} :=|$]SubChainlatexmath:[$(B, B') |$]
is an unsigned 32-bit integer indicating the length of the subchain
starting at latexmath:[$B$], the block containing the consensus message
in its header digest and ending when it reaches
latexmath:[$N_{\ensuremath{\operatorname{delay}}}$] length as a path
graph. The last block in that subchain, latexmath:[$B'$], depending on
the message type, is either finalized or imported (and therefore
validated by the block production consensus engine according to
Algorithm
link:#algo-import-and-validate-block[[algo-import-and-validate-block]].
See below for details).
* latexmath:[$\ensuremath{\operatorname{Auth}}_{\ensuremath{\operatorname{ID}}}$]
is an unsigned 64-bit integer pointing to an individual authority in the
current authority list.

The Polkadot Host should inspect the digest header of each block and
delegate consensus messages to their consensus engines.

The BABE consensus engine should react based on the type of consensus
messages it receives as follows:

* The Runtime issues this message on every first block of an epoch
latexmath:[$\mathcal{E}_n$]. The supplied authority set and randomness
are intended to be used in the next epoch
latexmath:[$\mathcal{E}_{n + 1}$].  
* *On Disabled*: An index to the individual authority in the current
authority list that should be immediately disabled until the next
authority set changes. When an authority gets disabled, the node should
stop performing any authority functionality for that authority,
including authoring blocks. Similarly, other nodes should ignore all
messages from the indicated authority which pertain to their authority
role.
* These messages are only issued on configuration change and in the
first block of an epoch. The supplied configuration data are intended to
be used from the next epoch onwards.

The GRANDPA consensus engine should react based on the type of consensus
messages it receives as follows:

* *Scheduled Change*: Schedule an authority set change after the given
delay of
latexmath:[$N_{\ensuremath{\operatorname{delay}}} :=|$]SubChainlatexmath:[$(B, B') |$]
where latexmath:[$B'$] in the definition of
latexmath:[$N_{\ensuremath{\operatorname{delay}}}$], is a block
_finalized_ by the finality consensus engine. The earliest digest of
this type in a single block will be respected. No change should be
scheduled if one is already finalized and the delay has not passed
completely. If such an inconsistency occurs, the scheduled change should
be ignored.
* *Forced Change*: Force an authority set change after the given delay
of
latexmath:[$N_{\ensuremath{\operatorname{delay}}} :=|$]SubChainlatexmath:[$(B, B') |$]
where latexmath:[$B'$] in the definition of
latexmath:[$N_{\ensuremath{\operatorname{delay}}}$], is an _imported_
block that has been validated by the block production consensus engine.
Hence, the authority changeset is valid for every subchain containing
_B_ and where the delay has been exceeded. If one or more blocks gets
finalized before the change takes effect, the authority set change
should be disregarded. The earliest digest of this type in a single
block will be respected. No change should be scheduled if one is already
finalized and the delay has not passed completely. If such an
inconsistency occurs, the scheduled change should be ignored.
* *On Disabled*: An index to the individual authority in the current
authority list that should be immediately disabled until the next
authority set changes. When an authority gets disabled, the node should
stop performing any authority functionality from that authority,
including authoring blocks and casting GRANDPA votes for finalization.
Similarly, other nodes should ignore all messages from the indicated
authority which pertain to their authority role.
* *Pause*: A signal to pause the current authority set after the given
delay of
latexmath:[$N_{\ensuremath{\operatorname{delay}}} :=|$]SubChainlatexmath:[$(B, B') |$]
where latexmath:[$B'$] in the definition of
latexmath:[$N_{\ensuremath{\operatorname{delay}}}$], is a block
_finalized_ by the finality consensus engine. After finalizing block
latexmath:[$B'$], the authorities should stop voting.
* *Resume*: A signal to resume the current authority set after the given
delay of
latexmath:[$N_{\ensuremath{\operatorname{delay}}} :=|$]SubChainlatexmath:[$(B, B') |$]
where latexmath:[$B'$] in the definition of
latexmath:[$N_{\ensuremath{\operatorname{delay}}}$], is an _imported_
block and validated by the block production consensus engine. After
authoring block latexmath:[$B'$], the authorities should resume voting.

The active GRANDPA authorities can only vote for blocks that occurred
after the finalized block in which they were selected. Any votes for
blocks before the came into effect would get rejected.

[[sect-babe]]
=== Block Production

[#sect-block-production]#[sect-block-production]#

The Polkadot Host uses BABE protocol for block production. It is
designed based on Ouroboros praos . BABE execution happens in sequential
non-overlapping phases known as an *_epoch_*. Each epoch on its turn is
divided into a predefined number of slots. All slots in each epoch are
sequentially indexed starting from 0. At the beginning of each epoch,
the BABE node needs to run Algorithm
link:#algo-block-production-lottery[[algo-block-production-lottery]] to
find out in which slots it should produce a block and gossip to the
other block producers. In turn, the block producer node should keep a
copy of the block tree and grow it as it receives valid blocks from
other block producers. A block producer prunes the tree in parallel by
eliminating branches that do not include the most recent finalized
blocks according to Definition
link:#defn-pruned-tree[[defn-pruned-tree]].

==== Preliminaries

A *block producer*, noted by latexmath:[$\mathcal{P}_j$], is a node
running the Polkadot Host which is authorized to keep a transaction
queue and which it gets a turn in producing blocks.

*Block authoring session key pair
latexmath:[$(\ensuremath{\operatorname{sk}}^s_j,
  \ensuremath{\operatorname{pk}}^s_j)$]* is an SR25519 key pair which
the block producer latexmath:[$\mathcal{P}_j$] signs by their account
key (see Definition link:#defn-account-key[[defn-account-key]]) and is
used to sign the produced block as well as to compute its lottery values
in Algorithm
link:#algo-block-production-lottery[[algo-block-production-lottery]].

[#defn-epoch-slot]##[defn-epoch-slot]##A block production *epoch*,
formally referred to as latexmath:[$\mathcal{E}$], is a period with a
pre-known starting time and fixed-length during which the set of block
producers stays constant. Epochs are indexed sequentially, and we refer
to the latexmath:[$n^{\ensuremath{\operatorname{th}}}$] epoch since
genesis by latexmath:[$\mathcal{E}_n$]. Each epoch is divided into
equal-length periods known as block production *slots*, sequentially
indexed in each epoch. The index of each slot is called a *slot number*.
The equal length duration of each slot is called the *slot duration* and
indicated by latexmath:[$\mathcal{T}$]. Each slot is awarded to a subset
of block producers during which they are allowed to generate a block.

Substrate refers to an epoch as ``session'' in some places, however,
epoch should be the preferred and official name for these periods.

[#note-slot]##[note-slot]##We refer to the number of slots in epoch
latexmath:[$\mathcal{E}_n$] by
latexmath:[$\ensuremath{\operatorname{sc}}_n$].
latexmath:[$\ensuremath{\operatorname{sc}}_n$] is set to the field in
the returned data from the call of the Runtime entry (see
link:#sect-rte-babeapi-epoch[13.3.8.1]) at genesis. For a given block
latexmath:[$B$], we use the notation *latexmath:[$s_B$]* to refer to the
slot during which latexmath:[$B$] has been produced. Conversely, for
slot latexmath:[$s$], latexmath:[$\mathcal{B}_s$] is the set of Blocks
generated at slot latexmath:[$s$].

Definition link:#defn-epoch-subchain[[defn-epoch-subchain]] provides an
iterator over the blocks produced during a specific epoch.

[#defn-epoch-subchain]#[defn-epoch-subchain]# By
SubChain(latexmath:[$\mathcal{E}_n$]) for epoch
latexmath:[$\mathcal{E}_n$], we refer to the path graph of
latexmath:[$\ensuremath{\operatorname{BT}}$] containing all the blocks
generated during the slots of epoch latexmath:[$\mathcal{E}_n$]. When
there is more than one block generated at a slot, we choose the one
which is also on
Longest-Chain(latexmath:[$\ensuremath{\operatorname{BT}}$]).

A block producer *equivocates* if they produce more than one block at
the same slot. The proof of equivocation are the given distinct headers
that were signed by the validator and which include the slot number.

 

The Polkadot Host must detect equivocations committed by other
validators and submit those to the Runtime as described in Section
link:#sect-babeapi_submit_report_equivocation_unsigned_extrinsic[13.3.8.6].

==== Block Production Lottery

[#defn-babe-constant]##[defn-babe-constant]##The
latexmath:[$\ensuremath{c} \in (0,
  1 )$] is the probability that a slot will not be empty and used in the
winning threshold calculation (see Definition
link:#defn-winning-threshold[[defn-winning-threshold]]).

The babe constant (Definition
link:#defn-babe-constant[[defn-babe-constant]]) is initialized at
genesis to the value returned by calling (see
link:#sect-rte-babeapi-epoch[13.3.8.1]). For efficiency reasons, it is
generally updated by the Runtime through the ``Next Config Data''
consensus message (see Definition
link:#defn-consensus-message-digest[[defn-consensus-message-digest]]) in
the digest of the first block of an epoch for the next epoch.

[#defn-winning-threshold]##[defn-winning-threshold]##The *Winning
threshold* denoted by *latexmath:[$\tau_{\varepsilon_n}$]* is the
threshold that is used alongside the result of Algorithm
link:#algo-block-production-lottery[[algo-block-production-lottery]] to
decide if a block producer is the winner of a specific slot.
latexmath:[$\tau_{\varepsilon_n}$] is calculated  as follows:

[latexmath]
++++
\[\tau_{\varepsilon_n} :=1 - (1 - c)^{\frac{1}{|
     \ensuremath{\operatorname{AuthorityDirectory}}^{\mathcal{E}_n} |}}\]
++++
where the
latexmath:[$\ensuremath{\operatorname{AuthorityDirectory}}^{\mathcal{E}_n}$]
is the set of BABE authorities for epoch latexmath:[$\varepsilon_n$] and
latexmath:[$c \in (0, 1)$] is the BABE constant as defined in definition
link:#defn-babe-constant[[defn-babe-constant]].

A block producer aiming to produce a block during
latexmath:[$\mathcal{E}_n$] should run Algorithm
link:#algo-block-production-lottery[[algo-block-production-lottery]] to
identify the slots it is awarded. These are the slots during which the
block producer is allowed to build a block. The
latexmath:[$\ensuremath{\operatorname{sk}}$] is the block producer
lottery secret key and latexmath:[$n$] is the index of the epoch for
whose slots the block producer is running the lottery.

*Algorithm*

[#algo-block-production-lottery]##[algo-block-production-lottery]##Block-production-lottery(latexmath:[$\ensuremath{\operatorname{sk}}
      :$] the session secret key of the producer,

latexmath:[$n :$] the epoch index)

For any slot latexmath:[$i$] in epoch latexmath:[$n$] where
latexmath:[$d < \tau$], the block producer is required to produce a
block. For the definitions of Epoch-Randomness and _VRF_ functions, see
Section link:#sect-epoch-randomness[6.2.5] and Section
link:#sect-vrf[9.4] respectively.

[[sect-slot-number-calculation]]
==== Slot Number Calculation

[#defn-slot-offset]##[defn-slot-offset]##Let latexmath:[$s_i$] and
latexmath:[$s_j$] be two slots belonging to epochs
latexmath:[$\mathcal{E}_k$] and latexmath:[$\mathcal{E}_l$]. By we refer
to the function whose value is equal to the number of slots between
latexmath:[$s_i$] and latexmath:[$s_j$] (counting latexmath:[$s_j$]) on
the time continuum. As such, we have Slot-Offsetlatexmath:[$(s_i,
  s_i) = 0$].

It is imperative for the security of the network that each block
producer correctly determines the current slot numbers at a given time
by regularly estimating the local clock offset in relation to the
network (Definition
link:#defn-relative-syncronization[[defn-relative-syncronization]]).

[#defn-relative-syncronization]##[defn-relative-syncronization]##The is
a tuple of a slot number and a local clock timestamp
latexmath:[$(s_{\ensuremath{\operatorname{sync}}}, t_{\ensuremath{\operatorname{sync}}})$]
describing the last point at which the slot numbers have been
synchronized with the local clock.

*Algorithm*

For now, each block producer is required to synchronize its local clock
using NTP instead. The current slot latexmath:[$s$] is then calculated
by latexmath:[$s  = t_{\ensuremath{\operatorname{unix}}} /\mathcal{T}$]
where latexmath:[$t_{\ensuremath{\operatorname{unix}}}$] is the current
UNIX time in seconds since 1970-01-01 00:00:00 UTC. That also entails
that slot numbers are currently not reset at the beginning of each
epoch.

Polkadot does this synchronization without relying on any external clock
source (e.g. through the or the ). To stay in synchronization, each
producer is therefore required to periodically estimate its local clock
offset in relation to the rest of the network.

This estimation depends on the two fixed parameters (Definition
link:#defn-prunned-best[[defn-prunned-best]]) and
latexmath:[$\ensuremath{\boldsymbol{s_{\ensuremath{\operatorname{cq}}}}}$]
(Definition link:#defn-chain-quality[[defn-chain-quality]]). These are
chosen based on the results of a formal security analysis, currently
assuming a latexmath:[$1 s$]clock drift per day and targeting a
probability lower than latexmath:[$0.5\%$] for an adversary to break
BABE in 3 years with resistance against a network delay up to
latexmath:[$1 / 3$] of the slot time and a Babe constant (Definition
link:#defn-babe-constant[[defn-babe-constant]]) of
latexmath:[$c = 0.38$].

[#defn-prunned-best]##[defn-prunned-best]##The
latexmath:[$\ensuremath{\boldsymbol{C^{┌k}}}$] is the longest chain
selected according to Definition
link:#defn-longest-chain[[defn-longest-chain]] with the last k Blocks
pruned. We chose latexmath:[$k = 140$]. The describes the last block in
this pruned best chain.

[#defn-chain-quality]##[defn-chain-quality]##The
latexmath:[$\ensuremath{\boldsymbol{s_{\ensuremath{\operatorname{cq}}}}}$]
represents the number of slots that are used to estimate the local clock
offset. Currently, it is set to
latexmath:[$s_{\ensuremath{\operatorname{cq}}} =
  3000$].

The prerequisite for such a calculation is that each producer stores the
arrival time of each block (Definition
link:#defn-block-time[[defn-block-time]]) measured by a clock that is
otherwise not adjusted by any external protocol.

[#defn-block-time]##[defn-block-time]##The *block arrival time* of block
latexmath:[$B$] for node latexmath:[$j$] formally represented by
*latexmath:[$T^j_B$]* is the local time of node latexmath:[$j$] when
node latexmath:[$j$] has received block latexmath:[$B$] for the first
time. If the node latexmath:[$j$] itself is the producer of
latexmath:[$B$], latexmath:[$T_B^j$] is set equal to the time that the
block is produced. The index latexmath:[$j$] in latexmath:[$T^j_B$]
notation may be dropped and B’s arrival time is referred to by
latexmath:[$T_B$] when there is no ambiguity about the underlying node.

{empty}[To do: Currently still lacks a clear definition of when block
arrival times are considered valid and how to differentiated imported
block on initial sync from ``fresh'' blocks that were just produced.]

[#defn-sync-period]##[defn-sync-period]##A is an interval at which each
validator (re-)evaluates its local clock offsets. The first sync period
latexmath:[$\mathfrak{E}_1$] starts just after the genesis block is
released. Consequently, each sync period latexmath:[$\mathfrak{E}_i$]
starts after latexmath:[$\mathfrak{E}_{i - 1}$]. The length of the sync
period is equal to latexmath:[$s_{\ensuremath{\operatorname{qc}}}$] as
defined in Definition link:#defn-chain-quality[[defn-chain-quality]] and
expressed in the number of slots.

All validators are then required to run Algorithm
link:#algo-slot-time[[algo-slot-time]] at the beginning of each sync
period (Definition link:#defn-sync-period[[defn-sync-period]]) to update
their synchronization using all block arrival times of the previous
period. The algorithm should only be run once all the blocks in this
period have been finalized, even if only probabilistically (Definition
link:#defn-prunned-best[[defn-prunned-best]]). The target slot to which
to synchronize should be the first slot in the new sync period.

*Algorithm*

[#algo-slot-time]##[algo-slot-time]##Median-Algorithm(latexmath:[$\mathfrak{E}_j$]:
sync period used for the estimate,
latexmath:[$s_{\ensuremath{\operatorname{sync}}} :$] slot time to
estimate)

latexmath:[$\mathcal{T}$] is the slot duration defined in Definition
link:#defn-epoch-slot[[defn-epoch-slot]].

[[block-production]]
==== Block Production

Throughout each epoch, each block producer should run Algorithm
link:#algo-block-production[[algo-block-production]] to produce blocks
during the slots it has been awarded during that epoch. The produced
block needs to carry the _BABE header_ as well as the _block signature_
as Pre-Runtime and Seal digest items defined in Definition
link:#defn-babe-header[[defn-babe-header]] and
link:#defn-block-signature[[defn-block-signature]] respectively.

[#defn-babe-header]##[defn-babe-header]##The *BABE Header* of block B,
referred to formally by
*latexmath:[$H_{\ensuremath{\operatorname{BABE}}} (B)$]* is a tuple and
consists of the following components:

[latexmath]
++++
\[(d, \pi, j, s)\]
++++
in which:

[cols=">,<",]
|===
|latexmath:[$\pi, d$]: |the results of the block lottery for slot s.

|latexmath:[$j$]: |the index of the block producer in the authority
directory of the current epoch

|s: |the slot at which the block is produced.
|===

 

 

latexmath:[$H_{\ensuremath{\operatorname{BABE}}} (B)$] must be included
as a digest item of Pre-Runtime type in the header digest
latexmath:[$H_d (B)$] as defined in Definition
link:#defn-digest[[defn-digest]].

[#defn-block-signature]##[defn-block-signature]##[#defn-babe-seal]##[defn-babe-seal]##The
*Block Signature* latexmath:[$S_B$] is a signature of the block header
hash (see
Definitionlink:#defn-block-header-hash[[defn-block-header-hash]]) and
defined as

[latexmath]
++++
\[\ensuremath{\operatorname{Sig}}_{\ensuremath{\operatorname{SR}} 25519, \ensuremath{\operatorname{sk}}^s_j} (H_h (B))\]
++++
latexmath:[$S_B$] should be included in latexmath:[$H_d (B)$] as the
Seal digest item according to Definition
link:#defn-digest[[defn-digest]] of value:

[latexmath]
++++
\[(E_{\ensuremath{\operatorname{id}}} (\ensuremath{\operatorname{BABE}}), S_B)\]
++++
in which,
latexmath:[$E_{\ensuremath{\operatorname{id}}} (\ensuremath{\operatorname{BABE}})$]
is the BABE consensus engine unique identifier defined in Definition
link:#defn-consensus-message-digest[[defn-consensus-message-digest]].
The Seal digest item is referred to as the *BABE Seal*.

 

*Algorithm*

[#algo-block-production]#[algo-block-production]#(latexmath:[$\ensuremath{\operatorname{sk}}$],
pk, latexmath:[$n$],
latexmath:[$\ensuremath{\operatorname{BT}} : \ensuremath{\operatorname{Current}} \ensuremath{\operatorname{Block}} \ensuremath{\operatorname{Tree}}$])

Add-Digest-Item appends a digest item to the end of the header digest
latexmath:[$H_d (B)$] according to Definition
link:#defn-digest[[defn-digest]].

[[sect-epoch-randomness]]
==== Epoch Randomness

[#defn-epoch-randomness]##[defn-epoch-randomness]##For epoch
latexmath:[$\mathcal{E}$], there is a 32-byte
latexmath:[$\mathcal{R}_{\mathcal{E}}$] computed based on the previous
epochs VRF outputs. For latexmath:[$\mathcal{E}_0$] and
latexmath:[$\mathcal{E}_1$], the randomness seed is provided in the
genesis state.

At the beginning of each epoch, latexmath:[$\mathcal{E}_n$] the host
will receive the randomness seed
latexmath:[$\mathcal{R}_{\mathcal{E}_{n + 1}}$](Definition
link:#defn-epoch-randomness[[defn-epoch-randomness]]) necessary to
participate in the block production lottery in the next epoch
latexmath:[$\mathcal{E}_{n + 1}$] from the Runtime, through the
consensus message (Definition
link:#defn-consensus-message-digest[[defn-consensus-message-digest]]) in
the digest of the first block.

[[sect-verifying-authorship]]
==== Verifying Authorship Right

When a Polkadot node receives a produced block, it needs to verify if
the block producer was entitled to produce the block in the given slot
by running Algorithm
link:#algo-verify-authorship-right[[algo-verify-authorship-right]]
where:

* Tlatexmath:[$_B$] is latexmath:[$B$]’s arrival time defined in
Definition link:#defn-block-time[[defn-block-time]].
* latexmath:[$H_d (B)$] is the digest sub-component of
latexmath:[$\ensuremath{\operatorname{Head}} (B)$] defined in
Definitions link:#defn-block-header[[defn-block-header]] and
link:#defn-digest[[defn-digest]].
* The Seal latexmath:[$D_s$] is the last element in the digest array
latexmath:[$H_d (B)$] as defined in Definition
link:#defn-digest[[defn-digest]].
* Seal-Id is the type index showing that a digest item of variable type
is of _Seal_ type (See Definitions
link:#defn-scale-variable-type[[defn-scale-variable-type]] and
link:#defn-digest[[defn-digest]])
* latexmath:[$\ensuremath{\operatorname{AuthorityDirectory}}^{\mathcal{E}_c}$]
is the set of Authority ID for block producers of epoch
latexmath:[$\mathcal{E}_c$].
* verify-Slot-Winner is defined in Algorithm
link:#algo-verify-slot-winner[[algo-verify-slot-winner]].

*Algorithm*

[#algo-verify-authorship-right]##[algo-verify-authorship-right]##Verify-Authorship-Right(latexmath:[$\ensuremath{\operatorname{Head}}_s
      (B)$]: The header of the block being verified)

Algorithm link:#algo-verify-slot-winner[[algo-verify-slot-winner]] runs
as a part of the verification process, when a node is importing a block,
in which:

* Epoch-Randomness is defined in Definition
link:#defn-epoch-randomness[[defn-epoch-randomness]].
* latexmath:[$H_{\ensuremath{\operatorname{BABE}}} (B)$] is the BABE
header defined in Definition link:#defn-babe-header[[defn-babe-header]].
* Verify-VRF is described in Section link:#sect-vrf[9.4].
* latexmath:[$\tau$] is the winning threshold defined in
link:#defn-winning-threshold[[defn-winning-threshold]].

*Algorithm*

[#algo-verify-slot-winner]##[algo-verify-slot-winner]##Verify-Slot-Winner(latexmath:[$B$]:
the block whose winning status to be verified)

latexmath:[$(d_B, \pi_B)$]: Block Lottery Result for Block
latexmath:[$B$],

latexmath:[$s_n$]: the slot number,

latexmath:[$n$]: Epoch index

AuthorID: The public session key of the block producer

[[sect-block-building]]
==== Block Building Process

The blocks building process is triggered by Algorithm
link:#algo-block-production[[algo-block-production]] of the consensus
engine which runs Alogrithm link:#algo-build-block[[algo-build-block]].

*Algorithm*

[#algo-build-block]##[algo-build-block]##Build-Block(latexmath:[$C_{\ensuremath{\operatorname{Best}}}$]:
The chain is where at its head, the block to be constructed, is

s: Slot number)

* latexmath:[$\ensuremath{\operatorname{Head}} (B)$] is defined in
Definition link:#defn-block-header[[defn-block-header]].
* Call-Runtime-Entry is defined in Notation
link:#nota-call-into-runtime[[nota-call-into-runtime]].
* Inherent-Data is defined in Definition
link:#defn-inherent-data[[defn-inherent-data]].
* End-Of-Slot indicates the end of the BABE slot as defined in Algorithm
link:#algo-slot-time[[algo-slot-time]] respectively Definition
link:#defn-epoch-slot[[defn-epoch-slot]].
* Next-Ready-Extrinsic indicates picking an extrinsic from the
extrinsics queue (Definition
link:#defn-transaction-queue[[defn-transaction-queue]]).
* Block-Is-Full indicates that the maximum block size is being used.
* Should-Drop determines based on the result _R_ whether the extrinsic
should be dropped or remain in the extrinsics queue and scheduled for
the next block. The as defined in Definition
link:#defn-rte-apply-extrinsic-result[[defn-rte-apply-extrinsic-result]]
describes this behavior in more detail.
* Drop indicates removing the extrinsic from the extrinsic queue
(Definition link:#defn-transaction-queue[[defn-transaction-queue]]).
* Add-Seal adds the seal to the block as defined in Definition
link:#defn-digest[[defn-digest]] before sending it to peers. The seal is
removed again before submitting it to the Runtime.

[[sect-finality]]
=== Finality

The Polkadot Host uses GRANDPA Finality protocol to finalize blocks.
Finality is obtained by consecutive rounds of voting by the validator
nodes. Validators execute GRANDPA finality process in parallel to Block
Production as an independent service. In this section, we describe the
different functions that GRANDPA service performs to successfully
participate in the block-finalization process.

==== Preliminaries

[#defn-grandpa-voter]##[defn-grandpa-voter]##A *GRANDPA Voter*,
latexmath:[$v$], represented by a key pair
latexmath:[$(k^{\ensuremath{\operatorname{pr}}}_v, v_{\ensuremath{\operatorname{id}}})$]
where latexmath:[$k_v^{\ensuremath{\operatorname{pr}}}$] represents an
latexmath:[$\ensuremath{\operatorname{ED}} 25519$] private key, is a
node running a GRANDPA protocol and broadcasting votes to finalize
blocks in a Polkadot Host-based chain. The *set of all GRANDPA voters*
for a given block B is indicated by latexmath:[$\mathbb{V}_B$]. In that
regard, we have [To do: change function name, only call at genesis,
adjust V_B over the sections]

[latexmath]
++++
\[\mathbb{V}_B = \text{\text{{\ttfamily{grandpa\_authorities}}}} (B)\]
++++
where latexmath:[$\texttt{grandpa\_authorities}$] is the entry into the
Runtime described in Section link:#sect-rte-grandpa-auth[13.3.7.1]. We
refer to latexmath:[$\mathbb{V}_B$] as latexmath:[$\mathbb{V}$] when
there is no chance of ambiguity.

Analogously we say that a Polkadot node is a *non-voter node* for block
latexmath:[$B$], if it does not own any of the key pairs in
latexmath:[$\mathbb{V}_B$].

[#defn-authority-set-id]##[defn-authority-set-id]##The *authority set
Id* (latexmath:[$\ensuremath{\operatorname{id}}_{\mathbb{V}}$]) is an
incremental counter which tracks the amount of authority list changes
that occurred (Definition
link:#defn-consensus-message-digest[[defn-consensus-message-digest]]).
Starting with the value of zero at genesis, the Polkadot Host increments
this value by one every time a *Scheduled Change* or a *Forced Change*
occurs. The authority set Id is an unsigned 64-bit integer.

*GRANDPA state*, latexmath:[$\ensuremath{\operatorname{GS}}$], is
defined as [To do: verify V_id and id_V usage, unify]

[latexmath]
++++
\[\ensuremath{\operatorname{GS}} :=\{\mathbb{V}, \ensuremath{\operatorname{id}}_{\mathbb{V}}, r\}\]
++++
where:

latexmath:[$\textbf{\ensuremath{\mathbb{V}}}$]: is the set of voters.

latexmath:[$\textbf{id\ensuremath{_{\textrm{\ensuremath{\mathbb{V}}}}}}$]:
is the authority set ID as defined in Definition
link:#defn-authority-set-id[[defn-authority-set-id]].

*r*: is the voting round number.

Following, we need to define how the Polkadot Host counts the number of
votes for block latexmath:[$B$]. First, a vote is defined as:

[#defn-vote]##[defn-vote]##A *GRANDPA vote* or simply a vote for block
latexmath:[$B$] is an ordered pair defined as

[latexmath]
++++
\[V_{} (B) :=(H_h (B), H_i (B))\]
++++
where latexmath:[$H_h (B)$] and latexmath:[$H_i (B)$] are the block hash
and the block number defined in Definitions
link:#defn-block-header[[defn-block-header]] and
link:#defn-block-header-hash[[defn-block-header-hash]] respectively.

Voters engage in a maximum of two sub-rounds of voting for each round
latexmath:[$r$]. The first sub-round is called *pre-vote* and the second
sub-round is called *pre-commit*.

By *latexmath:[$V_v^{r, \ensuremath{\operatorname{pv}}}$]* and
*latexmath:[$V_v^{r, \ensuremath{\operatorname{pc}}}$]* we refer to the
vote cast by voter latexmath:[$v$] in round latexmath:[$r$] (for block
latexmath:[$B$]) during the pre-vote and the pre-commit sub-round
respectively.

Voting is done by means of broadcasting voting messages to the network.
The structure of these messages is described in Section
link:#sect-msg-grandpa[4.8.4]. Validators inform their peers about the
block finalized in round latexmath:[$r$] by broadcasting a commit
message (see Algorithm link:#algo-grandpa-round[[algo-grandpa-round]]
for more details).

[#defn-sign-round-vote]##[defn-sign-round-vote]##*latexmath:[$\ensuremath{\operatorname{Sign}}^{r,
  \ensuremath{\operatorname{stage}}}_{v_i}$]* refers to the signature of
a voter for a specific message in a round and is formally defined as:

[latexmath]
++++
\[\ensuremath{\operatorname{Sign}}^{r, \ensuremath{\operatorname{stage}}}_{v_i} : = \ensuremath{\operatorname{Sig}}_{\ensuremath{\operatorname{ED}} 25519}
     (\ensuremath{\operatorname{msg}}, r, \ensuremath{\operatorname{id}}_{\mathbb{V}})\]
++++
Where:

 

[#defn-grandpa-justification]##[defn-grandpa-justification]##The
*justification* for block B in round latexmath:[$r$],
latexmath:[$\ensuremath{\boldsymbol{J^{r, \ensuremath{\operatorname{stage}}} (B)}}$],
is a vector of pairs of the type:

[latexmath]
++++
\[(V (B'), \ensuremath{\operatorname{Sign}}^{r, \ensuremath{\operatorname{stage}}}_{v_i} (B'), v_{\ensuremath{\operatorname{id}}})\]
++++
in which either

[latexmath]
++++
\[B' \geqslant B\]
++++
or latexmath:[$V^{r, \ensuremath{\operatorname{pc}}}_{v_i} (B')$] is an
equivocatory vote.

 

In all cases,
latexmath:[$\ensuremath{\operatorname{Sign}}^{r, \ensuremath{\operatorname{stage}}}_{v_i} (B')$],
as defined in Definition
link:#defn-sign-round-vote[[defn-sign-round-vote]], is the signature of
voter latexmath:[$v_i \in
  \mathbb{V}_B$] broadcasted during either the pre-vote (stage = pv) or
the pre-commit (stage = pc) sub-round of round r. A *valid
justification* must only contain up-to-one valid vote from each voter
and must not contain more than two equivocatory votes from each voter.

[#defn-finalizing-justification]##[defn-finalizing-justification]##We
say latexmath:[$J^{r, \ensuremath{\operatorname{pc}}} (B)$] *justifies
the finalization* of latexmath:[$B' \geqslant B$] *for a non-voter node
latexmath:[$n$]* if the number of valid signatures in
latexmath:[$J^{r, \ensuremath{\operatorname{pc}}}
  (B)$] for latexmath:[$B'$] is greater than
latexmath:[$\frac{2}{3} |\mathbb{V}_B |$].

Note that latexmath:[$J^{r, \ensuremath{\operatorname{pc}}} (B)$] can
only be used by a non-voter node to finalize a block. In contrast, a
voter node can only be assured of the finality of block latexmath:[$B$]
by actively participating in the voting process. That is by invoking
Algorithm link:#algo-grandpa-round[[algo-grandpa-round]]. See Definition
link:#defn-finalized-block[[defn-finalized-block]] for more details.

 

The GRANDPA protocol dictates how an honest voter should vote in each
sub-round, which is described in Algorithm
link:#algo-grandpa-round[[algo-grandpa-round]]. After defining what
constitutes a vote in GRANDPA, we define how GRANDPA counts votes.

[#defn-equivocation]##[defn-equivocation]##Voter latexmath:[$v$]
*equivocates* if they broadcast two or more valid votes to blocks during
one voting sub-round. In such a situation, we say that latexmath:[$v$]
is an *equivocator* and any vote
latexmath:[$V_v^{r, \ensuremath{\operatorname{stage}}} (B)$] cast by
latexmath:[$v$] in that sub-round is an *equivocatory vote*, and

[latexmath]
++++
\[\mathcal{E}^{r, \ensuremath{\operatorname{stage}}}\]
++++
represents the set of all equivocators voters in sub-round
``latexmath:[$\ensuremath{\operatorname{stage}}$]'' of round
latexmath:[$r$]. When we want to refer to the number of equivocators
whose equivocation has been observed by voter latexmath:[$v$] we refer
to it by:

[latexmath]
++++
\[\mathcal{E}^{r, \ensuremath{\operatorname{stage}}}_{\ensuremath{\operatorname{obs}} (v)}\]
++++
The Polkadot Host must detect equivocations committed by other
validators and submit those to the Runtime as described in Section
link:#sect-grandpaapi_submit_report_equivocation_unsigned_extrinsic[13.3.7.2].

A vote latexmath:[$V_v^{r, \ensuremath{\operatorname{stage}}} = V (B)$]
is *invalid* if

* latexmath:[$H (B)$] does not correspond to a valid block;
* latexmath:[$B$] is not an (eventual) descendant of a previously
finalized block;
* latexmath:[$M^{r, \ensuremath{\operatorname{stage}}}_v$] does not bear
a valid signature;
* latexmath:[$\ensuremath{\operatorname{id}}_{\mathbb{V}}$] does not
match the current latexmath:[$\mathbb{V}$];
* If latexmath:[$V_v^{r, \ensuremath{\operatorname{stage}}}$] is an
equivocatory vote.

For validator v, *the set of observed direct votes for Block
latexmath:[$B$] in round latexmath:[$r$]*, formally denoted by
latexmath:[${\ensuremath{\operatorname{VD}}^{r,
  \ensuremath{\operatorname{stage}}}_{\ensuremath{\operatorname{obs}} (v)}}^{}_{} (B)$]
is equal to the union of:

* set of [.underline]#valid# votes
latexmath:[$V^{r, \ensuremath{\operatorname{stage}}}_{v_i}$] cast in
round latexmath:[$r$] and received by v such that
latexmath:[$V^{r, \ensuremath{\operatorname{stage}}}_{v_i} = V (B)$].

[#defn-observed-votes]##[defn-observed-votes]##We refer to *the set of
total votes observed by voter latexmath:[$v$] in sub-round
``latexmath:[$\ensuremath{\operatorname{stage}}$]'' of round
latexmath:[$r$]* by
*latexmath:[${V^{r, \ensuremath{\operatorname{stage}}}_{\ensuremath{\operatorname{obs}}
  (v)}}^{}_{}$]*.

The *set of all observed votes by latexmath:[$v$] in the sub-round stage
of round latexmath:[$r$] for block latexmath:[$B$]*,
*latexmath:[$V^{r, \ensuremath{\operatorname{stage}}}_{\ensuremath{\operatorname{obs}} (v)}
  (B)$]* is equal to all of the observed direct votes cast for block
latexmath:[$B$] and all of the latexmath:[$B$]’s descendants defined
formally as:

[latexmath]
++++
\[V^{r, \ensuremath{\operatorname{stage}}}_{\ensuremath{\operatorname{obs}} (v)} (B) :=\bigcup_{v_i \in
     \mathbb{V}, B \geqslant B'} \ensuremath{\operatorname{VD}}^{r, \ensuremath{\operatorname{stage}}}_{\ensuremath{\operatorname{obs}} (v)}
     {(B')_{}^{}}_{}\]
++++
The *total number of observed votes for Block latexmath:[$B$] in round
latexmath:[$r$]* is defined to be the size of that set plus the total
number of equivocator voters:

[latexmath]
++++
\[\#V^{r, \ensuremath{\operatorname{stage}}}_{\ensuremath{\operatorname{obs}} (v)} (B) = |V^{r,
     \ensuremath{\operatorname{stage}}}_{\ensuremath{\operatorname{obs}} (v)} (B) | + | \mathcal{E}^{r,
     \ensuremath{\operatorname{stage}}}_{\ensuremath{\operatorname{obs}} (v)} |\]
++++

Note that for genesis state we always have
latexmath:[$\#V_{\ensuremath{\operatorname{obs}} (v)}^{r,
\ensuremath{\operatorname{pv}}} (B) = | \mathbb{V} |$].

[#defn-total-potential-votes]##[defn-total-potential-votes]##Let
latexmath:[$V^{r, \ensuremath{\operatorname{stage}}}_{\ensuremath{\operatorname{unobs}}
  (v)}$] be the set of voters whose vote in the given stage has not been
received. We define the *total number of potential votes for Block
latexmath:[$B$] in round latexmath:[$r$]* to be:

[latexmath]
++++
\[\#V^{r, \ensuremath{\operatorname{stage}}}_{\ensuremath{\operatorname{obv}} (v), \ensuremath{\operatorname{pot}}} (B) :=|V^{r,
     \ensuremath{\operatorname{stage}}}_{\ensuremath{\operatorname{obs}} (v)} (B) | + | V^{r,
     \ensuremath{\operatorname{stage}}}_{\ensuremath{\operatorname{unobs}} (v)} | + \ensuremath{\operatorname{Min}} \left( \frac{1}{3} |
     \mathbb{V} |, | \mathbb{V} | - |V^{r, \ensuremath{\operatorname{stage}}}_{\ensuremath{\operatorname{obs}} (v)} (B)
     | - | V^{r, \ensuremath{\operatorname{stage}}}_{\ensuremath{\operatorname{unobs}} (v)} | \right)\]
++++

The current *pre-voted* block *latexmath:[$B^{r,
  \ensuremath{\operatorname{pv}}}_v$]*also know as GRANDPA GHOST is the
block chosen by Algorithm
link:#algo-grandpa-ghost[[algo-grandpa-ghost]]:

[latexmath]
++++
\[B^{r, \ensuremath{\operatorname{pv}}}_v :=\text{{\textsc{GRANDPA-GHOS{\CYRT}}}} (r)\]
++++

Finally, we define when a voter latexmath:[$v$] sees a round as
completable, that is when they are confident that
latexmath:[$B_v^{r, \ensuremath{\operatorname{pv}}}$] is an upper bound
for what is going to be finalized in this round.

[#defn-grandpa-completable]##[defn-grandpa-completable]##We say that
round latexmath:[$r$] is *completable* if
latexmath:[$|V^{r, \ensuremath{\operatorname{pc}}}_{\ensuremath{\operatorname{obs}} (v)} |
  +\mathcal{E}^{r, \ensuremath{\operatorname{pc}}}_{\ensuremath{\operatorname{obs}} (v)} > \frac{2}{3} \mathbb{V}$]
and for all latexmath:[$B' > B_v^{r, \ensuremath{\operatorname{pv}}}$]:

[latexmath]
++++
\[\begin{array}{l}
       |V^{r, \ensuremath{\operatorname{pc}}}_{\ensuremath{\operatorname{obs}} (v)} | -\mathcal{E}^{r,
       \ensuremath{\operatorname{pc}}}_{\ensuremath{\operatorname{obs}} (v)} - |V^{r, \ensuremath{\operatorname{pc}}}_{\ensuremath{\operatorname{obs}}
       (v)_{}} (B') | > \frac{2}{3} |\mathbb{V}|
     \end{array}\]
++++

Note that in practice we only need to check the inequality for those
latexmath:[$B' >
B_v^{r, \ensuremath{\operatorname{pv}}}$] where
latexmath:[$|V^{r, \ensuremath{\operatorname{pc}}}_{\ensuremath{\operatorname{obs}} (v)_{}} (B')
| > 0$].

==== Initiating the GRANDPA State

In order to participate coherently in the voting process, a validator
must initiate its state and sync it with other active validators. In
particular, considering that voting is happening in different distinct
rounds where each round of voting is assigned a unique sequential round
number latexmath:[$r_v$], it needs to determine and set its round
counter latexmath:[$r$] equal to the voting round latexmath:[$r_n$]
currently undergoing in the network. Algorithm
link:#algo-initiate-grandpa[[algo-initiate-grandpa]] mandates the
initialization procedure for GRANDPA protocol for a joining validator.

*Algorithm*

[#algo-initiate-grandpa]##[algo-initiate-grandpa]##Initiate-Grandpa(

latexmath:[$r_{\ensuremath{\operatorname{last}}}$]: last round number
(See the following),

, latexmath:[$B_{\ensuremath{\operatorname{last}}}$]: the last block
which has been finalized on the chain (see Definition
link:#defn-finalized-block[[defn-finalized-block]])

)

latexmath:[$r_{\ensuremath{\operatorname{last}}}$] is equal to the
latest round the voter has observed that other voters are voting on. The
voter obtains this information through various gossiped messages
including those mentioned in Definition
link:#defn-finalized-block[[defn-finalized-block]].

latexmath:[$r_{\ensuremath{\operatorname{last}}}$] is set to 0 if the
GRANDPA node is initiating the GRANDPA voting process as a part of a new
authority set. This is because the GRANDPA round number reset to 0 for
every authority set change.

===== Voter Set Changes

Voter set changes are signalled by Runtime via a consensus engine
message as described in Section
link:#sect-consensus-message-digest[6.1.2]. When Authorities process
such messages they must not vote on any block with a higher number than
the block at which the change is supposed to happen. The new authority
set should reinitiate GRANDPA protocol by executing Algorithm
link:#algo-initiate-grandpa[[algo-initiate-grandpa]].

==== Voting Process in Round latexmath:[$r$]

For each round latexmath:[$r$], an honest voter latexmath:[$v$] must
participate in the voting process by following Algorithm
link:#algo-grandpa-round[[algo-grandpa-round]].

*Algorithm*

{empty}[#algo-grandpa-round]##[algo-grandpa-round]##Play-Grandpa-roundlatexmath:[$(r)$]

Where:

* latexmath:[$T$] is sampled from a log-normal distribution whose mean
and standard deviation are equal to the average network delay for a
message to be sent and received from one validator to another.
* Derive-Primary is described in Algorithm
link:#algo-derive-primary[[algo-derive-primary]].
* The condition of _completablitiy_ is defined in Definition
link:#defn-grandpa-completable[[defn-grandpa-completable]].
* Best-Final-Candidate function is explained in Algorithm
link:#algo-grandpa-best-candidate[[algo-grandpa-best-candidate]].
* Attempt-To-Finalize-Round(latexmath:[$r$]) is described in Algorithm
link:#algo-attempt-tofinalize[[algo-attempt-tofinalize]].
* Finalizabl is defined in Algorithm
link:#algo-finalizable[[algo-finalizable]].

*Algorithm*

[#algo-derive-primary]##[algo-derive-primary]##Derive-Primary(latexmath:[$r$]:
the GRANDPA round whose primary to be determined)

latexmath:[$\mathbb{V}$] is the GRANDPA voter set as defined in
Definition link:#defn-grandpa-voter[[defn-grandpa-voter]].

*Algorithm*

[#algo-grandpa-best-candidate]##[algo-grandpa-best-candidate]##Best-Final-Candidate(latexmath:[$r$])

latexmath:[$\#V^{r, \ensuremath{\operatorname{stage}}}_{\ensuremath{\operatorname{obv}} (v), \ensuremath{\operatorname{pot}}}$]
is defined in Definition
link:#defn-total-potential-votes[[defn-total-potential-votes]].

*Algorithm*

[#algo-grandpa-ghost]##[algo-grandpa-ghost]##GRANDPA-GHOST(latexmath:[$r$])

Where

* latexmath:[$B_{\ensuremath{\operatorname{last}}}$] is the last block
which has been finalized on the chain (see Definitin
link:#defn-finalized-block[[defn-finalized-block]])
* latexmath:[$\#V_{\ensuremath{\operatorname{obs}} (v)}^{r, \ensuremath{\operatorname{pv}}} (B)$]
is defined in Definition
link:#defn-observed-votes[[defn-observed-votes]].

*Algorithm*

Best-PreVote-Candidate(latexmath:[$r$]: voting round to cast the
pre-vote in)

*Algorithm*

[#algo-finalizable]##[algo-finalizable]##Finalizable(latexmath:[$r :$]voting
round)

The condition of _completablitiy_ is defined in Definition
link:#defn-grandpa-completable[[defn-grandpa-completable]].

*Algorithm*

[#algo-attempt-tofinalize]##[algo-attempt-tofinalize]##Attempt-To-Finalize-Round(latexmath:[$r$])

Note that we might not always succeed in finalizing our best final
candidate due to the possibility of equivocation. Example
link:#exmp-candid-unfinalized[[exmp-candid-unfinalized]] serves to
demonstrate such a situation:

[#exmp-candid-unfinalized]##[exmp-candid-unfinalized]##Let us assume
that we have 100 voters and there are two blocks in the chain
(latexmath:[$B_1 < B_2$]). At round 1, we get 67 pre-votes for
latexmath:[$B_2$] and at least one pre-vote for latexmath:[$B_1$] which
means that GRANDPA-GHOST(1) = latexmath:[$B_2$].

Subsequently, potentially honest voters who could claim not seeing all
the pre-votes for latexmath:[$B_2$] but receiving the pre-votes for
latexmath:[$B_1$] would pre-commit to latexmath:[$B_1$]. In this way, we
receive 66 pre-commits for latexmath:[$B_1$] and 1 pre-commit for
latexmath:[$B_2$]. Henceforth, we finalize latexmath:[$B_1$] since we
have a threshold commit (67 votes) for latexmath:[$B_1$].

At this point, though, we have
Best-Final-Candidate(latexmath:[$r$])latexmath:[$= B_2$] as
latexmath:[$\#V^{r, \ensuremath{\operatorname{stage}}}_{\ensuremath{\operatorname{obv}} (v), \ensuremath{\operatorname{pot}}} (B_2) = 67$]
and latexmath:[$2 >
  1$].

However, at this point, the round is already completable as we know that
we have GRANDPA-GHOST(1) = latexmath:[$B_2$] as an upper limit on what
we can finalize and nothing greater than latexmath:[$B_2$] can be
finalized at latexmath:[$r = 1$]. Therefore, the condition of Algorithm
link:#algo-grandpa-round[[algo-grandpa-round]]:14 is satisfied and we
must proceed to round 2.

Nonetheless, we must continue to attempt to finalize round 1 in the
background as the condition of
link:#algo-attempt-tofinalize[[algo-attempt-tofinalize]]:3 has not
been fulfilled.

This prevents us from proceeding to round 3 until either:

* We finalize latexmath:[$B_2$] in round 2, or
* We receive an extra pre-commit vote for latexmath:[$B_1$] in round 1.
This will make it impossible to finalize latexmath:[$B_2$] in round 1,
no matter to whom the remaining pre-commits are going to be cast for
(even with considering the possibility of 1/3 of voter equivocating) and
therefore we have
Best-Final-Candidate(latexmath:[$r$])latexmath:[$= B_1$].

Both scenarios unblock the Algorithm
link:#algo-grandpa-round[[algo-grandpa-round]]:14
Last-Finalized-Blocklatexmath:[$\geqslant$]Best-Final-Candidate(latexmath:[$r$]-1))
albeit in different ways: the former with increasing the
Last-Finalized-Block and the latter with decreasing
Best-Final-Candidate(latexmath:[$r$]-1).

[[sect-block-finalization]]
=== Block Finalization

[#defn-finalized-block]##[defn-finalized-block]##A Polkadot relay chain
node latexmath:[$n$] should consider block latexmath:[$B$] as
*finalized* if any of the following criteria hold for
latexmath:[$B' \geqslant B$]:

* latexmath:[${V^{r, \ensuremath{\operatorname{pc}}}_{\ensuremath{\operatorname{obs}} (n)}}^{}_{} (B') >
    2 / 3 |\mathbb{V}_{B'} |$].
* it receives a
latexmath:[$M_v^{r, \ensuremath{\operatorname{Fin}}} (B')$] message in
which latexmath:[$J^r (B)$] justifies the finalization (according to
Definition
link:#defn-grandpa-justification[[defn-grandpa-justification]]).
* it receives a block data message for latexmath:[$B'$] with
latexmath:[$\ensuremath{\operatorname{Just}} (B')$] defined in Section
link:#sect-justified-block-header[3.3.1.2] which justifies the
finalization.

for

* any round latexmath:[$r$] if the node latexmath:[$n$] is _not_ a
GRANDPA voter.
* only for rounds latexmath:[$r$] for which the node latexmath:[$n$] has
invoked Algorithm link:#algo-grandpa-round[[algo-grandpa-round]] if
latexmath:[$n$] is a GRANDPA voter.

Note that all Polkadot relay chain nodes are supposed to process GRANDPA
commit messages regardless of their GRANDPA voter status.

[[sect-grandpa-catchup]]
==== Catching up

When a Polkadot node (re)joins the network during the process described
in Chapter link:#chap-bootstrapping[5], it requests the history of state
transition in the form of blocks, which it is missing. Each finalized
block comes with the Justification of its finalization as defined in
Definition
link:#defn-grandpa-justification[[defn-grandpa-justification]]. Through
this process, they can synchronize the authority list currently
performing the finalization process.

===== Sending the catch-up requests

[#sect-sending-catchup-request]#[sect-sending-catchup-request]#

When a Polkadot node has the same authority list as a peer node who is
reporting a higher number for the ``finalized round'' field, it should
send a catch-up request message, as specified in Definition
link:#defn-grandpa-catchup-request-msg[[defn-grandpa-catchup-request-msg]],
to the reporting peer in order to catch-up to the more advanced
finalized round, provided that the following criteria hold:

* the peer node is a GRANDPA voter, and
* the last known finalized round for the Polkadot node is at least 2
rounds behind the finalized round for the peer.

===== Processing the catch-up requests

Only GRANDPA voter nodes are required to respond to the catch-up
responses. When a GRANDPA voter node receives a catch-up request message
it needs to execute Algorithm
link:#algo-process-catchup-request[[algo-process-catchup-request]].

*Algorithm*

[#algo-process-catchup-request]##[algo-process-catchup-request]##ProcessCatchupRequest(

latexmath:[$M_{i, v}^{\ensuremath{\operatorname{Cat}} - q} (\ensuremath{\operatorname{id}}_{\mathbb{V}}, r)$]:
The catch-up message received from peer latexmath:[$i$] (See Definition
link:#defn-grandpa-catchup-request-msg[[defn-grandpa-catchup-request-msg]])

)

In which:

* latexmath:[$\ensuremath{\operatorname{id}}_{\mathbb{V}}$] is the voter
set id with which the serving node is operating
* latexmath:[$r$] is the round number for which the catch-up is
requested for.
* latexmath:[$\mathbb{P}$] is the set of immediate peers of node
latexmath:[$v$].
* Last-Completed-Round is [To do: define:
https://github.com/w3f/polkadot-spec/issues/161]
* latexmath:[$M_{v, i}^{\ensuremath{\operatorname{Cat}} - s} (\ensuremath{\operatorname{id}}_{\mathbb{V}}, r)$]
is the catch-up response defined in Definition
link:#defn-grandpa-catchup-response-msg[[defn-grandpa-catchup-response-msg]].

===== Processing catch-up responses

A Catch-up response message contains critical information for the
requester node to update their view on the active rounds which are being
voted on by GRANDPA voters. As such, the requester node should verify
the content of the catch-up response message and subsequently updates
its view of the state of the finality of the Relay chain according to
Algorithm
link:#algo-process-catchup-response[[algo-process-catchup-response]].

*Algorithm*

[#algo-process-catchup-response]#[algo-process-catchup-response]#
Process-Catchup-Response(

latexmath:[$M_{v, i}^{\ensuremath{\operatorname{Cat}} - s} (\ensuremath{\operatorname{id}}_{\mathbb{V}}, r)$]:
the catch-up response received from node latexmath:[$v$] (See Definition
link:#defn-grandpa-catchup-response-msg[[defn-grandpa-catchup-response-msg]])

)

[[sect-grandpa-beefy]]
=== Bridge design (BEEFY)

{empty}[To do: NOTE: The BEEFY protocol is currently in early
development and subject to change]

 

The BEEFY (Bridge Effiency Enabling Finality Yielder) is a secondary
protocol to GRANDPA to support efficient bridging between the Polkadot
network (relay chain) and remote, segregated blockchains, such as
Ethereum, which were not built with the Polkadot interchain operability
in mind. The protocol allows participants of the remote network to
verify finality proofs created by the Polkadot relay chain validators.
In other words: clients in the Ethereum network should able to verify
that the Polkadot network is at a specific state.

 

Storing all the information necessary to verify the state of the remote
chain, such as the block headers, is too expensive. BEEFY stores the
information in a space-efficient way and clients can request additional
information over the protocol.

==== Preliminaries

Merkle Mountain Ranges, *MMR*, as defined in Definition [To do: TODO]
are used as an efficient way to send block headers and signatures to
light clients.

[#defn-beefy-statement]##[defn-beefy-statement]##The *statement* is the
same piece of information which every relay chain validator is voting
on. Namely, the MMR root of all the block header hashes leading up to
the latest, finalized block.

*[#defn-beefy-witness-data]##[defn-beefy-witness-data]##Witness data*
contains the statement as defined in Definition
link:#defn-beefy-statement[[defn-beefy-statement]], an array indicating
which validator of the Polkadot network voted for the statement (but not
the signatures themselves) and a MMR root of the signatures. The
indicators of which validator voted for the statement are just claimes
and provide no proofs . The network message is defined in Definition
link:#defn-grandpa-beefy-signed-commitment-witness[[defn-grandpa-beefy-signed-commitment-witness]]
and the relayer saves it on the chain of the remote network.

[#defn-beefy-light-client]##[defn-beefy-light-client]##A *light client*
is an abstract entity in a remote network such as Ethereum. It can be a
node or a smart contract with the intent of requesting finality proofs
from the Polkadot network. A light client reads the witness data as
defined in Definition
link:#defn-beefy-witness-data[[defn-beefy-witness-data]] from the chain,
then requests the signatures directly from the relayer in order to
verify those.

 

The light client is expected to know who the validators are and has
access to their public keys.

[#defn-beefy-relayer]##[defn-beefy-relayer]##A *relayer* (or ``prover'')
is an abstract entity which takes finality proofs from the Polkadot
network and makes those available to the light clients. Inherently, the
relayer tries to convince the light clients that the finality proofs
have been voted for by the Polkadot relay chain validators. The relayer
operates offchain and can for example be a node or a collection of
nodes.

==== Voting on Statements

The Polkadot Host signs a statement as defined in Definition
link:#defn-beefy-statement[[defn-beefy-statement]] and gossips it as
part of a vote as defined in Definition
link:#defn-msg-beefy-gossip[[defn-msg-beefy-gossip]] to its peers on
every new, finalized block. The Polkadot Host uses ECDSA for signing the
statement, since Ethereum has better compatibility for it compared to
SR25519 or ED25519. [To do: how does one map the validator set keys to
the corresponding ECDSA keys?]

[[sect-beefy-committing-witnesses]]
==== Committing Witnesses

The relayer as defined in Definition
link:#defn-beefy-relayer[[defn-beefy-relayer]] participates in the
Polkadot network by collecting the gossiped votes as defined in
Definition link:#defn-msg-beefy-gossip[[defn-msg-beefy-gossip]]. Those
votes are converted into the witness data structure as defined in
Definition link:#defn-beefy-witness-data[[defn-beefy-witness-data]]. and
the relayer saves the data on the chain of the remote network. The
occurrence of saving witnesses on remote networks is undefined.

 

How the witness data is saved on the remote chain varies among networks
or implementations. On Ethereum, for example, the relayer could call a
smart contract which saves the witness data on chain and light clients
can fetch this data.

 

{empty}[To do: Add note about 2/3 majority]

==== Requesting Signed Commitments

A light client as defined in Definition
link:#defn-beefy-light-client[[defn-beefy-light-client]] fetches the
witness data as defined in Definition
link:#defn-beefy-witness-data[[defn-beefy-witness-data]] from the chain.
Once the light client knows which validators apparently voted for the
specified statement, it needs to request the signatures from the relayer
to verify whether the claims are actually true. This is achieved by
requesting signed commitments as defined in Definition
link:#defn-grandpa-beefy-signed-commitment[[defn-grandpa-beefy-signed-commitment]].

How those signed commitments are requested by the light client and
delivered by the relayer varies among networks or implementations. On
Ethereum, for example, the light client can request the signed
commitments in form of a transaction, which results in a response in
form of a transaction. [To do: If the signed commitments are just
transactions, which are stored in the blockchain, why bother with
witnesses?]

 

latexmath:[$\Box$]

 

 

== Availability & Validity

=== Introduction

As clarified in Chapter 1, Polkadot serves as a replicated shared-state
machine designed to resolve scalability issues and interoperability
among blockchains. The validators of Polkadot execute transactions and
participate in the consensus of Polkadots primary chain, the so called
_relay chain_. _Parachains_ are independent networks that maintain their
own state and are connected to the relay chain. Those parachains can
take advantage of the relay chain consensus mechanism, including sending
and receiving messages to and from other parachains. Parachain nodes
that send parachain blocks, known as _candidates_, to the validators in
order to be inlcuded in relay chain are referred to as _collators_.

 

The Polkadot relay chain validators are responsible for guaranteeing the
validity of both relay chain and parachain blocks. Additionally, the
validators are required to keep enough parachain blocks that should be
included in the relay chain available in their local storage in order to
make those retrievable by peers, who lack the information, to reliably
confirm the issued validity statements about parachain blocks. The
Availability & Validity (AnV) protocol consists of multiple steps for
successfully upholding those responsibilities.

 

Parachain blocks themselves are produced by collators as described in
Section link:#sect-collations[7.3], whereas the relay chain validators
only verify their validity (and later, their availability). It is
possible that the collators of a parachain  produces multiple parachain
block candidates for a child of a specific block. Subsequently, they
send the block candadiates to the the relay chain validators who are
assigned to the specific parachain. The assignment is determined by the
Runtime as described in Section link:#sect-candidate-backing[7.4]. Those
validators are then required to check the validity of submitted
candidates as described in Section link:#sect-candidate-validation[7.5],
then issue and collect statements about the validity of candidates to
other validators as described in Section
link:#sect-candidate-backing-statements[7.4.1]. This process is known as
_candidate backing_. Once a candidate meets a specified criteria for
inclusion, the selected relay chain block author then choses any of the
backed candidate for each parachain and includes those into the relay
chain block as described in Section
link:#sect-candidate-inclusion[7.4.2].

 

Every relay chain validator must fetch the proposed candidates and issue
votes on whether they have the candidate saved in their local storage,
so called _availability votes_ as described in Section
link:#sect-availability-votes[7.6.1], then also collect the votes sent
by other validators and include them in the relay chain state, as
described in Section link:#sect-candidate-inclusion[7.4.2]. This process
ensures that only relay chain blocks get finalized where each candidate
is available on enough nodes of validators.

 

Parachain candidates contained in _non-finalized_ (Section
link:#sect-finality[6.3]) relay chain blocks must then be retrieved by a
secondary set of relay chain validators, unrelated from the candidate
backing process, who are randomly assigned to determine the validity of
specific parachains based on a VRF lottery and are then required to vote
on the validity of those candidates as described in Section
link:#sect-approval-voting[7.7]. This process is known as _approval
voting_. If a validator does not have the candidate data, it must
recover the candidate data as described in Section
link:#sect-availability-recovery[7.6.2].

=== Preliminaries

A *collator* is a parachain node that sends parachain blocks, known as
candidates as defined in Definition
link:#defn-candidate[[defn-candidate]], to the relay chain validators.
The relay chain validators are not concerned how the collator works or
how it creates candidates.

[#defn-candidate]##[defn-candidate]##A *candidate* is a submitted
parachain block as defined in Definition
link:#defn-parablock[[defn-parablock]] to the relay chain validators. A
parachain block stops being referred to as a candidate as soon it has
been finalized.

[#defn-parablock]##[defn-parablock]##A *parachain block* or a
*Proof-of-Validity block* (PoV block) contains the necessary data to for
parachain specific state transition logic. Relay chain validators are
not concerned with the inner structure of the block and treat it as a
byte array.

[#defn-para-head-data]##[defn-para-head-data]##The *head data* is
contains information about a parachain block as defined in Definition
link:#defn-parablock[[defn-parablock]]. The head data is returned by
executing the parachain Runtime and relay chain validators are not
concerned with its inner structure and treat it as a byte arrays.

[#defn-para-id]##[defn-para-id]##The *Parachain Id* is a unique,
unsigned 32-bit integer which serves as an identifier of a parachain,
assigned by the Runtime.

*[#defn-availability-cores]##[defn-availability-cores]##Availability
cores* are slots used to process parachains. The Runtime assigns each
parachain to a availability core and validators can fetch information
about the cores, such as parachain block candidates, by calling the
appropriate Runtime API as described in Section
link:#sect-rt-api-availability-cores[7.8.3]. Validators are not
concerned with the internal workings from the Runtimes perspective.

*[#defn-validator-groups]##[defn-validator-groups]##Validator groups*
indicate which validators are responsible for creating backable
candidates for certain parachains, as described in Section
link:#sect-candidate-backing[7.4], and are assigned by the Runtime.
Validators are not concerned with the internal workings from the
Runtimes perspective. Collators can use this information for submitting
blocks.

[#defn-upward-message]##[defn-upward-message]##An *upward message* is an
opaque byte array sent from a parachain to a relay chain.

[#defn-downward-message]##[defn-downward-message]##A *downward message*
is an opaque byte array received by the parachain from the relay chain.

[#defn-outbound-hrmp-message]##[defn-outbound-hrmp-message]##An
*outbound HRMP message* (Horizontal Relay-routed Message Passing) is
sent from the perspective of a sender of a parachain to an other
parachain by passing it through the relay chain. It’s a datastructure of
the following format:

[latexmath]
++++
\[\begin{aligned}
    & (I, M) & 
  \end{aligned}\]
++++
where latexmath:[$I$] is the recipient Id as defined in Definition
link:#defn-para-id[[defn-para-id]] and latexmath:[$M$] is an upward
message as defined in Definition
link:#defn-upward-message[[defn-upward-message]].

[#defn-inbound-hrmp-message]##[defn-inbound-hrmp-message]##An *inbound
HRML message* (Horizontal Relay-routed Message Passing) is seen from the
perspective of a recipient parachain sent from an other parachain by
passing it through the relay chain. It’s a datastructure of the
following format:

[latexmath]
++++
\[\begin{aligned}
    & (N, M) & 
  \end{aligned}\]
++++
where latexmath:[$N$] is the relay chain block number at which the
message was passed down to the recipient parachain and latexmath:[$M$]
is a downward message as defined in Definition
link:#defn-downward-message[[defn-downward-message]].

[[sect-collations]]
=== Collations

Collations are proposed candidates (see Definition
link:#defn-candidate[[defn-candidate]]) to the Polkadot relay chain
validators. The Polkodat network protocol is agnostic on what candidate
productionis mechanism each parachain uses and does not specify or
mandate any of such production methods (e.g. BABE-GRANDPA, Aura, etc).
Furthermore, the relay chain validator host implementation itself does
not directly interpret or process teh internal transactions of the
candidate, but rather rely on the parachain Runtime to validate the
candidate, as described in Section link:#sect-candidate-validation[7.5].
Collators, which are parachain nodes which produce candidate proposals
and send them to the relay chain validator, must prepare pieces of data
specified in Definition link:#defn-collation[[defn-collation]] in order
to correctly comply with the requirements of the parachain protocol.

[#defn-collation]##[defn-collation]##A *collation* is a datastructure
which contains the proposed parachain candidate, including an optional
validation parachain Runtime update and upward messages. The collation
datastructure, latexmath:[$C$], is a datastructure of the following
format:

[latexmath]
++++
\[\begin{aligned}
    C & = & (M, H, R, h, P, p, w)\\
    M & = & (u_n, \ldots u_m)\\
    H & = & (z_n, \ldots z_m)
  \end{aligned}\]
++++
where

* latexmath:[$M$] is an array of upward messages, latexmath:[$u$],
interpreted by the relay chain itself, as defined in Definition
link:#defn-upward-message[[defn-upward-message]].
* latexmath:[$H$] is an array of outbound horizontal messages,
latexmath:[$z$], interpreted by other parachains, as defined in
Definition
link:#defn-outbound-hrmp-message[[defn-outbound-hrmp-message]]
* latexmath:[$R$] is an type as defined in Definition
link:#defn-option-type[[defn-option-type]] which can contain a parachain
Runtime update. The new Runtime code is an array of bytes.
* latexmath:[$H$] is the head data as defined in Definition
link:#defn-para-head-data[[defn-para-head-data]] produced as a result of
execution of the parachain specific logic.
* latexmath:[$P$] is the PoV block as defined in Definition
link:#defn-pov-block[[defn-pov-block]].
* latexmath:[$p$] is an unsigned 32-bit integer indicating the number of
downward messages processed as defined in Definition
link:#defn-downward-message[[defn-downward-message]].
* latexmath:[$w$] is an unsigned 32-bit integer indicating the mark up
to which all inbound HRMP messages have been processed by the parachain.

[[sect-candidate-backing]]
=== Candidate Backing

The Polkadot validator receives an arbitrary number of parachain
candidates with associated proofs from untrusted collators. The
validator must verify and select a specific quantity of the proposed
candidates and issue those as _backable_ candidates to its peers. A
candidate is considered _backable_ when at least latexmath:[$2 / 3$] of
all assigned validators have issued a statement about that candidate, as
described in Section link:#sect-candidate-backing-statements[7.4.1].
Validators can retrieve information about assignments via the Runtime
APIs link:#sect-rt-api-validator-groups[7.8.2] respectively
link:#sect-rt-api-availability-cores[7.8.3].

[[sect-candidate-backing-statements]]
==== Statements

The assigned validator checks the validity of the proposed parachains
blocks as described in Section link:#sect-candidate-validation[7.5] and
issues statements as defined in Definition
link:#net-msg-full-statement[[net-msg-full-statement]] to its peers if
the verification succeeded. Broadcasting failed verification as
statements is a slashable offense. The validator must only issue one
statement, based on an arbitrary metric, which implies an explicit vote
for a candidate to be included in the relay chain.

 

{empty}[To do: reference disputes]

 

This protocol attempts to produce as many backable candidates as
possible, but does not attempt to determine a final candidate for
inclusion. Once a parachain candidate has been seconded by at least one
other validator and enough statements have been issued about that
candidate to meet the latexmath:[$2 / 3$] quorum, the candidate is ready
to be inlcuded in the relay chain as described in Section
link:#sect-candidate-inclusion[7.4.2].

 

The validator issues validity statements votes in form of a validator
protocol message as defined in Definition
link:#net-msg-collator-protocol-message[[net-msg-collator-protocol-message]].

[#net-msg-full-statement]##[net-msg-full-statement]##A *statement*,
latexmath:[$S$], is a datastructure of the following format:

[latexmath]
++++
\[\begin{aligned}
    S & = & (d, A_i, A_s)\\
    d & = & \left\{\begin{array}{l}
      1 \rightarrow C_r\\
      2 \rightarrow C_h
    \end{array}\right.
  \end{aligned}\]
++++
where

* latexmath:[$d$] is a varying datatype where latexmath:[$1$] indicates
that the validator ``seconds'' a candidate, meaning that the candidate
should be included in the relay chain, followed by the committed
candidate receipt, latexmath:[$C_r$], as defined in Definition
link:#defn-committed-candidate-receipt[[defn-committed-candidate-receipt]].
latexmath:[$2$] indicates that the validator has deemed the candidate
valid, followed by the candidate hash.
* latexmath:[$C_h$] is the candidate hash.
* latexmath:[$A_i$] is the validator index in the authority set that
signed this statement.
* latexmath:[$A_s$] is the signature of the validator.

[#defn-bitfield-array]##[defn-bitfield-array]##A *bitfield array*
contains single-bit values which indidate whether a candidate is
available. The number of items is equal of to the number of availability
cores as defined in Definition
link:#defn-availability-cores[[defn-availability-cores]] and each bit
represents a vote on the corresponding core in the given order.
Respectively, if the single bit equals , then the Polkadot validator
claims that the availability core is occupied, there exists a committed
candidate receipt as defined in Definition
link:#defn-committed-candidate-receipt[[defn-committed-candidate-receipt]]
and that the validator has a stored chunk of the parachain block as
defined in Definition link:#sect-availability-recovery[7.6.2].

[[sect-candidate-inclusion]]
==== Inclusion

The Polkadot validator includes the backed candidates as inherent data
as defined in Definition
link:#defn-parachain-inherent-data[[defn-parachain-inherent-data]] into
a block as described in Section link:#sect-inherents[3.2.3]. The relay
chain block author decides on whatever metric which candidate should be
selected for inclusion, as long as that candidate is valid and meets the
validity quorum of latexmath:[$2 / 3 +$] as described in Section
link:#sect-candidate-backing-statements[7.4.1]. The candidate approval
process as described in Section link:#sect-approval-voting[7.7] ensures
that only relay chain blocks are finalized where each candidate for each
availability core meets the requirement of 2/3+ availability votes.

[#defn-parachain-inherent-data]##[defn-parachain-inherent-data]##The
*parachain inherent data* contains backed candidates and is included
when authoring a relay chain block. The datastructure, latexmath:[$I$],
is of the following format:

[latexmath]
++++
\[\begin{aligned}
    I & = & (A, T, D, P_h)\\
    T & = & (C_0, \ldots C_n)\\
    D & = & (d_n, \ldots d_m)\\
    C & = & (R, V, i)\\
    V & = & (a_n, \ldots a_m)\\
    a & = & \left\{\begin{array}{l}
      1 \rightarrow s\\
      2 \rightarrow s
    \end{array}\right.\\
    A & = & (L_n, \ldots L_m)\\
    L & = & (b, v_i, s)
  \end{aligned}\]
++++
where

* latexmath:[$A$] is an array of signed bitfields by validators claiming
the candidate is available (or not). The array must be sorted by
validator index corresponding to the authority set as described in
Section link:#defn-authority-list[[defn-authority-list]].
* latexmath:[$T$] is an array of backed candidates for inclusing in the
current block.
* latexmath:[$D$] is an array of disputes.
* latexmath:[$P_h$] is the parachain parent head data as defined in
Definition link:#defn-para-head-data[[defn-para-head-data]].
* latexmath:[$d$] is a dispute statement as described in Section
link:#sect-anv-disputes[7.7.3].
* latexmath:[$R$] is a committed candidate receipt as defined in
Definition
link:#defn-committed-candidate-receipt[[defn-committed-candidate-receipt]].
* latexmath:[$V$] is an array of validity votes themselves, expressed as
signatures.
* latexmath:[$i$] is a bitfield of indices of the validators within the
validator group as defined in Definition
link:#defn-validator-groups[[defn-validator-groups]].
* latexmath:[$a$] is either an implicit or explicit attestation of the
validity of a parachain candidate, where latexmath:[$1$] implies an
implicit vote (in correspondence of a statement) and latexmath:[$2$]
implies an explicit attestation (in correspondence of a statement). Both
variants are followed by the signature of the validator.
* latexmath:[$s$] is the signature of the validator.
* latexmath:[$b$] the availability bitfield as described in Section
link:#sect-availability-votes[7.6.1].
* latexmath:[$v_i$] is the validator index of the authority set as
defined in Definition link:#defn-authority-list[[defn-authority-list]].

[#defn-candidate-receipt]##[defn-candidate-receipt]##A *candidate
receipt*, R, contains information about the candidate and a proof of the
results of its execution. It’s a datastructure of the following format:

[latexmath]
++++
\[\begin{aligned}
    R & = & (D, C_h)
  \end{aligned}\]
++++
where latexmath:[$D$] is the candidate descriptor as defined in
Definition link:#defn-candidate-descriptor[[defn-candidate-descriptor]]
and latexmath:[$C_h$] is the hash of candidate commitments as defined in
Definition
link:#defn-candidate-commitments[[defn-candidate-commitments]].

[#defn-committed-candidate-receipt]##[defn-committed-candidate-receipt]##The
*committed candidate receipt*, latexmath:[$R$], contains information
about the candidate and the the result of its execution that is included
in the relay chain. This type is similiar to the candidate receipt as
defined in Definition
link:#defn-candidate-receipt[[defn-candidate-receipt]], but actually
contains the execution results rather than just a hash of it. It’s a
datastructure of the following format:

[latexmath]
++++
\[\begin{aligned}
    R & = & (D, C)
  \end{aligned}\]
++++
where latexmath:[$D$] is the candidate descriptor as defined in
Definition link:#defn-candidate-descriptor[[defn-candidate-descriptor]]
and C is the candidate commitments as defined in Definition
link:#defn-candidate-commitments[[defn-candidate-commitments]].

[#defn-candidate-descriptor]##[defn-candidate-descriptor]##The
*candidate descriptor*, latexmath:[$D$], is a unique descriptor of a
candidate receipt. It’s a datastructure of the following format:

[latexmath]
++++
\[\begin{aligned}
    D & = & (p, H, C_i, V, B, r, s, p_h, R_h)
  \end{aligned}\]
++++
where

* latexmath:[$p$] is the parachain Id as defined in Definition
link:#defn-para-id[[defn-para-id]].
* latexmath:[$H$] is the hash of the relay chain block the candidate is
executed in the context of.
* latexmath:[$C_i$] is the collators public key.
* latexmath:[$V$] is the hash of the persisted validation data as
defined in Definition
link:#defn-persisted-validation-data[[defn-persisted-validation-data]].
* latexmath:[$B$] is the hash of the PoV block.
* latexmath:[$r$] is the root of the block’s erasure encoding Merkle
tree. [To do: clarify]
* latexmath:[$s$] the collator signature of the concatenated components
latexmath:[$p$], latexmath:[$H$], latexmath:[$R_h$] and latexmath:[$B$].
* latexmath:[$p_h$] is the hash of the parachain head data as described
in Definition link:#defn-para-head-data[[defn-para-head-data]] of this
candidate.
* latexmath:[$R_h$] is the hash of the parachain Runtime.

The [#defn-candidate-commitments]#[defn-candidate-commitments]#,
latexmath:[$C$], is the result of the execution and validation of a
parachain (or parathread) candidate whose produced values must be
committed to the relay chain. Those values are retrieved from the
validation result as defined in Definition
link:#defn-validation-result[[defn-validation-result]]. A candidate
commitment is a datastructure of the following format:

[latexmath]
++++
\[\begin{aligned}
{2}
    C & = (M\ensuremath{_{\textrm{u}}},M\ensuremath{_{\textrm{h}}},R,h,p,w)
  \end{aligned}\]
++++

where:

* latexmath:[$M_u$] is an array of upward messages sent by the
parachain. Each individual message, latexmath:[$m$], is an array of
bytes.
* latexmath:[$M_h$] is an array of outbound horizontal messages sent by
the parachain. Each individual messages, latexmath:[$t$], is a
datastructure as defined in Definition
link:#defn-outbound-hrmp-message[[defn-outbound-hrmp-message]].
* latexmath:[$R$] is an value as described in Section
link:#defn-option-type[[defn-option-type]] that can contain a new
parachain Runtime in case of an update.
* latexmath:[$h$] is the parachain head data as described in Definition
link:#defn-para-head-data[[defn-para-head-data]].
* latexmath:[$p$] is a unsigned 32-bit intiger indicating the number of
downward messages that were processed by the parachain. It is expected
that the parachain processes the messages from frist to last.
* latexmath:[$w$] is a unsigned 32-bit integer indicating the watermark
which specifies the relay chain block number up to which all inbound
horizontal messages have been processed.

[[sect-candidate-validation]]
=== Candidate Validation

Received candidates submitted by collators and must have its validity
verified by the assigned Polkadot validators. For each candidate to be
valid, the validator must successfully verify the following condidations
in the following order:

[arabic]
. The candidate does not exceed any parameters in the persisted
validation data as defined in Definition
link:#defn-persisted-validation-data[[defn-persisted-validation-data]].
. The signature of the collator is valid.
. Validate the candidate by executing the parachain Runtime as defined
in Definition link:#sect-parachain-runtime[7.5.1].

If all steps are valid, the Polkadot validator must create the necessary
candidate commitments as defined in Definition
link:#defn-candidate-commitments[[defn-candidate-commitments]] and
submit the appropriate statement for each candidate as described in
Section link:#sect-candidate-backing-statements[7.4.1].

[[sect-parachain-runtime]]
==== Parachain Runtime

Parachain Runtimes are stored in the relay chain state, and can either
be fetched by the parachain Id or the Runtime hash via the relay chain
Runtime API as described in Section
link:#sect-rt-api-validation-code[7.8.7] and
link:#sect-rt-api-validation-code-by-hash[7.8.8] respectively. The
retrieved parachain Runtime might need to be decompressed based on the
magic identifier as described in Section
link:#sect-runtime-compression[7.5.2].

 

In order to validate a parachain block, the Polkadot validator must
prepare the validation parameters as defined in Definition
link:#defn-validation-parameters[[defn-validation-parameters]], then use
its local Wasm execution environment as described in Section
link:#sect-code-executor[3.1.2] to execute the parachain Runtime API by
passing on the validation parameters as an argument. The parachain
Runtime function returns the validation result as defined in Definition
link:#defn-validation-result[[defn-validation-result]].

[#defn-validation-parameters]##[defn-validation-parameters]##The
*validation parameters* structure, latexmath:[$P$], is required to
validate a candidate against a parachain Runtime. It’s a datastructure
of the following format:

[latexmath]
++++
\[\begin{aligned}
    P & = & (h, b, B_i, S_r)
  \end{aligned}\]
++++
where

* latexmath:[$h$] is the parachain head data as defined in Definition
link:#defn-para-head-data[[defn-para-head-data]].
* latexmath:[$b$] is the block body as defined in Definition
link:#defn-parablock[[defn-parablock]].
* latexmath:[$B_i$] is the latest relay chain block number.
* latexmath:[$S_r$] is the relay chain block storage root as defined in
Definition link:#sect-merkl-proof[2.1.4].

[#defn-validation-result]##[defn-validation-result]##The *validation
result* is returned by the parachain Runtime API after attempting to
validate a parachain block. Those results are then used in candidate
commitments as defined in Definition link:#sect-merkl-proof[2.1.4].,
which then will be inserted into the relay chain via the parachain
inherent data as described in Definition
link:#defn-parachain-inherent-data[[defn-parachain-inherent-data]]. The
validation result, V, is a datastructure of the following format:

[latexmath]
++++
\[\begin{aligned}
    V & = & (h, R, M_u, M_h, p , w)\\
    M_u & = & (m_0, \ldots m_n)\\
    M_h & = & (t_0, \ldots t_n)
  \end{aligned}\]
++++
where

* latexmath:[$h$] is the parachain head data as defined in Definition
link:#defn-para-head-data[[defn-para-head-data]].
* latexmath:[$R$] is an value as described in Section
link:#defn-option-type[[defn-option-type]] that can contain a new
parachain Runtime in case of an update.
* latexmath:[$M_u$] is an array of upward messages sent by the
parachain. Each individual message, latexmath:[$m$], is an array of
bytes.
* latexmath:[$M_h$] is an array of outbound horizontal messages sent by
the parachain. Each individual message, latexmath:[$t$], is a
datastructure as defined in Definition
link:#defn-outbound-hrmp-message[[defn-outbound-hrmp-message]].
* latexmath:[$p$] is a unsigned 32-bit integer indicating the number of
downward messages that were processed by the parachain. It is expected
that the parachain processes the messages from first to last.
* latexmath:[$w$] is a unsigned 32-bit integer indicating the watermark
which specifies the relay chain block number up to which all inbound
horizontal messages have been processed.

[[sect-runtime-compression]]
==== Runtime Compression

{empty}[To do: todo]

=== Availability

[[sect-availability-votes]]
==== Availability Votes

The Polkadot validator must issue a bitfield as defined in Definition
link:#defn-bitfield-array[[defn-bitfield-array]] which indicates votes
for the availabilty of candidates. Issued bitfields can be used by the
validator and other peers to determine which backed candidates meet the
latexmath:[$2 / 3 +$] availability quorum.

 

Candidates are inserted into the relay chain in form of inherent data by
a block author, as described in Section
link:#sect-candidate-inclusion[7.4.2]. A validator can retrieve that
data by calling the appropriate Runtime API entry as described in
Section link:#sect-rt-api-availability-cores[7.8.3], then create a
bitfield indicating for which candidate the validator has availability
data stored and broadcast it to the network as defined in Definition
link:#net-msg-bitfield-dist-msg[[net-msg-bitfield-dist-msg]]. When
sending the bitfield distrubtion message, the validator must ensure
latexmath:[$B_h$] is set approriately, therefore clarifying to which
state the bitfield is referring to, given that candidates can vary based
on the chain fork.

 

Missing availability data of candidates must be recovered by the
validator as described in Section
link:#sect-availability-recovery[7.6.2]. If previously issued bitfields
are no longer accurate, i.e. the availability data has been recovered or
the candidate of an availablity core has changed, the validator must
create a new bitfield and boradcast it to the network. Candidates must
be kept available by validators for a specific amount of time. If a
candidate does not receive any backing, validators should keep it
available for about one hour, in case the state of backing does change.
Backed and even approved candidates (described in Section
link:#sect-approval-voting[7.7]) must be kept by validators for about 25
hours, since disputes (described in Section [To do: todo]) can occure
and the candidate needs to be checked again.

 

The validator issues availability votes in form of a validator protocol
message as defined in Definition
link:#net-msg-collator-protocol-message[[net-msg-collator-protocol-message]].

[[sect-availability-recovery]]
==== Candidate Recovery

The availability distribution of the Polkadot validator must be able to
recover parachain candidates that the validator is assigned to, in order
to determine whether the candidate should be backed as described in
Section link:#sect-candidate-backing[7.4] repsectively whether the
candidate should be approved as described in Section
link:#sect-approval-voting[7.7]. Additionally, peers can send
availability requests as defined in Definition
link:#net-msg-chunk-fetching-request[[net-msg-chunk-fetching-request]]
and Definition
link:#net-msg-available-data-request[[net-msg-available-data-request]]
to the validator, which the validator should be able to respond to.

 

Candidates are recovered by sending requests for specific indices of
erasure encoded chunks. Erasure encoding is described in Section [To do:
todo]. A validator should request chunks by picking peers randomly and
must recover at least latexmath:[$f + 1$] chunks, where
latexmath:[$n = 3 f + k$] and latexmath:[$k \in \{ 1, 2, 3 \}$].
latexmath:[$n$] is the number of validators as specified in the session
info, which can be fetched by the Runtime API as described in Section
link:#sect-rt-api-session-info[7.8.11].

[[sect-approval-voting]]
=== Approval Voting

The approval voting process ensures that only valid parachain blocks are
finalized on the relay chain. After _backable_ parachain candidates were
submitted to the relay chain, as described in Section
link:#sect-candidate-inclusion[7.4.2], which can be retrieved by the
Runtime API as described in Section
link:#sect-rt-api-availability-cores[7.8.3], validators need to
determine their assignments for each parachain and issue approvals for
valid candidates, respectively disputes for invalid candidates. Since it
cannot be expected that each validator verifies every single parachain
candidate, this mechanism ensures that enough honest validators are
selected to verify parachain candidates in order prevent the
finalization of invalid blocks. If an honest validator detects an
invalid block which was approved by one or more validators, the honest
validator must issue a disputes which wil cause escalations, resulting
in consequences for all malicious parties, i.e. slashing. This mechanism
is described more in Section
link:#sect-availability-assingment-criteria[7.7.1].

[[sect-availability-assingment-criteria]]
==== Assignment Criteria

Validators determine their assignment based on a VRF mechanism, similiar
to the BABE consensus mechanism. First, validators generate an
availability core VRF assignment as defined in Definition
link:#defn-aval-core-vrf-assignment[[defn-aval-core-vrf-assignment]],
which indicates which availability core a validator is assigned to. Then
a _delayed_ availability core VRF assignment is generated which
indicates at what point a validator should start the approval process.
The delays are based on ``tranches'', as described in Section
link:#defn-tranches[7.7.2].

 

An assigned validator never broadcasts their assignment until relevant.
Once the assigned validator is ready to check a candidate, the validator
broadcasts their assignment by issuing an approval distribution message
as defined in Definition
link:#net-msg-approval-distribution[[net-msg-approval-distribution]],
where latexmath:[$M$] is of variant latexmath:[$0$]. Other assigned
validators that receive that network message must keep track of if,
expecting an approval vote following shortly after. Assigned validators
can retrieve the candidate by using the availability recovery as
described in Section link:#sect-availability-recovery[7.6.2] and then
validate the candidate as described in Section
link:#sect-candidate-validation[7.5].

 

The validator issues approval votes in form of a validator protocol
message as defined in Definition
link:#net-msg-validator-protocol-message[[net-msg-validator-protocol-message]]
and disputes as described in Section link:#sect-anv-disputes[7.7.3].

[[defn-tranches]]
==== Tranches

Validators use a subjective, tick-based system to determine when the
approval process should start. A validator starts the tick-based system
when a new availability core candidates have been proposed, which can be
retrieved via the Runtime API as described in Section
link:#sect-rt-api-availability-cores[7.8.3], and increments the tick
every 500 Milliseconds. Each tick/increment is referred to as a
``tranche'', represented as an integer, starting at latexmath:[$0$].

 

As described in Section
link:#sect-availability-assingment-criteria[7.7.1], the validator first
executes the VRF mechanism to determine which parachains (availability
cores) the validator is assigned to, then an additional VRF mechanism
for each assigned parachain to determine the _delayed assignment_. The
delayed assignment indicites the tranche at which the validator should
start the approval process. A tranche of value 0 implies that the
assignment should be started immediately, while later assignees of later
tranches wait until it’s their term to issue assignments, determined by
their subjective, tick-based system.

 

Validators are required to track broadcasted assignments by other
validators assigned to the same parachain, including verifying the VRF
output. Once a valid assignment from a peer was received, the validator
must wait for the following approval vote within a certain period as
described in Section link:#sect-rt-api-session-info[7.8.11] by orienting
itself on its local, tick-based system. If the waiting time after a
broadcasted assignment exceeds the specified period, the validator
interprets this behavior as a ``no-show'', indicating that more
validators should commit on their tranche until enough approval votes
have been collected.

 

If enough approval votes have been collected as described in Section
link:#sect-rt-api-session-info[7.8.11], then assignees of later tranches
do not have to start the approval process. Therefore, this tranche
system serves as a mechanism to ensure that enough candidate approvals
from a _random_ set of validators are created without requiring all
assigned validators to check the candidate.

 

{empty}[To do: TODO: Move all VRF related definitions to the VRF
sections]

[#defn-relay-vrf-story]##[defn-relay-vrf-story]##The *relay VRF story*
is an array of random bytes derived from the VRF submitted within the
block by the block author. The relay VRF story, latexmath:[$T$], is used
as input to determine approval voting criteria and generated the
following way:

[latexmath]
++++
\[\begin{aligned}
    T & = & \text{{\textsc{Transcript{\textsc{}}}}} (b_r, b_s, e_i, A)
  \end{aligned}\]
++++
where

* Transcript constructs a VRF transcript as defined in Definition [To
do: todo].
* latexmath:[$b_r$] is the BABE randomness of the current epoch as
defined in Definition [To do: todo].
* latexmath:[$b_s$] is the current BABE slot as defined in Definition
[To do: todo].
* latexmath:[$e_i$] is the current BABE epoch index as defined in
Definition [To do: todo].
* A is the public key of the authority.

[#defn-aval-core-vrf-assignment]##[defn-aval-core-vrf-assignment]##An
*availability core VRF assignment*, latexmath:[$T$], is computed by a
relay chain validator to determine which availability core as defined in
Definition link:#defn-availability-cores[[defn-availability-cores]] a
validator is assigned to and should vote for approvals. The assignment
consits of a VRF pair, latexmath:[$v$], as defined in Definition
link:#defn-vrf-pair[[defn-vrf-pair]] and a VRF proof, latexmath:[$p$],
as defined in Definition link:#defn-vrf-proof[[defn-vrf-proof]]:

[latexmath]
++++
\[\begin{aligned}
    T & = & (v, p)
  \end{aligned}\]
++++
The Runtime dictates how many assignments should be conducted by a
validator, as specified in the session index which can be retrieved via
the Runtime API as described in Section
link:#sect-rt-api-session-info[7.8.11]. The amount of assignments is
referred to as ``samples''. For each iteration of the number of samples,
the validator calculates an individual assignment, latexmath:[$T$],
where the little-endian encoded sample number, latexmath:[$S$], is
incremented by one. At the beginning of the iteration, latexmath:[$S$]
starts at value latexmath:[$0$].

 

The validator executes the following steps to retrieve a (possibly
valid) core index:

[latexmath]
++++
\[\begin{aligned}
    t & \leftarrow & \text{{\textsc{Create-Transcript}}} \left(
    \text{\textsuperscript{''}A\&V MOD\textsuperscript{''}} \right)\\
    t & \leftarrow & \text{{\textsc{Meta-Ad}}} \left( t \text{,
    \textsuperscript{''}RC-VRF\textsuperscript{''}}, R_s \right)\\
    t & \leftarrow & \textsc{\text{Meta-Ad}} \left( t \text{,
    \textsuperscript{''}sample\textsuperscript{''}}, S \right)\\
    e & \leftarrow & \textsc{\text{Evaluate-VRF}} (s_k, t)\\
    b & \leftarrow & \text{{\textsc{Make-Bytes}}} \left( e, 4 \text{,
    \textsuperscript{''}A\&V CORE\textsuperscript{''}} \right)\\
    c_i & \leftarrow & \text{{\textsc{LE}}} (b) \ensuremath{\operatorname{mod}} a_c
  \end{aligned}\]
++++
where

* Create-Transcript is a function defined in Definition
link:#defn-vrf-create-transcript[[defn-vrf-create-transcript]].
* Meta-Ad is a function defined in Definition [To do: todo].
* Evaluate-VRF is a function defined in Definition
link:#defn-vrf-evaluate-vrf[[defn-vrf-evaluate-vrf]].
* LE implies that the 4-byte input is converted to a little-endian
encoded 32-bit interger.
* Make-Bytes is a function defined in Definition
link:#defn-vrf-make-bytes[[defn-vrf-make-bytes]].
* latexmath:[$R_s$] is the relay VRF story as defined in Definition
link:#defn-relay-vrf-story[[defn-relay-vrf-story]].
* latexmath:[$s_k$] is the secret key of the validator.
* latexmath:[$a_c$] is the number of availablity cores used during the
active session, as defined in the session info retrieved by the Runtime
API as defined in Definition link:#sect-rt-api-session-info[7.8.11].

The resulting integer, latexmath:[$c_i$], indicates the parachain Id as
defined in Definition link:#defn-para-id[[defn-para-id]]. If the Id
doesn’t exist, as can be retrieved by the Runtime API as described in
Section link:#sect-rt-api-availability-cores[7.8.3], the validator
discards that value and continues with the next iteration. If the Id
does exist, the validators continues with the following steps:

[latexmath]
++++
\[\begin{aligned}
    t & \leftarrow & \text{{\textsc{Create-Transcript}}} \left(
    \text{\textsuperscript{''}A\&V ASSIGNED\textsuperscript{''}} \right)\\
    t & \leftarrow & \text{{\textsc{Meta-Ad}}} \left( t \text{,
    \textsuperscript{''}core\textsuperscript{''}}, c_i \right)\\
    (p, \ensuremath{\boldsymbol{\phi}}) & \leftarrow & \textsc{\text{DLEQ-Proove}} (s_k, t,
    e)\\
    T & = & (e, p)
  \end{aligned}\]
++++
where DLEQ-Proove is a function defined in Definition
link:#defn-vrf-dleq-proove[[defn-vrf-dleq-proove]]. Hence, the full list
of available core VRF assignments is represtend as:

[latexmath]
++++
\[\begin{aligned}
    & \{ T_n, \ldots, T_m \} & 
  \end{aligned}\]
++++
where each latexmath:[$T_x$] corresponds to a sample number. The amount
of individual assignments does not necessarily equal the number of
samples, but the amount must not exceed the number of samples.

[#defn-delayed-aval-core-vrf-assignment]##[defn-delayed-aval-core-vrf-assignment]##The
*delayed availability core VRF assignments* determined at what point a
validator should start the approval process as described in Section
link:#defn-tranches[7.7.2]. The validator executes the following steps:

[latexmath]
++++
\[\begin{aligned}
    t & \leftarrow & \text{{\textsc{Create-Transcript}}} \left(
    \text{\textsuperscript{''}A\&V DELAY\textsuperscript{''}} \right)\\
    t & \leftarrow & \text{{\textsc{Meta-Ad}}} (t,'' \ensuremath{\operatorname{RC}} - \ensuremath{\operatorname{VRF}}'',
    R_s)\\
    t & \leftarrow & \text{{\textsc{Meta-Ad}}} (t,'' \ensuremath{\operatorname{core}}'', c_i)\\
    e & \leftarrow & \text{{\textsc{Evaluate-VRF}}} (s_k, t )\\
    t  & \leftarrow & \text{{\textsc{Create-Transcript}}} ('' \ensuremath{\operatorname{VRF}}'')\\
    (p, x) & \leftarrow & \text{{\textsc{DLEQ-Proove}}} (s_k, t, e)
  \end{aligned}\]
++++
The resulting values latexmath:[$e$] and latexmath:[$p$] are the VRF
pair as defined in Definition link:#defn-vrf-pair[[defn-vrf-pair]]
respectively the VRF proof as defined in Definition
link:#defn-vrf-proof[[defn-vrf-proof]].

 

The *tranche*, latexmath:[$d$], is determined as:

[latexmath]
++++
\[\begin{aligned}
    b & = & \text{{\textsc{Make-Bytes}}} \left( e, 4,'' \text{A\&V TRANCHE}''
    \right)\\
    d & = & \ensuremath{\operatorname{LE}} (b) \ensuremath{\operatorname{mod}} (d_c + d_z) - d_z
  \end{aligned}\]
++++
where

* Make-Bytes is a function defined in Definition
link:#defn-vrf-make-bytes[[defn-vrf-make-bytes]].
* LE implies that the 4-byte input is converted to a little-endian
encoded 32-bit interger.
* latexmath:[$d_c$] is the number of delayed tranches by total as
specified by the session info, retrieved via the Runtime API as
described in Section link:#sect-rt-api-session-info[7.8.11].
* latexmath:[$d_z$] is the zeroth delay tranche width as specified by
the session info, retrieved via the Runtime API as described in Section
link:#sect-rt-api-session-info[7.8.11].

The resulting tranche, latexmath:[$n$], cannot be less than
latexmath:[$0$]. If the tranche is less than latexmath:[$0$], then
latexmath:[$d = 0$].

[#defn-vrf-pair]##[defn-vrf-pair]##The *VRF Pair* is a datastructure
that contains both the VRV input and its corresponding output.

{empty}[#defn-vrf-proof]##[defn-vrf-proof]##The *VRF proof* and *VRF
batchable proof* ... [To do: todo] [To do: does batchable proof need to
be specced?]

{empty}[#defn-vrf-transcript]##[defn-vrf-transcript]##The *transcript*
... [To do: todo]

{empty}[#defn-vrf-evaluate-vrf]##[defn-vrf-evaluate-vrf]##The
Evaluate-VRF function takes a public key, latexmath:[$k$], a transcript,
latexmath:[$t$], as defined in Definition
link:#defn-vrf-transcript[[defn-vrf-transcript]] and procudes a
VRF-Pair, latexmath:[$p$], as defined in Definition
link:#defn-vrf-pair[[defn-vrf-pair]].

[latexmath]
++++
\[\begin{aligned}
    p & \leftarrow & \textsc{\text{Evaluate-VRF}} (k, t)
  \end{aligned}\]
++++
The functions executes the following steps: [To do: todo]

{empty}[#defn-vrf-dleq-proove]##[defn-vrf-dleq-proove]##The DLEQ-Proove
function takes a private key, latexmath:[$s_k$], and a transcript,
latexmath:[$t$], as defined in Definition
link:#defn-vrf-transcript[[defn-vrf-transcript]] and a VRF pair,
latexmath:[$v$], as defined in Definition
link:#defn-vrf-pair[[defn-vrf-pair]] and produces a VRF proof and a VRF
batchable proof, latexmath:[$p$] respectively latexmath:[$p_b$], as
defined in Definition link:#defn-vrf-proof[[defn-vrf-proof]].

[latexmath]
++++
\[\begin{aligned}
    (p, p_b) & \leftarrow & \text{{\textsc{DLEQ-Proove}}} (s_k, t, v)
  \end{aligned}\]
++++
The functions executed the following steps: [To do: todo]

{empty}[#defn-vrf-create-transcript]##[defn-vrf-create-transcript]##The
Create-Transcript function takes a context, latexmath:[$c$], represented
as a UTF-8 encoded string and produces a transcript, latexmath:[$t$], as
defined in Definition link:#defn-vrf-transcript[[defn-vrf-transcript]].

[latexmath]
++++
\[\begin{aligned}
    t & \leftarrow & \text{{\textsc{Create-Transcript}}} (c)
  \end{aligned}\]
++++
The function executes the following steps: [To do: todo]

[#defn-vrf-make-bytes]##[defn-vrf-make-bytes]##The Make-Bytes function
takes a VRF Pair, latexmath:[$p$], as defined in Definition
link:#defn-vrf-pair[[defn-vrf-pair]], the size of the buffer in bytes,
latexmath:[$s$], and a context, latexmath:[$c$], represtended as a UTF-8
encoded string and produces the raw byte output of the VRF.

[latexmath]
++++
\[\begin{aligned}
    b & \leftarrow & \text{{\textsc{Make-Bytes}}} (p, s, c)
  \end{aligned}\]
++++

[[sect-anv-disputes]]
==== Disputes

{empty}[To do: TODO]

=== Runtime Api

[[sect-rt-api-validators]]
==== validators

Returns the validator set at the current state. The specified validators
are responsible for backing parachains for the current state.

 

*Arguments*

* None.

*Return*

* An array of public keys representing the validators.

[[sect-rt-api-validator-groups]]
==== validator_groups

Returns the validator groups as defined in Definition
link:#defn-validator-groups[[defn-validator-groups]] used during the
current session. The validators in the groups are referred to by the
validator set Id as defined in Definition
link:#defn-authority-list[[defn-authority-list]].

 

*Arguments*

* None

*Return*

* An array of tuples, latexmath:[$T$], of the following format:
+
[latexmath]
++++
\[\begin{aligned}
    T & = & (I, G)\\
    I & = & (v_n, \ldots v_m)\\
    G & = & (B_s, f, B_c)
  \end{aligned}\]
++++
where
** latexmath:[$I$] is an array the validator set Ids as defined in
Definition link:#defn-authority-list[[defn-authority-list]].
** latexmath:[$B_s$] indicates the block number where the session
started.
** latexmath:[$f$] indicates how often groups rotate. latexmath:[$0$]
means never.
** latexmath:[$B_c$] indicates the current block number.

[[sect-rt-api-availability-cores]]
==== availability_cores

Returns information on all availability cores as defined in Definition
link:#defn-availability-cores[[defn-availability-cores]].

 

*Arguments*

* None

*Return*

* An array of core states, latexmath:[$S$], of the following format:
+
[latexmath]
++++
\[\begin{aligned}
    S & = & \left\{\begin{array}{l}
      0 \rightarrow C_o\\
      1 \rightarrow C_s\\
      2 \rightarrow \ensuremath{\boldsymbol{\phi}}
    \end{array}\right.\\
    C_o & = & (n_u, B_o, B_t, n_t, b, G_i, C_h, C_d)\\
    C_s & = & (P_{\ensuremath{\operatorname{id}}}, C_i)
  \end{aligned}\]
++++
where
** latexmath:[$S$] specifies the core state. latexmath:[$0$] indicates
that the core is occupied, latexmath:[$1$] implies it’s currently free
but scheduled and given the opportunity to occupy and latexmath:[$2$]
implies it’s free and there’s nothing scheduled.
** latexmath:[$n_u$] is an as described in Definition
link:#defn-option-type[[defn-option-type]] which can contain a
latexmath:[$C_s$] value if the core was freed by the Runtime and
indicates the assignment that is next scheduled on this core. An empty
value indicates there is nothing scheduled.
** latexmath:[$B_o$] indicates the relay chain block number at which the
core got occupied.
** latexmath:[$B_t$] indicates the relay chain block number the core
will time-out at, if any.
** latexmath:[$n_t$] is an as described in Definition
link:#defn-option-type[[defn-option-type]] which can contain a
latexmath:[$C_s$] value if the core is freed by a time-out and indicates
the assignment that is next scheduled on this core. An empty value
indicates there is nothing scheduled.
** latexmath:[$b$] is a bitfield array as defined in Definition
link:#defn-bitfield-array[[defn-bitfield-array]]. A
latexmath:[$> 2 / 3$] majority of assigned validators voting with
latexmath:[$1$] values means that the core is available.
** latexmath:[$G_i$] indicates the assigned validator group index as
defined in Definition
link:#defn-validator-groups[[defn-validator-groups]] is to distribute
availability pieces of this candidate.
** latexmath:[$C_h$] indicates the hash of the candidate occypying the
core.
** latexmath:[$C_d$] is the candidate descriptor as defined in
Definition link:#defn-candidate-descriptor[[defn-candidate-descriptor]].
** latexmath:[$C_i$] is an as described in Definition
link:#defn-option-type[[defn-option-type]] which can contain the
collators public key indicating who should author the block.

[[sect-rt-api-persisted-validation-data]]
==== persisted_validation_data

Returns the persistend validation data for the given parachain Id and a
given occupied core assumption.

 

*Arguments*

* The parachain Id as defined in Definition
link:#defn-para-id[[defn-para-id]].
* An occupied core assumption as defined in Definition
link:#defn-occupied-core-assumption[[defn-occupied-core-assumption]].

*Return*

* An as described in Definition
link:#defn-option-type[[defn-option-type]] which can contain the
persisted validation data as defined in Definition
link:#defn-persisted-validation-data[[defn-persisted-validation-data]].
The value is empty if the parachain Id is not registered or the core
assumption is of index latexmath:[$2$], meaning that the core was freed.

[#defn-occupied-core-assumption]##[defn-occupied-core-assumption]##A
*occupied core assumption* is used for fetching certain pieces of
information about a parachain by using the relay chain API. The
assumption indicates how the Runtime API should compute the result. [To
do: how does the node make assumptions?] The assumptions,
latexmath:[$A$], is a varying datatype of the following format:

[latexmath]
++++
\[\begin{aligned}
    A & = & \left\{\begin{array}{l}
      0 \rightarrow \ensuremath{\boldsymbol{\phi}}\\
      1 \rightarrow \ensuremath{\boldsymbol{\phi}}\\
      2 \rightarrow \ensuremath{\boldsymbol{\phi}}
    \end{array}\right.
  \end{aligned}\]
++++
where latexmath:[$0$] indicates that the candidate occupying the core
was made available and included to free the core, latexmath:[$1$]
indicates that it timed-out and freed the core without advancing the
parachain and latexmath:[$2$] indicates that the core was not occuped to
begin with.

[#defn-persisted-validation-data]##[defn-persisted-validation-data]##The
*persisted validation data* provides information about how to create the
inputs for the validation of a candidate by calling the Runtime. This
information is derived from the parachain state and will vary from
parachain to parachain, although some of the fields may be the same for
every parachain. This validation data acts as a way to authorize the
additional data (such as messages) the collator needs to pass to the
validation function.

 

The persisted validation data,
latexmath:[$D_{\ensuremath{\operatorname{pv}}}$], is a datastructure of
the following format:

[latexmath]
++++
\[\begin{aligned}
    D_{\ensuremath{\operatorname{pv}}} & = & (P_h, H_i, H_r, m_b)
  \end{aligned}\]
++++
where

* latexmath:[$P_h$] is the parent head data as defined in Definition
link:#defn-para-head-data[[defn-para-head-data]].
* latexmath:[$H_i$] is the relay chain block number this is in the
context of.
* latexmath:[$H_r$] is the relay chain storage root this is in the
context of.
* latexmath:[$m_b$] is the maximum legal size of the PoV block, in
bytes.

The persisted validation data is fetched via the Runtime API as
described in Section link:#sect-rt-api-persisted-validation-data[7.8.4].

==== check_validation_outputs

Checks if the given validation outputs pass the acceptence criteria.

 

*Arguments*

* The parachain Id as defined in Definition
link:#defn-para-id[[defn-para-id]].
* The candidate commitments as defined in Definition
link:#defn-candidate-commitments[[defn-candidate-commitments]].

*Return*

* A boolean indicating whether the candidate commitments pass the
acceptence criteria.

==== session_index_for_child

Returns the session index that is expected at the child of a block. [To
do: clarify session index]

 

*Arguments*

* None

*Return*

* A unsigned 32-bit integer representing the session index.

[[sect-rt-api-validation-code]]
==== validation_code

Fetches the validation code (Runtime) of a parachain by parachain Id.

 

*Arguments*

* The parachain Id as defined in Definition
link:#defn-para-id[[defn-para-id]].
* The occupied core assumption as defined in Definition
link:#defn-occupied-core-assumption[[defn-occupied-core-assumption]].

*Return*

* An value as defined in Definition
link:#defn-option-type[[defn-option-type]] containing the full
validation code in an byte array. This value is empty if the parachain
Id cannot be found or the assumption is wrong.

[[sect-rt-api-validation-code-by-hash]]
==== validation_code_by_hash

Returns the validation code (Runtime) of a parachain by its hash.

 

*Arguments*

* The hash value of the validation code.

*Return*

* An value as defined in Definition
link:#defn-option-type[[defn-option-type]] containing the full
validation code in an byte array. This value is empty if the parachain
Id cannot be found or the assumption is wrong.

==== candidate_pending_availability

Returns the receipt of a candidate pending availability for any
parachain assigned to an occupied availabilty core.

 

*Arguments*

* The parachain Id as defined in Definition
link:#defn-para-id[[defn-para-id]].

*Return*

* An value as defined in Definition
link:#defn-option-type[[defn-option-type]] containing the committed
candidate receipt as defined in Definition
link:#defn-candidate-receipt[[defn-candidate-receipt]]. This value is
empty if the given parachain Id is not assigned to an occupied
availability cores.

==== candidate_events

Returns an array of candidate events that occured within the lastest
state.

 

*Arguments*

* None

*Return*

* An array of single candidate events, latexmath:[$E$], of the following
format:
+
[latexmath]
++++
\[\begin{aligned}
    E & = & \left\{\begin{array}{l}
      0 \rightarrow d\\
      1 \rightarrow d\\
      2 \rightarrow (C_r, h, I_c)
    \end{array}\right.\\
    d & = & (C_r, h, I_c, G_i)
  \end{aligned}\]
++++
where
** latexmath:[$E$] specifies the the event type of the candidate.
latexmath:[$0$] indicates that the candidate receipt was backed in the
latest relay chain block, latexmath:[$1$] indicates that it was included
and became a parachain block at the latest relay chain block and
latexmath:[$2$] indicates that the candidate receipt was not made
available and timed-out.
** latexmath:[$C_r$] is the candidate receipt as defined in Definition
link:#defn-candidate-receipt[[defn-candidate-receipt]].
** latexmath:[$h$] is the parachain head data as defined in Definition
link:#defn-para-head-data[[defn-para-head-data]].
** latexmath:[$I_c$] is the index of the availabilty core as can be
retrieved in Section link:#sect-rt-api-availability-cores[7.8.3] that
the candidate is occupying. If latexmath:[$E$] is of variant
latexmath:[$2$], then this indicates the core index the candidate _was_
occupying.
** latexmath:[$G_i$] is the group index as defined in Definition
link:#defn-validator-groups[[defn-validator-groups]] that is responsible
of backing the candidate.

[[sect-rt-api-session-info]]
==== session_info

Get the session info of the given session, if available.

 

*Arguments*

* The unsigned 32-bit integer indicating the session index.

*Return*

* An type as defined in Definition
link:#defn-option-type[[defn-option-type]] which can contain the session
info structure, latexmath:[$S$], of the following format:
+
[latexmath]
++++
\[\begin{aligned}
    S & = & (A, D, K, G, c, z, s, d, x, a)\\
    A & = & (v_n, \ldots v_m)\\
    D & = & (v_{_n}, \ldots v_m)\\
    K & = & (v_n, \ldots v_m)\\
    G & = & (g_n, \ldots g_m)\\
    g & = & (A_n, \ldots A_m)
  \end{aligned}\]
++++
where
** latexmath:[$A$] indicates the validators of the current session, in
canonical order. There might be more validators in the current session
than validators participating in parachain consensus, as returned by the
Runtime API as defined in Section link:#sect-rt-api-validators[7.8.1].
** latexmath:[$D$] indicates the validator authority discovery keys for
the given session in canonical order. The first couple of validators are
equal to the corresponding validators participating in the parachain
consensus, as returned by the Runtime API as defined in Section
link:#sect-rt-api-validators[7.8.1]. The remaining authorities are not
participating in the parachain consensus.
** latexmath:[$K$] indicates the assignment keys for validators. There
might be more authorities in the session that validators participating
in parachain consensus, as returned by the Runtime API as defined in
Section link:#sect-rt-api-validators[7.8.1].
** latexmath:[$G$] indicates the validator groups in shuffled order. [To
do: what’s the purpose of this?]
** latexmath:[$v_n$] is public key of the authority.
** latexmath:[$A_n$] is the authority set Id as defined in Definition
[To do: todo].
** latexmath:[$c$] is an unsigned 32-bit integer indicating the number
of availability cores used by the protocol during the given session.
** latexmath:[$z$] is an unsigned 32-bit integer indicating the zeroth
delay tranche width.
** latexmath:[$s$] is an unsigned 32-bit integer indicating the number
of samples an assigned validator should do for approval voting.
** latexmath:[$d$] is an unsigned 32-bit integer indicating the number
of delay tranches in total.
** latexmath:[$x$] is an unsigned 32-bit integer indicating how many
BABE slots must pass before an assignment is considered a ``no-show''.
[To do: clarify how to convert between BABE slots and ``ticks'']
** latexmath:[$a$] is an unsigned 32-bit integer indicating the number
of validators needed to approve a block.

==== dmq_contents

Returns all the pending inbound messages in the downward message queue
for a given parachain.

 

*Arguments*

* The parachain Id as defined in Definition
link:#defn-para-id[[defn-para-id]].

*Return*

* An array of inbound downward messages as defined in [To do: reference
messaging chapter]

==== inbound_hrmp_channels_contents

Returns the contents of all channels addresssed to the given recipient.
Channels that have no messages in them are also included.

 

*Arguments*

* The parachain Id as defined in Definition
link:#defn-para-id[[defn-para-id]].

*Return*

* An array of inbound HRMP messages as defined in [To do: reference
messaging chapter]

==== disputes_info

{empty}[To do: looks like this was renamed (and modified) into
on_chain_votes?]

 

Returns information about all disputes known by the Runtime, including
which validators the Runtime will accept disputes from.

 

*Arguments*

* None

*Return*

* A dispute information structure, latexmath:[$I$], of the following
format:
+
[latexmath]
++++
\[\begin{aligned}
    I & = & ((D_0, \ldots D_n), T)\\
    D & = & (i, C_h, S, l)\\
    T & = & (m, (p_0, \ldots p_n))\\
    p & = & (i, (s_0, \ldots s_n))
  \end{aligned}\]
++++
where
** latexmath:[$D$] represents a dispute.
** latexmath:[$T$] represents information about spam slots [To do:
clarify]
** latexmath:[$i$] is the session index as defined in Definition [To do:
todo].
** latexmath:[$C_h$] is the candidate hash [To do: receipt?].
** latexmath:[$S$] is the dispute state as defined in Definition [To do:
todo].
** latexmath:[$l$] is a boolean indacting ... [To do: ?].
** latexmath:[$m$] is a unsigned 32-bit integer indicating the maximum
spam slots [To do: clarify].
** latexmath:[$s$] is a unsigned 32-bit integer indicating the spam
slot.

==== candidates_included

{empty}[To do: looks like this was removed?]

 

Checks which candidates have been included within the local chain.

 

*Arguments*

* An array for pairs, latexmath:[$p$], of the following format:
+
[latexmath]
++++
\[\begin{aligned}
    p & = & (i, C_h)
  \end{aligned}\]
++++
where latexmath:[$i$] is the session index as defined in Definition [To
do: todo] and latexmath:[$C_h$] is the candidate hash.

*Return*

* An array of booleans which indicate whether the a candidate is
included (_true_) or not (_false_). The order of booleans corresponds to
the order of the passed on pairs latexmath:[$p$].

[[network-messages]]
=== Network messages

The availability and validity process requires certain network messages
to be exchanged between validators and collators.

==== Notification Messages

The notification messages are exchanged between validators, including
messages sent by collators to validators. The protocol messages are
exchanged based on a streaming notification substream as described in
Section link:#sect-connection-establishment[4.5]. The messages are SCALE
encoded as described in Section link:#sect-scale-codec[10.1].

[#net-msg-validator-protocol-message]##[net-msg-validator-protocol-message]##The
*validator protocol message* is a varying datatype used by validators to
broadcast relevant information about certain steps in the A&V process.
Specifically, this includes the backing process as described in Section
link:#sect-candidate-backing[7.4] and the approval process as described
in Section link:#sect-approval-voting[7.7]. The validator protocol
message, latexmath:[$M$], is a varying datatype of the following format:

[latexmath]
++++
\[\begin{aligned}
    M & = & \left\{\begin{array}{l}
      1 \rightarrow M_f\\
      3 \rightarrow M_s\\
      4 \rightarrow M_a
    \end{array}\right.
  \end{aligned}\]
++++
where

* latexmath:[$M_f$] is a bitfield distribution message as defined in
Definition link:#net-msg-bitfield-dist-msg[[net-msg-bitfield-dist-msg]].
* latexmath:[$M_s$] is a statement distribution message as defined in
Definition
link:#net-msg-statement-distribution[[net-msg-statement-distribution]].
* latexmath:[$M_a$] is a approval distribution message as defined in
Definition
link:#net-msg-approval-distribution[[net-msg-approval-distribution]].

[#net-msg-collator-protocol-message]##[net-msg-collator-protocol-message]##The
*collation protocol message*, latexmath:[$M$], is a varying datatype of
the following format:

[latexmath]
++++
\[\begin{aligned}
    M & = & \left\{\begin{array}{l}
      0 \rightarrow M_c
    \end{array}\right.
  \end{aligned}\]
++++
where latexmath:[$M_c$] is the collator message as defined in Definition
link:#net-msg-collator-protocol[[net-msg-collator-protocol]].

[#net-msg-collator-protocol]##[net-msg-collator-protocol]##The *collator
message*, latexmath:[$M$], is a varying datatype of the following
format:

[latexmath]
++++
\[\begin{aligned}
    M & = & \left\{\begin{array}{l}
      0 \rightarrow (C_i, P_i, C_s)\\
      1 \rightarrow H\\
      4 \rightarrow (B_h, S)
    \end{array}\right.
  \end{aligned}\]
++++
where

* latexmath:[$M$] is a varying datatype where latexmath:[$0$] indicates
the intent to advertise a collation and latexmath:[$1$] indicates the
advertisment of a collation to a validator. latexmath:[$4$] indicates
that a collation sent to a validator was seconded.
* latexmath:[$C_i$] is the public key of the collator.
* latexmath:[$P_i$] is the parachain Id as defined in Definition
link:#defn-para-id[[defn-para-id]].
* latexmath:[$C_s$] is the signature of the collator using the of the
collators node.
* latexmath:[$H$] is the hash of the parachain block as defined in
Definition link:#defn-parablock[[defn-parablock]].
* latexmath:[$S$] is a full statement as defined in Definition
link:#net-msg-full-statement[[net-msg-full-statement]].

This message is not sent directly but is sent as part of the collator
protocol message as defined in Section
link:#net-msg-collator-protocol-message[[net-msg-collator-protocol-message]].

[#net-msg-statement-distribution]##[net-msg-statement-distribution]##The
*statement distribution message* is sent as part of the validator
protocol message as defined in Section
link:#net-msg-validator-protocol-message[[net-msg-validator-protocol-message]],
indicates the validity vote of a validator for a given candidate,
described further in Section
link:#sect-candidate-backing-statements[7.4.1]. The statement
distribution message, latexmath:[$M$], is of varibale type of the
following format:

[latexmath]
++++
\[\begin{aligned}
    M & = & \left\{\begin{array}{l}
      0 \rightarrow (B_h, S)\\
      1 \rightarrow S_m
    \end{array}\right.\\
    S_m & = & (B_h, C_h, A_i, A_s)
  \end{aligned}\]
++++
where

* latexmath:[$M$] is a vayring datatype where latexmath:[$0$]indicates a
signed statement and latexmath:[$1$] contains metadata about a seconded
statement with a larger payload, such as a runtime upgrade. The
candidate itself can be fetched via the request/response message as
defined in Definition
link:#net-msg-statement-fetching-request[[net-msg-statement-fetching-request]].
* latexmath:[$B_h$] is the hash of the relay chain parent, indicating
the state this message is for.
* latexmath:[$S$] is a full statement as defined in Definition
link:#net-msg-full-statement[[net-msg-full-statement]].
* latexmath:[$A_i$] is the validator index in the authority set that
signed this message.
* latexmath:[$A_s$] is the signature of the validator.

[#net-msg-bitfield-dist-msg]##[net-msg-bitfield-dist-msg]##The *bitfield
distribution message* indicates the availability vote of a validator for
a given candidate, described further in Section
link:#sect-availability-votes[7.6.1]. This message is sent in form of a
validator protocol message as defined in Definition
link:#net-msg-validator-protocol-message[[net-msg-validator-protocol-message]].
The bitfield distribution message, latexmath:[$M$], is a datastructure
of the following format:

[latexmath]
++++
\[\begin{aligned}
    M & = & \left\{\begin{array}{l}
      0 \rightarrow (B_h, P)
    \end{array}\right.\\
    P & = & (d, A_i, A_s)
  \end{aligned}\]
++++
where

* latexmath:[$B_h$] is the hash of the relay chain parent, indicating
the state this message is for.
* latexmath:[$d$] is the bitfield array as described in Definition
link:#defn-bitfield-array[[defn-bitfield-array]].
* latexmath:[$A_i$] is the validator index in the authority set as
defined in Definition link:#defn-authority-list[[defn-authority-list]]
that signed this message.
* latexmath:[$A_s$] is the signature of the validator.

This message is not sent directly but is sent as part of the collator
protocol message as defined in Section
link:#net-msg-validator-protocol-message[[net-msg-validator-protocol-message]].

[#net-msg-approval-distribution]##[net-msg-approval-distribution]##The
*approval distribution message* indicates the approval vote of a
validator for a given candidate, described further in Section
link:#sect-availability-assingment-criteria[7.7.1]. This message is sent
in form of a validator protocol message as defined in Definition
link:#net-msg-validator-protocol-message[[net-msg-validator-protocol-message]].
The approval distribution message, latexmath:[$M$], is a varying
datatype of the following format:

[latexmath]
++++
\[\begin{aligned}
    M & = & \left\{\begin{array}{l}
      0 \rightarrow ((C , I )_0 \ldots (C, I)_n)\\
      1 \rightarrow (V_0, \ldots V_n)
    \end{array}\right.\\
    C & = & (B_h, A_i, c_a)\\
    c_a & = & (c_k, P_o, P_p)\\
    c_k & = & \left\{\begin{array}{l}
      0 \rightarrow s\\
      1 \rightarrow i
    \end{array}\right.\\
    V & = & (B_h, I, A_i, A_s)
  \end{aligned}\]
++++
where

* latexmath:[$M$] is a varying datatype where latexmath:[$0$] indicates
assignments for candidates in recent, unfinalized blocks and
latexmath:[$1$] indicates approvals for candidates in some recent,
unfinalized block.
* latexmath:[$C$] is an assignment criterion which refers to the
candidate under which the assignment is relevant by the block hash.
* latexmath:[$I$] is an unsigned 32-bit integer indicating the index of
the candidate, corresponding the the order of the availability cores as
described in Section link:#sect-rt-api-availability-cores[7.8.3].
* latexmath:[$B_h$] is the relay chain block hash where the candidate
appears.
* latexmath:[$A_i$] is the authority set Id of the validator as defined
in Definition link:#defn-authority-list[[defn-authority-list]] that
created this message.
* latexmath:[$A_s$] is the signature of the validator issuing this
message.
* latexmath:[$c_a$] is the certification of the assignment.
* latexmath:[$c_k$] is a varying datatype where latexmath:[$0$]
indicates an assignment based on the VRF that authorized the relay chain
block where the candidate was included, followed by a sample number,
latexmath:[$s.$] latexmath:[$1$] indicates an assignment story based on
the VRF that authorized the relay chain block where the candidate was
included combined with the index of a particular core. This is described
further in Section link:#sect-approval-voting[7.7].
* latexmath:[$P_o$] is a VRF output and latexmath:[$P_p$] its
corresponding proof.

This message is not sent directly but is sent as part of the collator
protocol message as defined in Section
link:#net-msg-validator-protocol-message[[net-msg-validator-protocol-message]].

=== Request & Response

The request & response network messages are sent and received between
peers in the Polkadot network, including collators and non-validator
nodes. Those messages are conducted on the request-response substreams
are described in Section link:#sect-connection-establishment[4.5]. The
network messages are SCALE encoded as described in Section
link:#sect-scale-codec[10.1].

[#net-msg-pov-fetching-request]##[net-msg-pov-fetching-request]##The
*PoV fetching request* is sent by clients who want to retrieve a PoV
block from a node. The request is a datastructure of the following
format:

[latexmath]
++++
\[(C_h)\]
++++
where latexmath:[$C_h$] is the 256-bit hash of the PoV block. The
reponse message is defined in Definition
link:#net-msg-pov-fetching-response[[net-msg-pov-fetching-response]].

 

[#net-msg-pov-fetching-response]##[net-msg-pov-fetching-response]##The
*PoV fetching response* is sent by nodes to the clients who issued a PoV
fetching request as defined in Definition
link:#net-msg-pov-fetching-request[[net-msg-pov-fetching-request]]. The
response, latexmath:[$R$], is a varying datatype of the following
format:

[latexmath]
++++
\[\begin{aligned}
    R & = & \left\{\begin{array}{l}
      0 \rightarrow B\\
      1 \rightarrow \ensuremath{\boldsymbol{\phi}}
    \end{array}\right.
  \end{aligned}\]
++++
where latexmath:[$0$] is followed by the PoV block and latexmath:[$1$]
indicates that the PoV block was not found.

[#net-msg-chunk-fetching-request]##[net-msg-chunk-fetching-request]##The
*chunk fetching request* is sent by clients who want to retrieve chunks
of a parachain candidate. The request is a datastructure of the
following format:

[latexmath]
++++
\[(C_h, i)\]
++++
where latexmath:[$C_h$] is the 256-bit hash of the parachain candiate
and latexmath:[$i$] is a 32-bit unsigned integer indicating the index of
the chunk to fetch. The response message is defined in Definition
link:#net-msg-chunk-fetching-response[[net-msg-chunk-fetching-response]].

[#net-msg-chunk-fetching-response]##[net-msg-chunk-fetching-response]##The
*chunk fetching response* is sent by nodes to the clients who issued a
chunk fetching request as defined in Definition
link:#net-msg-chunk-fetching-request[[net-msg-chunk-fetching-request]].
The reponse, latexmath:[$R$], is a varying datatype of the following
format:

[latexmath]
++++
\[\begin{aligned}
    R & = & \left\{\begin{array}{l}
      0 \rightarrow C_r\\
      1 \rightarrow \ensuremath{\boldsymbol{\phi}}
    \end{array}\right.\\
    C_r & = & (c, c_p)
  \end{aligned}\]
++++
where 0 is followed by the chunk response, latexmath:[$C_r$] and 1
indicates that the requested chunk was not found. latexmath:[$C_r$]
contains the erasure-encoded chunk of data belonging to the candidate
block, latexmath:[$c$], and latexmath:[$c_p$] is that chunks proof in
the Merkle tree. Both latexmath:[$c$] and latexmath:[$c_p$] are byte
arrays of type latexmath:[$(b_n \ldots
  b_m)$].

[#net-msg-available-data-request]##[net-msg-available-data-request]##The
*available data request* is sent by clients who want to retrieve the PoV
block of a parachain candidate. The request is a datastructure of the
following format:

[latexmath]
++++
\[C_h\]
++++
where latexmath:[$C_h$] is the 256-bit candidate hash to get the
available data for. The reponse message is defined in Definition
link:#net-msg-available-data-reponse[[net-msg-available-data-reponse]].

[#net-msg-available-data-reponse]##[net-msg-available-data-reponse]##The
*available data response* is sent by nodes to the clients who issued a
available data request as defined in Definition
link:#net-msg-available-data-request[[net-msg-available-data-request]].
The reponse, latexmath:[$R$], is a varying datatype of the following
format:

[latexmath]
++++
\[\begin{aligned}
    R & = & \left\{\begin{array}{l}
      0 \rightarrow A\\
      1 \rightarrow \ensuremath{\boldsymbol{\phi}}
    \end{array}\right.\\
    A & = & (P_{\ensuremath{\operatorname{ov}}}, D_{\ensuremath{\operatorname{pv}}})
  \end{aligned}\]
++++
where latexmath:[$0$] is followed by the available data,
latexmath:[$A$], and latexmath:[$1$] indicates the the requested
candidate hash was not found.
latexmath:[$P_{\ensuremath{\operatorname{ov}}}$] is the PoV block as
defined in Definition link:#defn-pov-block[[defn-pov-block]] and
latexmath:[$D_{\ensuremath{\operatorname{pv}}}$] is the persisted
validation data as defined in Definition
link:#defn-persisted-validation-data[[defn-persisted-validation-data]].

[#net-msg-collation-fetching-request]##[net-msg-collation-fetching-request]##The
*collation fetching request* is sent by clients who want to retrieve the
advertised collation at the specified relay chain block. The request is
a datastructure of the following format:

[latexmath]
++++
\[(B _h, P_{\ensuremath{\operatorname{id}}})\]
++++
where latexmath:[$B _h$] is the hash of the relay chain block and
latexmath:[$P_{\ensuremath{\operatorname{id}}}$] is the parachain Id as
defined in Definition link:#defn-para-id[[defn-para-id]]. The response
message is defined in Definition
link:#net-msg-collation-fetching-response[[net-msg-collation-fetching-response]].

[#net-msg-collation-fetching-response]##[net-msg-collation-fetching-response]##The
*collation fetching response* is sent by nodes to the clients who issued
a collation fetching request as defined in Definition
link:#net-msg-collation-fetching-request[[net-msg-collation-fetching-request]].
The response, latexmath:[$R$], is a varying datatype of the following
format:

[latexmath]
++++
\[\begin{aligned}
    R & = & \left\{\begin{array}{l}
      0 \rightarrow (C_r, B)
    \end{array}\right.
  \end{aligned}\]
++++
where latexmath:[$0$] is followed by the candidate receipt,
latexmath:[$C_r$], as defined in Definition
link:#defn-candidate-receipt[[defn-candidate-receipt]] and the PoV
block, latexmath:[$B$]. This type does not notify the client about a
statement that was not found.

[#net-msg-statement-fetching-request]##[net-msg-statement-fetching-request]##The
*statement fetching request* is sent by clients who want to retrieve
statements about a given candidate. The request is a datastructure of
the following format:

[latexmath]
++++
\[\begin{aligned}
    & (B_h, C_h) & 
  \end{aligned}\]
++++
where latexmath:[$B_h$] is the hash of the relay chain parent and
latexmath:[$C_h$] is the candidate hash that was used to create a
committed candidate recept as defined in Definition
link:#defn-committed-candidate-receipt[[defn-committed-candidate-receipt]].
The response message is defined in Definition
link:#net-msg-statement-fetching-response[[net-msg-statement-fetching-response]].

[#net-msg-statement-fetching-response]##[net-msg-statement-fetching-response]##The
*statement fetching response* is sent by nodes to the clients who issued
a collation fetching request as defined in Definition
link:#net-msg-statement-fetching-request[[net-msg-statement-fetching-request]].
The reponse, latexmath:[$R$], is a varying datatype of the following
format:

[latexmath]
++++
\[\begin{aligned}
    R & = & \left\{\begin{array}{l}
      0 \rightarrow C_r
    \end{array}\right.
  \end{aligned}\]
++++
where latexmath:[$C_r$] is the committed candidate receipt as defined in
Definition
link:#defn-committed-candidate-receipt[[defn-committed-candidate-receipt]].
No response is returned if no statement is found.

[#net-msg-dispute-request]##[net-msg-dispute-request]##The *dispute
request* is sent by clients who want to issue a dispute about a
candidate. The request, latexmath:[$D_r$], is a datastructure of the
following format:

[latexmath]
++++
\[\begin{aligned}
    D_r & = & (C_r, S_i, I_v, V_v)\\
    I_v & = & (A_i, A_s, k_i)\\
    V_v & = & (A_i, A_s, k_v)\\
    k_i & = & \left\{\begin{array}{l}
      0 \rightarrow \ensuremath{\boldsymbol{\phi}}
    \end{array}\right.\\
    k_v & = & \left\{\begin{array}{l}
      0 \rightarrow \ensuremath{\boldsymbol{\phi}}\\
      1 \rightarrow C_h\\
      2 \rightarrow C_h\\
      3 \rightarrow \ensuremath{\boldsymbol{\phi}}
    \end{array}\right.
  \end{aligned}\]
++++
where

* latexmath:[$C_r$] is the candidate that is being disputed. The
structure is a candidate receipt as defined in Definition
link:#defn-candidate-receipt[[defn-candidate-receipt]].
* latexmath:[$S_i$] is an unsigned 32-bit integer indicating the session
index the candidate appears in.
* latexmath:[$I_v$] is the invalid vote that makes up the request.
* latexmath:[$V_v$] is the valid vote that makes this disput request
valid.
* latexmath:[$A_i$] is an unsigned 32-bit integer indicating the
validator index in the authority set as defined in Definition
link:#defn-authority-list[[defn-authority-list]].
* latexmath:[$A_s$] is the signature of the validator.
* latexmath:[$k_i$] is a varying datatype and implies the dispute
statement. latexmath:[$0$] indicates an explicit statemet.
* latexmath:[$k_v$] is a varying datatype and implies the dispute
statement.
** latexmath:[$0$] indicates an explicit statement.
** latexmath:[$1$] indicates a seconded statement on a candidate,
latexmath:[$C_h$], from the backing phase. latexmath:[$C_h$] is the hash
of the candidate.
** latexmath:[$2$] indicates a valid statement on a candidate,
latexmath:[$C_h$], from the backing phase. latexmath:[$C_h$] is the hash
of the candidate.
** latexmath:[$3$] indicates an approval vote from the approval checking
phase.

The response message is defined in Definition
link:#net-msg-dispute-response[[net-msg-dispute-response]].

[#net-msg-dispute-response]##[net-msg-dispute-response]##The *dispute
response* is sent by nodes to the clients who who issued a dispute
request as defined in Definition
link:#net-msg-dispute-request[[net-msg-dispute-request]]. The response,
latexmath:[$R$], is a varying type of the following format:

[latexmath]
++++
\[\begin{aligned}
    R & = & \left\{\begin{array}{l}
      0 \rightarrow \ensuremath{\boldsymbol{\phi}}
    \end{array}\right.
  \end{aligned}\]
++++
where latexmath:[$0$] indicates that the dispute was successfully
processed.

[[sect-primary-validation]]
=== [To do: todo - Outdated section]

Collators produce candidates (Definition
link:#defn-candidate[[defn-candidate]]) and send those to validators.
Validators verify the validity of the received candidates (Algo.
link:#algo-primary-validation[[algo-primary-validation]]) by executing
the validation code, latexmath:[$R_{\rho}$], and issue statements
(Definition link:#defn-gossip-statement[[defn-gossip-statement]]) about
the candidates to connected peers. The validator ensures the that every
candidate considered for inclusion has at least one other validator
backing it. Candidates without backing are discarded.

 

The validator must keep track of which candidates were submitted by
collators, including which validators back those candidates in order to
penalize bad behavior. This is described in more detail in section
link:#sect-primary-validaty-announcement[[sect-primary-validaty-announcement]].

[[sect-parachain-block-production]]
==== Parachain Block Production

Collators produce a candidate for their corresponding parachains and
submit those to the parachain validators which are part of the Polkadot
relay chain.

===== Building a parachain block

*Algorithm*

[#algo-build-parablock]##[algo-build-parablock]##Producing a parachain
candidate

* RelayParent - Fetches the parent block hash of the relay chain as
described in Section
link:#sect-collator-consensus[[sect-collator-consensus]].
* ValidationData - Fetches the persistent validation data as defined in
Definition
link:#defn-persisted-validation-data[[defn-persisted-validation-data]].
* ParentHead - Derives the parachain parent header from validation data
latexmath:[$v_d$].
* ProduceCandidate - Produces a candidate as defined in Definition
link:#defn-candidate[[defn-candidate]] from the values
latexmath:[$r_p$], latexmath:[$v_d$] and latexmath:[$h_d$].
* CreateParaBlock - Creates a parachain block as defined in Definition
link:#defn-parablock[[defn-parablock]] from the produced candidate
latexmath:[$D_p$].
* BuildCollation - Builds the final collation as defined in Definition
link:#defn-collation[[defn-collation]] from the created parachain block
latexmath:[$B_p$].
* Announce - Sends the collation to relay chain validators.

[#defn-gossip-pov-block]##[defn-gossip-pov-block]##A is a tuple of the
following format:

[latexmath]
++++
\[(h_b (B_{^{\ensuremath{\operatorname{relay}}}_{\ensuremath{\operatorname{parent}}}}), h_b (C_{\ensuremath{\operatorname{coll}}}
     (\ensuremath{\operatorname{PoV}}_B)), \ensuremath{\operatorname{PoV}}_B)\]
++++
where
latexmath:[$h_b (B_{^{\ensuremath{\operatorname{relay}}}_{\ensuremath{\operatorname{parent}}}})$]
is the block hash of the relay chain being referred to and
latexmath:[$h_b (C_{\ensuremath{\operatorname{coll}}} (\ensuremath{\operatorname{PoV}}_B))$]
is the hash of some candidate localized to the same Relay chain block.

*Algorithm*

[#algo-primary-validation-announcement]##[algo-primary-validation-announcement]##PrimaryValidationAnnouncement(latexmath:[$\ensuremath{\operatorname{PoV}}_B$])

* : Validates latexmath:[$\ensuremath{\operatorname{PoV}}_B$] as defined
in Algorithm link:#algo-validate-block[[algo-validate-block]].
* : Creates a valid statement as defined in Definition
link:#defn-gossip-statement[[defn-gossip-statement]].
* : Creates an invalid statement as defined in Definition
link:#defn-gossip-statement[[defn-gossip-statement]].
* : blacklists the collator which sent the invalid PoV block, preventing
any new PoV blocks from being received. The amount of time for
blacklisting is unspecified.
* : sends the statement to the connected peers.

*Algorithm*

[#algo-endorse-candidate-receipt]##[algo-endorse-candidate-receipt]##ConfirmCandidateReceipt(latexmath:[$\ensuremath{\operatorname{Stmt}}_{\ensuremath{\operatorname{peer}}}$])

* latexmath:[$\ensuremath{\operatorname{Stmt}}_{\ensuremath{\operatorname{peer}}}$]:
a statement received from another validator.
* : Retrieves the PoV block from the statement
(link:#defn-gossip-statement[[defn-gossip-statement]]).
* : Validates latexmath:[$\ensuremath{\operatorname{PoV}}_B$] as defined
in Algorithm link:#algo-validate-block[[algo-validate-block]].
* : Verifies if a parachain block has already been seconded for the
given Relay Chain block. Validators that second more than one (1) block
per Relay chain block are subject to slashing. More information is
available in Definition
link:#defn-gossip-statement[[defn-gossip-statement]].
* : Creates a valid statement as defined in Definition
link:#defn-gossip-statement[[defn-gossip-statement]].
* : Creates a seconded statement as defined in Definition
link:#defn-gossip-statement[[defn-gossip-statement]]. Seconding a block
should ensure that the next call to reliably affirms this action.
* : Creates an invalid statement as defined in Definition
link:#defn-gossip-statement[[defn-gossip-statement]].
* : blacklists the collator which sent the invalid PoV block, preventing
any new PoV blocks from being received. The amount of time for
blacklisting is unspecified.
* : announces the misbehavior of the validator who claimed a valid
statement of invalid PoV block as described in algorithm [To do:
@fabio].
* : sends the statement to the connected peers.

=== Erasure encoding [To do: todo]

In order for the Polkadot protocol to ensure the security of validatod
parachain blocks, it must be able to reproduce those blocks in case of
future dispute. To this aim,  backed candidates must be available for
the entire, elected validators set. However it is impractical to require
each of those validator to maintain a full copy of all PoV blocks. A
practical solution to this problem is to employ erasure codes: PoV
blocks are broken into chunks and the chunks are encoded using
Reed-Solomon erasure codes. Erasure-encoded chunks are arranged into a
Merkle tree to ensure their integrity. Subsequently, the encoded chunks
are distributed among the validators each along side its Merkle proof of
integrity. Each validator keeps track of how those chunks are
distributed among the validator set. When a validator has to verify a
PoV block, it can request the relevant chunks from its peers, verify its
integrity and reconstruct the originally validated PoV block.

This Section specifies the interaction of a validator node with the
erasure code library to obtain the encoded chunk and to reconstructing
the original PoV when enough encode chunks are available. However, the
specification of the Reed-Solomon encoding/decoding Algorithm is beyond
the scope of this section.

For validator set of size latexmath:[$n$], The *encoding parameters* for
Polkadot Reed-Solomon code is set as follow:

* *latexmath:[$k$], the number of message symbols* is set to be
latexmath:[$\left\lfloor \frac{n - 1}{3} \right\rfloor + 1$].
* *n, the number of code symbols* is set to be latexmath:[$n$].

[#defn-erasure-encoder-decoder]##[defn-erasure-encoder-decoder]##The ,
is defined to be the Reed-Solomon encoder of a message of length k
symbols which encodes it into latexmath:[$n$] symbles as follows:

[latexmath]
++++
\[\ensuremath{\operatorname{encode}}_{k, n} : \left\{ \begin{array}{ccc}
       \mathbb{B}_m & \rightarrow & \mathbb{S}_n\\
       (b_1, \ldots, b_m) & \rightarrow & (S_1, S_2, \ldots, S_n)
     \end{array} \right.\]
++++
where latexmath:[$[b_1, \ldots, b_m]$] is a byte array of arbitrary size
latexmath:[$m$] and latexmath:[$(S_1,
  S_2, \ldots, S_n)$] is a sequence of shards defined in
link:#defn-erasure-shard[[defn-erasure-shard]].

{empty}[#defn-erasure-shard]##[defn-erasure-shard]##For a validator node
latexmath:[$i$], and byte array blob latexmath:[$B =
  (b_1, \ldots, b_m) \in \mathbb{B}_M$] we define *latexmath:[$S_i$]* as
the *latexmath:[$i$]’th erasure coded Shard*  which is a byte array of
length latexmath:[$\lceil m / 2 k \rceil$]. It is indexed as
latexmath:[$i$] because it is out to be handed over to and kept by
validator latexmath:[$i$] [To do: define how bytes are distributed
before encoding? First k Shards are containing pure data?]

The is defined to be the Reed-Solomon decoder of a code word of n
symboles into a message of k symbols as follows:

[latexmath]
++++
\[\ensuremath{\operatorname{decode}}_{k, n} : \left\{ \begin{array}{ccc}
       O S_n & \rightarrow & \mathbb{B}_m\\
       (O S_1, O S_2, \ldots, O S_n) & \rightarrow & (b_1, \ldots, b_m)\\
       &  & 
     \end{array} \right.\]
++++
Where latexmath:[$\ensuremath{\operatorname{OS}}_n$] is the set of
sequence of length n of optional shards as defined in Definition
link:#defn-erasure-optional-shard[[defn-erasure-optional-shard]] and
latexmath:[$\mathbb{B}_m$] is the set of byte arrays of length m
representing the decoded blob of data.

[#defn-erasure-optional-shard]##[defn-erasure-optional-shard]##For a
validator node latexmath:[$i$], we define *Olatexmath:[$S_i$]* as the
*latexmath:[$i$]’th Optional Shard* which is a of varying type:

[latexmath]
++++
\[\begin{array}{lll}
       \ensuremath{\operatorname{idx}} &  & \\
       0 & \ensuremath{\operatorname{None}} & \ensuremath{\operatorname{When}} S_i \ensuremath{\operatorname{is}} \ensuremath{\operatorname{not}} \ensuremath{\operatorname{received}}
       \ensuremath{\operatorname{by}} \ensuremath{\operatorname{the}} \ensuremath{\operatorname{constructing}} \ensuremath{\operatorname{node}}\\
       1 & S_i & \ensuremath{\operatorname{When}} S_i \ensuremath{\operatorname{shard}} \ensuremath{\operatorname{is}} \ensuremath{\operatorname{received}} .
     \end{array}\]
++++

*Algorithm*

[#algo-erasure-encode]##[algo-erasure-encode]##Erasure-Encode(latexmath:[$\bar{B}$]:
the available PoV blob defined in Definition
link:#defn-blob[[defn-blob]],

latexmath:[$v_B$]: number of validator in the active set)

* : return shards for each validator as described in Algorithm
link:#algo-make-shards[[algo-make-shards]]. Return value is defined as
latexmath:[$(\mathbb{S}_0, ..., \mathbb{S}_n)$] where
latexmath:[$\mathbb{S} :=(b_0, ...,
  b_n)$]
* Generate-Availability-Merkle-Tree is described in Algorithm
link:#algo-gen-availblity-tree[[algo-gen-availblity-tree]].
* : insert the given latexmath:[$\ensuremath{\operatorname{key}}$] and
latexmath:[$\ensuremath{\operatorname{value}}$] into the
latexmath:[$\ensuremath{\operatorname{trie}}$].
* : based on the latexmath:[$\ensuremath{\operatorname{key}}$], return
all required latexmath:[$\ensuremath{\operatorname{trie}}$] nodes in
order to verify the corresponding value for a (unspecified) Merkle root.
Return value is defined as
latexmath:[$(\mathbb{N}_0, ..., \mathbb{N}_n)$] where
latexmath:[$\mathbb{N} :=(b_0, ...,
  b_n)$].
* : add the given latexmath:[$\ensuremath{\operatorname{item}}$] to the
latexmath:[$\ensuremath{\operatorname{sequence}}$].
* latexmath:[$\ensuremath{\operatorname{ER}}_B$] is the collection of
erasure coded chunk as defined in Definition
link:#defn-erasure-coded-chunks[[defn-erasure-coded-chunks]].

*Algorithm*

[#algo-make-shards]##[algo-make-shards]##Make-Shards(latexmath:[$D$]:
The data to be erasure coded and sharded,

latexmath:[$v_B$]: Number of required resulting shards (equal to the
number of validators))

* Make-Encoder(C) is the API function provided by .

Algorithm link:#algo-gen-availblity-tree[[algo-gen-availblity-tree]]
creates a Merkle tree from the shards produced by Algorithm
link:#algo-make-shards[[algo-make-shards]]. The Merkle tree is to
produce the Merkle proofs to verify each chunk.

*Algorithm*

[#algo-gen-availblity-tree]##[algo-gen-availblity-tree]##Generate-Availability-Merkle-Tree(S:
Sequence of Shards generated

by Algorithm link:#algo-make-shards[[algo-make-shards]] )

[To do: Either we should spec the trie completly as we did with Storage
Trie or we should

refer to Storage trie spec.]

[#defn-erasure-coded-chunks]##[defn-erasure-coded-chunks]##The of
latexmath:[$\bar{B}$], denoted by:

[latexmath]
++++
\[\ensuremath{\operatorname{Er}}_B :=(e_1, ..., e_n)\]
++++
is defined to be the output of the Algorithm
link:#algo-erasure-encode[[algo-erasure-encode]]. Each chunk is a tuple
of the following format:

[latexmath]
++++
\[\begin{aligned}
{2}
    e &
    {:=}(\ensuremath{\mathbb{S}},I,(\ensuremath{\mathbb{N}}\ensuremath{_{\textrm{0}}},...,\ensuremath{\mathbb{N}}\ensuremath{_{\textrm{n}}}))\\
    \ensuremath{\mathbb{S}} & {:=}(b\ensuremath{_{\textrm{0}}},...,b\ensuremath{_{\textrm{n}}})\\
    \ensuremath{\mathbb{N}} & {:=}(b\ensuremath{_{\textrm{0}}},...,b\ensuremath{_{\textrm{n}}})
  \end{aligned}\]
++++

where each value represents:

* latexmath:[$\mathbb{S}$]: a byte array containing the erasure-encoded
shard of data.
* latexmath:[$I$]: the unsigned 32-bit integer representing the index of
this erasure-encoded chunk of data.
* latexmath:[$(\mathbb{N}_0, ..., \mathbb{N}_n)$]: an array of inner
byte arrays, each containing the nodes of the Trie in order to verify
the chunk based on the Merkle root.

== Message Passing

{empty}[To do: DISCLAIMER: this document is currently outdated. The
messaging protocol for Parachains is heavily work-in-progress and will
change a lot until finalization.]

=== Overview

Polkadot implements two types of message passing mechanisms; vertical
passing and horizontal passing.

* Vertical message passing refers to the communication between the
parachains and the relay chain. More precisely, when the relay chain
sends messages to a parachain, it’s ``downward message passing''. When a
parachain sends messages to the relay chain, it’s ``upward message
passing''.
* Horizontal message passing refers to the communication between the
parachains, only requiring minimal involvement of the relay chain. The
relay chain essentially only stores proofs that message where sent and
whether the recipient has read those messages.

=== Message Queue Chain (MQC)

The Message Queue Chain (MQC) is a general hash chain construct created
by validators which keeps track of any messages and their order as sent
from a sender to an individual recipient. The MQC is used by both HRMP
and XCMP.

Each block within the MQC is a triple containing the following fields:

- : The hash of the previous triple.

- : The hash of the message itself.

- : The relay block number at which the message was sent.

A MQC is always specific to one channel. Additional channels require its
own, individual MQC. The MQC itself is not saved anywhere, but only
provides a final proof of all the received messages. When a validators
receives a candidate, it generates the MQC from the messages placed
withing , in ascending order.

=== HRMP

Polkadot currently implements the mechanism known as Horizontal
Relay-routed Message Passing (HRMP), which fully relies on vertical
message passing in order to communicate between parachains.
Consequently, this goes against the entire idea of horizontal passing in
the first place, since now every message has to be inserted into the
relay chain itself, therefore heavily increasing footprint and resource
requirements. However, HRMP currently serves as a fast track to
implementing cross-chain interoperability. The upcoming replacement of
HRMP is Cross-Chain Message Passing (XCMP), which exchanges messages
directly between parachains and only updates proofs and
read-confirmations on chain. With XCMP, vertical message processing is
only used for opening and closing channels.

==== Channels

A channel is a construct on the relay chain indicating an open,
one-directional communication line between a sender and a recipient,
including information about how the channel is being used. The channel
itself does not contain any messages. A channel construct is created for
each, individual communication line.

A channel contains the following fields:

:

* : staked balances of sender.
* : staked balances of recipient.
* : the maximum number of messages that can be pending in the channel at
once.
* : the maximum total size of the messages that can be pending in the
channel at once.
* : the maximum message size that could be put into the channel.
* : number of messages used by the sender in this channel.
* : total number of bytes used by the sender in this channel.
* : (TOOD: this is not defined in the Impl-Guide) indicator wether the
channel is sealed. If it is, then the recipient will no longer accept
any new messages.
* : a head of the MQC for this channel.

This structure is created or overwritten on every start of each session.
Individual fields of this construct are updated for every message sent,
such as , and . If the channel is sealed and reaches (occurs when a new
session begins), this construct is be removed on the _next_ session
start.

The Runtime maintains a structure of the current, open channels in a
map. The key is a tuple of the sender ParaId and the recipient ParaId,
where the value is the corresponding structure.

`channels:``map(ParaId,``ParaId)``=>``Channel`

==== Opening Channels

Polkadot places a certain limit on the amount of channels that can be
opened between parachains. Only the the sender can open a channel.

In order to open a channel, the sender must send an opening request to
the relay chain. The request is a construct containing the following
fields:

:

* : the ParaId of the sender.
* : the ParaId of the recipient.
* : indicated whether the recipient has accepted the channel. On request
creation, this value is .
* : the age of this request, which start at and is incremented by 1 on
every session start.

TODO: Shouldn’t also have an field? Or can only the sender open an
channel?

===== Workflow

Before execution, the following conditions must be valid, otherwise the
candidate will be rejected.

* The and the exist.
* is not the .
* There’s currently not a active channel established, either seal or
unsealed (TODO: what if there’s an active closing request pending?).
* There’s not already an open channel request for and pending.
* The caller of this function () has capacity for a new channel. An open
request counts towards the capacity (TODO: where is this defined?).
* The caller of this function () has enough funds to cover the deposit.

The PVF executes the following steps:

* Create a message and inserts it into the list of the candidate
commitments.

Once the candidate is included in the relay chain, the runtime reads the
message from and executes the following steps:

* Reads the message from of the candidate commitments.
* Reserves a deposit for the caller of this function () (TODO: how
much?).
* Appends the request to the pending open request queue.

==== Accepting Channels

Open channel requests must be accepted by the other parachain.

TODO: How does a Parachain decide which channels should be accepted?
Probably off-chain consensus/agreement?

The accept message contains the following fields:

:

* : the index of the open request list.

===== Workflow

Before execution, the following conditions must be valid, otherwise the
candidate will be rejected.

* The is valid (the value is within range of the list).
* The ParaId corresponds to the ParaId of the caller of this function.
* The caller of this function () has enough funds to cover the deposit.

The PVF executes the following steps:

* Generates a message and inserts it into the list of the candidate
commitments.

Once the candidate is included in the relay chain, the relay runtime
reads the message from and executes the following steps:

* Reserve a deposit for the caller of this function ().
* Confirm the open channel request in the request list by setting the
field to .

==== Closing Channels

Any open channel can be closed by the corresponding sender or receiver.
No mutual agreement is required. A close channel request is a construct
containing the following fields:

:

* : the ParaId of the parachain which initiated this request, either the
sender or the receiver.
* : the ParaId of the sender.
* : the ParaId of the recipient.

==== Workflow

Before execution, the following conditions must be valid, otherwise the
candidate will be rejected.

* There’s currently and open channel or a pending open channel request
between and .
* The channel is not sealed.
* The caller of the Runtime function is either the or .
* There is not existing close channel request.

The PVF executes the following steps:

* Generates a message and inserts it into the list of the candidate
commitments.

Once a candidate block is inserted into the relay chain, the relay
runtime:

* Reads the message from of the candidate commitments.
* Appends the request to the pending close request queue.

==== Sending messages

The Runtime treats messages as SCALE encoded byte arrays and has no
concept or understanding of the message type or format itself. Consensus
on message format must be established between the two communicating
parachains (TODO: SPREE will handle this).

Messages intended to be read by other Parachains are inserted into of
the candidate commitments (), while message which are only intended to
be read by the relay chain (such as when opening, accepting or closing
channels) are inserted into .

The messages are included by collators into the committed candidate
receipt (), which contains the following fields:

TODO: This should be defined somewhere else, ideally in a
backing/validation section (once this document is merged with AnV).

:

* : the descriptor of the candidate.
* : the commitments of the candidate receipt.

The candidate descriptor contains the following fields:

:

* : the ID of the para this is a candidate for.
* : the hash of the relay chain block this is executed in the context
of.
* : the collator’s SR25519 public key.
* : the hash of the persisted valdation data. This is extra data derived
from the relay chain state which may vary based on bitfields included
before the candidate. Therefore, it cannot be derived entirely from the
relay parent.
* : the how of the PoV block.
* : the signature on the Blake2 256-bit hash of the following components
of this receipt:
** {blank}
** {blank}
** {blank}
** {blank}

The candidate commitments contains the following fields:

:

* : fees paid from the chain to the relay chian validators
* : a SCALE encoded arrary containing the messages intended to be
received by the recipient parachain.
* : message destined to be interpreted by the relay chain itself.
* : the root of a block’s erasure encoding Merkle tree.
* : new validation code for the parachain.
* : the head-data produced as a result of execution.
* : the number of messages processed from the DMQ.
* : the mark which specifies the block number up to which all inbound
HRMP messages are processed.

==== Receiving Messages

A recipient can check for unread messages by calling into the function
of the relay runtime (TODO: currently it’s not really clear how a
recipient will check for new messages).

Params:

* : the ParaId of the sender.

On success, it returns a SCALE encoded array of messages.

=== XCMP

XCMP is a horizontal message passing mechanism of Polkadot which allows
Parachains to communicate with each other and to prove that messages
have been sent. A core principle is that the relay chain remains as thin
as possible in regards to messaging and only contains the required
information for the validity of message processing.

The entire XCMP process requires a couple of steps:

* The sender creates a local Message Queue Chain (MQC) of the messages
it wants to send and inserts the Merkle root into a structure on the
relay chain, known as the Channel State Table (CST).
* The messages are sent to the recipient and contain the necessary data
in order to reproduce the MQC.
* The BIOS module of the recipient process those messages. The messages
are then inserted into the next parablock body as inherent extrinsics.
* Once that parablock is inserted into the relay chain, the recipient
then updates the Watermark, which points to the relay block number which
includes the parablock. This serves as an indicator that the receiving
parachain has processed messages up to that relay block.

Availabilty

* The messages created by the sender must be kept available for at least
one day. When AnV assigns validators to check the validity of the
sending parachains parablocks, it can load the data from the CST, which
includes the information required in order to regenerate the MQC.
* ...

==== CST: Channel State Table

The Channel State Table (CST) is a map construct on the relay chain
which keeps track of every MQC generated by a single sender. The
corresponding value is a list of pairs, where each pair contains the
ParaId of the recipient, the Merkle root of MQC heads and the relay
block number where that item was last updated in the CST. This provides
a mechanism for receiving parachains to easily verify messages sent from
a specific source.

When a PoV block on the recipient is created, the collator which builds
that block fetches the pairs of the sender from the CST and creates its
own Merkle root. When that PoV block is sent to the validator, the
validator can just fetch the Merkle root from the CST Root and verify
the PoV block without requiring the full list of pairs.

==== Message content

All messages sent to the recipient must contain enough information in
order for the recipient to verify those messages with the CST. This
includes the necessary Merkle trie nodes, the parent triple of each
individual MQC block and the messages themselves. The recipient then
recreates the MQC and verifies it against the CST.

==== Watermark

Collators of the recipient insert the messages into their parablock as
Inherents and publish the parablock to the relay chain. Once included,
the watermark is updated and points to the relay chain block number
where the inclusion ocurred.

`watermark:``map``ParaId``=>``(BlockNumber,``ParaId)`

=== SPREE

...

 

latexmath:[$\Box$]

 

 

== Cryptographic Algorithms

[[sect-hash-functions]]
=== Hash Functions

[[sect-blake2]]
=== BLAKE2

BLAKE2 is a collection of cryptographic hash functions known for their
high speed. Their design closely resembles BLAKE which has been a
finalist in the SHA-3 competition.

Polkadot is using the Blake2b variant which is optimized for 64-bit
platforms. Unless otherwise specified, the Blake2b hash function with a
256-bit output is used whenever Blake2b is invoked in this document. The
detailed specification and sample implementations of all variants of
Blake2 hash functions can be found in RFC 7693 .

[[sect-randomness]]
=== Randomness

[[sect-vrf]]
=== VRF

[[sect-cryptographic-keys]]
=== Cryptographic Keys

Various types of keys are used in Polkadot to prove the identity of the
actors involved in the Polkadot Protocols. To improve the security of
the users, each key type has its own unique function and must be treated
differently, as described by this Section.

[#defn-account-key]##[defn-account-key]##*Account key
latexmath:[$(\ensuremath{\operatorname{sk}}^a,
  \ensuremath{\operatorname{pk}}^a)$]* is a key pair of type of either
of the schemes listed in Table
link:#tabl-account-key-schemes[[tabl-account-key-schemes]]: An account
key can be used to sign transactions among other accounts and
blance-related functions.

There are two prominent subcategories of account keys namely ``stash
keys'' and ``controller keys'', each being used for a different
function, as described below.

The [#defn-stash-key]##[defn-stash-key]##*Stash key* is a type of
account key that holds funds bonded for staking (described in Section
link:#sect-staking-funds[9.5.1]) to a particular controller key (defined
in Definition link:#defn-controller-key[[defn-controller-key]]). As a
result, one may actively participate with a stash key keeping the stash
key offline in a secure location. It can also be used to designate a
Proxy account to vote in governance proposals, as described in
link:#sect-creating-controller-key[9.5.2]. The Stash key holds the
majority of the users’ funds and should neither be shared with anyone,
saved on an online device, nor used to submit extrinsics.

[#defn-controller-key]##[defn-controller-key]##The *Controller key* is a
type of account key that acts on behalf of the Stash account. It signs
transactions that make decisions regarding the nomination and the
validation of the other keys. It is a key that will be in direct control
of a user and should mostly be kept offline, used to submit manual
extrinsics. It sets preferences like payout account and commission, as
described in link:#sect-controller-settings[9.5.4]. If used for a
validator, it certifies the session keys, as described in
link:#sect-certifying-keys[9.5.5]. It only needs the required funds to
pay transaction fees [To do: key needing fund needs to be defined].

Keys defined in Definitions link:#defn-account-key[[defn-account-key]],
link:#defn-stash-key[[defn-stash-key]] and
link:#defn-controller-key[[defn-controller-key]] are created and managed
by the user independent of the Polkadot implementation. The user
notifies the network about the used keys by submitting a transaction, as
defined in link:#sect-creating-controller-key[9.5.2] and
link:#sect-certifying-keys[9.5.5] respectively.

[#defn-session-key]##[defn-session-key]##*Session keys* are short-lived
keys that are used to authenticate validator operations. Session keys
are generated by the Polkadot Host and should be changed regularly due
to security reasons. Nonetheless, no validity period is enforced by the
Polkadot protocol on session keys. Various types of keys used by the
Polkadot Host are presented in Table link:#tabl-session-keys[9.1]_:_

[[tabl-session-keys]]
.[#tabl-session-keys]##[tabl-session-keys]##List of key schemes which
are used for session keys depending on the protocol
[cols="<,<",options="header",]
|===
|Protocol |Key scheme
|GRANDPA |ED25519
|BABE |SR25519
|I’m Online |SR25519
|Parachain |SR25519
|===

Session keys must be accessible by certain Polkadot Host APIs defined in
Appendix link:#sect-host-api[12]. Session keys are _not_ meant to
control the majority of the users’ funds and should only be used for
their intended purpose. [To do: key managing fund need to be defined]

[[sect-staking-funds]]
==== Holding and staking funds

To be specced

[[sect-creating-controller-key]]
==== Creating a Controller key

To be specced

[[sect-designating-proxy]]
==== Designating a proxy for voting

To be specced

[[sect-controller-settings]]
==== Controller settings

To be specced

[[sect-certifying-keys]]
==== Certifying keys

Due to security considerations and Runtime upgrades, the session keys
are supposed to  be changed regularly. As such, the new session keys
need to be certified by a controller key before putting them in use. The
controller only needs to create a certificate by signing a session
public key and broadcasting this certificate via an extrinsic. [To do:
spec the detail of the data structure of the certificate etc.]

 

latexmath:[$\Box$]

 

[[sect-encoding]]
== Auxiliary Encodings

[[sect-scale-codec]]
=== SCALE Codec

The Polkadot Host uses _Simple Concatenated Aggregate Little-Endian”
(SCALE) codec_ to encode byte arrays as well as other data structures.
SCALE provides a canonical encoding to produce consistent hash values
across their implementation, including the Merkle hash proof for the
State Storage.

[#defn-scale-byte-array]##[defn-scale-byte-array]##The *SCALE codec* for
*Byte array* latexmath:[$A$] such that

[latexmath]
++++
\[A :=b_1 b_2 \ldots b_n\]
++++
such that latexmath:[$n < 2^{536}$] is a byte array refered to
latexmath:[$\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}}
  (A)$] and defined as:

[latexmath]
++++
\[\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (A) :=\ensuremath{\operatorname{Enc}}^{\ensuremath{\operatorname{Len}}}_{\ensuremath{\operatorname{SC}}}
     (\| A \|) | | A\]
++++
where
latexmath:[$\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}}^{\ensuremath{\operatorname{Len}}}$]
is defined in Definition
link:#defn-sc-len-encoding[[defn-sc-len-encoding]].

[#defn-scale-tuple]##[defn-scale-tuple]##The *SCALE codec* for *Tuple*
latexmath:[$T$] such that:

[latexmath]
++++
\[T :=(A_1, \ldots, A_n)\]
++++
Where latexmath:[$A_i$]’s are values of *different types*, is defined
as:

[latexmath]
++++
\[\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (T) :=\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (A_1) | |
     \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (A_2) | | \ldots | | \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (A_n)\]
++++

In case of a tuple (or struct), the knowledge of the shape of data is
not encoded even though it is necessary for decoding. The decoder needs
to derive that information from the context where the encoding/decoding
is happenning.

latexmath:[$\text{\text{}{\textbf{Dec\ensuremath{_{\textrm{SC}}}\text{}(d)}}}$]
refers to the decoding of a blob of data. Since the SCALE codec is not
self-describing, it’s up to the decoder to validate whether the blob of
data can be deserialized into the given type or datastructure.

[#defn-varrying-data-type]##[defn-varrying-data-type]##We define a
*varying data* type to be an ordered set of data types

[latexmath]
++++
\[\mathcal{T}= \{ T_1, \ldots, T_n \}\]
++++
A value latexmath:[$\ensuremath{\boldsymbol{A}}$] of varying date type
is a pair latexmath:[$(A_{\ensuremath{\operatorname{Type}}},
  A_{\ensuremath{\operatorname{Value}}})$] where
latexmath:[$A_{\ensuremath{\operatorname{Type}}} = T_i$] for some
latexmath:[$T_i \in
  \mathcal{T}$] and latexmath:[$A_{\ensuremath{\operatorname{Value}}}$]
is its value of type latexmath:[$T_i$], which can be empty. We define
latexmath:[$\ensuremath{\operatorname{idx}} (T_i) = i - 1$], unless it
is explicitly defined as another value in the definition of a particular
varying data type.

In particular, we define two specific varying data which are frequently
used in various part of Polkadot Protocol.

latexmath:[$\label{defn-option-type}$]The *Option* type is a varying
data type of latexmath:[$\{\ensuremath{\operatorname{None}}, T_2 \}$]
which indicates if data of latexmath:[$T_2$] type is available (referred
to as ``some'' state) or not (referred to as ``empty'', ``none'' or
``null'' state). The presence of type None, indicated by
latexmath:[$\ensuremath{\operatorname{idx}} (T_{\ensuremath{\operatorname{None}}}) = 0$],
implies that the data corresponding to latexmath:[$T_2$] type is not
available and contains no additional data. Where as the presence of type
latexmath:[$T_2$] indicated by
latexmath:[$\ensuremath{\operatorname{idx}} (T_2) = 1$] implies that the
data is available.

[#defn-result-type]##[defn-result-type]##The *Result* type is a varying
data type of latexmath:[$\{ T_1, T_2 \}$] which is used to indicate if a
certain operation or function was executed successfully (referred to as
``ok'' state) or not (referred to as ``err'' state). latexmath:[$T_1$]
implies success, latexmath:[$T_2$] implies failure. Both types can
either contain additional data or are defined as empty type otherwise.

[#defn-scale-variable-type]##[defn-scale-variable-type]##Scale coded for
value *latexmath:[$A =
  (A_{\ensuremath{\operatorname{Type}}}, A_{\ensuremath{\operatorname{Value}}})$]
of varying data type* latexmath:[$\mathcal{T}= \{
  T_1, \ldots, T_n \}$]

[latexmath]
++++
\[\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (A) :=\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (\ensuremath{\operatorname{Idx}}
     (A_{\ensuremath{\operatorname{Type}}})) | | \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (A_{\ensuremath{\operatorname{Value}}})\]
++++
Where latexmath:[$\ensuremath{\operatorname{Idx}}$] is encoded in a
fixed length integer determining the type of latexmath:[$A$].

In particular, for the optional type defined in Definition
link:#defn-varrying-data-type[[defn-varrying-data-type]], we have:

[latexmath]
++++
\[\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} ((\ensuremath{\operatorname{None}}, \phi)) :=0_{\mathbb{B}_1}\]
++++

SCALE codec does not encode the correspondence between the value of
latexmath:[$\ensuremath{\operatorname{Idx}}$] defined in Definition
link:#defn-scale-variable-type[[defn-scale-variable-type]] and the data
type it represents; the decoder needs prior knowledge of such
correspondence to decode the data.

[#defn-scale-list]##[defn-scale-list]##The *SCALE codec* for *sequence*
latexmath:[$S$] such that:

[latexmath]
++++
\[S :=A_1, \ldots, A_n\]
++++
where latexmath:[$A_i$]’s are values of *the same type* (and the decoder
is unable to infer value of latexmath:[$n$] from the context) is defined
as:

[latexmath]
++++
\[\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (S) :=\ensuremath{\operatorname{Enc}}^{\ensuremath{\operatorname{Len}}}_{\ensuremath{\operatorname{SC}}}
     (\| S \|) | \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (A_1) | \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (A_2) |
     \ldots | \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (A_n)\]
++++
where
latexmath:[$\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}}^{\ensuremath{\operatorname{Len}}}$]
is defined in Definition
link:#defn-sc-len-encoding[[defn-sc-len-encoding]].

SCALE codec for *dictionary* or *hashtable* D with key-value pairs
latexmath:[$(k_i, v_i)$]s such that:

[latexmath]
++++
\[D :=\{ (k_1, v_1), \ldots, (k_1, v_n) \}\]
++++
is defined the SCALE codec of latexmath:[$D$] as a sequence of key value
pairs (as tuples):

[latexmath]
++++
\[\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} (D) :=\ensuremath{\operatorname{Enc}}^{\ensuremath{\operatorname{Size}}}_{\ensuremath{\operatorname{SC}}}
     (| | D | |) | \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} ((k_1, v_1) ) |
     \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} ((k_2, v_2)) | \ldots | \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}}
     ((k_n, v_n))\]
++++
latexmath:[$\ensuremath{\operatorname{Enc}}^{\ensuremath{\operatorname{Size}}}_{\ensuremath{\operatorname{SC}}}$]
is encoded the same way as
latexmath:[$\ensuremath{\operatorname{Enc}}^{\ensuremath{\operatorname{Len}}}_{\ensuremath{\operatorname{SC}}}$]
but argument latexmath:[$\ensuremath{\operatorname{size}}$] refers to
the number of key-value pairs rather than the length.

The *SCALE codec* for *boolean value* latexmath:[$b$] defined as a byte
as follows:

[latexmath]
++++
\[\begin{array}{ll}
       \ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}} : & \{ \ensuremath{\operatorname{False}}, \ensuremath{\operatorname{True}} \} \rightarrow
       \mathbb{B}_1\\
       & b \rightarrow \left\{ \begin{array}{lcl}
         0 &  & b = \ensuremath{\operatorname{False}}\\
         1 &  & b = \ensuremath{\operatorname{True}}
       \end{array} \right.
     \end{array}\]
++++

[#defn-scale-fixed-length]##[defn-scale-fixed-length]##The *SCALE codec,
latexmath:[$\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}}$]*
for other types such as fixed length integers not defined here
otherwise, is equal to little endian encoding of those values defined in
Definition link:#defn-little-endian[[defn-little-endian]].

[#defn-scale-empty]##[defn-scale-empty]##The *SCALE codec,
latexmath:[$\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{SC}}}$]*
for an empty type is defined to a byte array of zero length and depicted
as *latexmath:[$\phi$]*.

[[sect-int-encoding]]
==== Length and Compact Encoding

_SCALE Length encoding_ is used to encode integer numbers of variying
sizes prominently in an encoding length of arrays:

[#defn-sc-len-encoding]##[defn-sc-len-encoding]##*SCALE Length Encoding,
latexmath:[$\ensuremath{\operatorname{Enc}}^{\ensuremath{\operatorname{Len}}}_{\ensuremath{\operatorname{SC}}}$]*
also known as compact encoding of a non-negative integer number
latexmath:[$n$] is defined as follows:

[latexmath]
++++
\[\begin{array}{ll}
       \ensuremath{\operatorname{Enc}}^{\ensuremath{\operatorname{Len}}}_{\ensuremath{\operatorname{SC}}} : & \mathbb{N} \rightarrow
       \mathbb{B}\\
       & n \rightarrow b :=\left\{ \begin{array}{lll}
         l^{}_1 &  & 0 \leqslant n < 2^6\\
         i^{}_1 i^{}_2 &  & 2^6 \leqslant n < 2^{14}\\
         j^{}_1 j^{}_2 j_3 &  & 2^{14} \leqslant n <
         2^{30}\\
         k_1^{} k_2^{} \ldots k_m^{}  &  & 2^{30}
         \leqslant n
       \end{array} \right.
     \end{array}\]
++++
in where the least significant bits of the first byte of byte array b
are defined as follows:

[latexmath]
++++
\[\begin{array}{lcc}
       l^1_1 l_1^0 & = & 00\\
       i^1_1 i_1^0 & = & 01\\
       j^1_1 j_1^0 & = & 10\\
       k^1_1 k_1^0 & = & 11
     \end{array}\]
++++
and the rest of the bits of latexmath:[$b$] store the value of
latexmath:[$n$] in little-endian format in base-2 as follows:

[latexmath]
++++
\[\left. \begin{array}{lll}
       l^7_1 \ldots l^3_1 l^2_1 &  & n < 2^6\\
       i_2^7 \ldots i_2^0 i_1^7 {\ldots i^2_1}^{} &  & 2^6 \leqslant
       n < 2^{14}\\
       j_4^7 \ldots j_4^0 j_3^7 \ldots j_1^7 \ldots j^2_1 &  & 2^{14}
       \leqslant n < 2^{30}\\
       k_2 + k_3 2^8 + k_4 2^{2 \cdot 8} + \cdots + k_m 2^{(m - 2) 8} &  &
       2^{30} \leqslant n
     \end{array} \right\} :=n\]
++++
such that:

[latexmath]
++++
\[k^7_1 \ldots k^3_1 k^2_1 : = m - 4\]
++++

=== Hex Encoding

Practically, it is more convenient and efficient to store and process
data which is stored in a byte array. On the other hand, the Trie keys
are broken into 4-bits nibbles. Accordingly, we need a method to encode
sequences of 4-bits nibbles into byte arrays canonically:

[#defn-hex-encoding]##[defn-hex-encoding]##Suppose that
latexmath:[$\ensuremath{\operatorname{PK}} = (k_1, \ldots, k_n)$] is a
sequence of nibbles, then

l
latexmath:[$\ensuremath{\operatorname{Enc}}_{\ensuremath{\operatorname{HE}}} (\ensuremath{\operatorname{PK}}) :=$] +
latexmath:[$\left\{ \begin{array}{lll}
      \ensuremath{\operatorname{Nibbles}}_4 & \rightarrow & \mathbb{B}\\
      \ensuremath{\operatorname{PK}} = (k_1, \ldots, k_n) & \mapsto & \left\{ \begin{array}{l}
        \begin{array}{ll}
          (16 k_1 + k_2, \ldots, 16 k_{2 i - 1} + k_{2 i}) & n = 2 i\\
          (k_1, 16 k_2 + k_3, \ldots, 16 k_{2 i} + k_{2 i + 1}) & n = 2 i + 1
        \end{array}
      \end{array} \right.
    \end{array} \right.$]

 

latexmath:[$\Box$]

 

[[sect-genesis-block]]
== Genesis State Specification

The genesis state is a set of key-value pairs representing the intial
state of the Polkadot state storage. It can be retrieved from . While
each of those key-value pairs offers important identifyable information
to the Runtime, to the Polkadot Host they are a transparent set of
arbitrary chain- and network-dependent keys and values. The only
exception to this are the and keys as described in Section
link:#sect-loading-runtime-code[3.1.1] and
link:#sect-memory-management[3.1.2.1], which are used by the Polkadot
Host to initialize the WASM environment and its Runtime. The other keys
and values are unspecifed and soley depend on the chain and respectively
its corresponding Runtime. On initialization the data should be inserted
into the state storage with the Host API, as defined in Section
link:#sect-storage-set[12.1.1].

 

As such, Polkadot does not defined a formal genesis block. Nonetheless
for the compatibility reasons in several algorithms, the Polkadot Host
defines the _genesis header_ according to Definition
link:#defn-genesis-header[[defn-genesis-header]]. By the abuse of
terminalogy, ``_genesis block_'' refers to the hypothetical parent of
block number 1 which holds genisis header as its header.

[#defn-genesis-header]##[defn-genesis-header]##The Polkadot genesis
header is a data structure conforming to block header format described
in section link:#defn-block-header[[defn-block-header]]. It contains the
values depicted in Table link:#tabl-genesis-header[11.1]:

[[tabl-genesis-header]]
.[#tabl-genesis-header]##[tabl-genesis-header]##Genesis header values
[cols="<,<",options="header",]
|===
|Block header field |Genesis Header Value
| |0

|[.sans-serif]#number# |0

| |Merkle hash of the state storage trie as defined in Definition
link:#defn-merkle-value[[defn-merkle-value]]

| |after inserting the genesis state in it.

|[.sans-serif]#extrinsics_root# |0

|[.sans-serif]#digest# |0
|===

 

latexmath:[$\Box$]

 

[[sect-host-api]]
== Polkadot Host API

The Polkadot Host API is a set of functions that the Polkadot Host
exposes to Runtime to access external functions needed for various
reasons, such as the Storage of the content, access and manipulation,
memory allocation, and also efficiency. The encoding of each data type
is specified or referenced in this section. If the encoding is not
mentioned, then the default Wasm encoding is used, such as little-endian
byte ordering for integers.

[#nota-host-api-at-state]##[nota-host-api-at-state]##By
latexmath:[$\mathcal{R}\mathcal{E}_B$] we refer to the API exposed by
the Polkadot Host which interact, manipulate and response based on the
state storage whose state is set at the end of the execution of block
latexmath:[$B$].

[#defn-runtime-pointer]##[defn-runtime-pointer]##The type is a integer
representing a pointer to data in memory. This pointer is the primary
way to exchange data of fixed/known size between the Runtime and
Polkadot Host.

[#defn-runtime-pointer-size]##[defn-runtime-pointer-size]##The *Runtime
pointer-size* type is an integer, representing two consecutive integers.
The least significant is a pointer to the data in memory. The most
significant provides the size of the data in bytes. This representation
is the primary way to exchange data of arbitrary/dynamic sizes between
the Runtime and the Polkadot Host.

[#defn-lexicographic-ordering]##[defn-lexicographic-ordering]##*Lexicographic
ordering* refers to the ascending ordering of bytes or byte arrays, such
as:

[latexmath]
++++
\[[0, 0, 2] < [0, 1, 1] < [0, 2, 0] < [1] < [1, 1, 0] < [2] < [\ldots]\]
++++

The functions are specified in each subsequent subsection for each
category of those functions.

=== Storage

Interface for accessing the storage from within the runtime.

[[sect-storage-set]]
==== 

Sets the value under a given key into storage.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] containing
the key.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] containing
the value.

[[section]]
==== 

Retrieves the value associated with the given key from storage.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] containing
the key.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] returning
the SCALE encoded as defined in Definition
link:#defn-option-type[[defn-option-type]] containing the value.

[[section-1]]
==== 

Gets the given key from storage, placing the value into a buffer and
returning the number of bytes that the entry in storage has beyond the
offset.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] containing
the key.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] containing
the buffer to which the value will be written to. This function will
never write more then the length of the buffer, even if the value’s
length is bigger.
* : an u32 integer containing the offset beyond the value should be read
from.
* : a pointer-size (Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]]) pointing
to a SCALE encoded (Definition
link:#defn-option-type[[defn-option-type]]) containing an unsinged
32-bit interger representing the number of bytes left at supplied .
Returns if the entry does not exists.

[[section-2]]
==== 

Clears the storage of the given key and its value.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] containing
the key.

[[section-3]]
==== 

Checks whether the given key exists in storage.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] containing
the key.
* : an i32 integer value equal to if the key exists or a value equal to
if otherwise.

[[section-4]]
==== 

Clear the storage of each key/value pair where the key starts with the
given prefix.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] containing
the prefix.

[[section-5]]
==== 

Append the SCALE encoded value to a SCALE encoded sequence (Definition
link:#defn-scale-list[[defn-scale-list]]) at the given key. This
function assumes that the existing storage item is either empty or a
SCALE encoded sequence and that the value to append is also SCALE
encoded and of the same type as the items in the existing sequence.

 

To improve performance, this function is allowed to skip decoding the
entire SCALE encoded sequence and instead can just append the new item
to the end of the existing data and increment the length prefix
latexmath:[$\ensuremath{\operatorname{Enc}}^{\ensuremath{\operatorname{Len}}}_{\ensuremath{\operatorname{SC}}}$].

 

*Warning*: If the storage item does not exist or is not SCALE encoded,
the storage item will be set to the specified value, represented as a
SCALE encoded byte array.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] containing
the key.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] containing
the value to be appended.

[[section-6]]
==== 

Compute the storage root.

===== Version 1 - Prototype

*Arguments*:

* : a 32-bit pointer to the buffer containing the 256-bit Blake2 storage
root.

[[sect-ext-storage-changes-root]]
==== 

Compute the root of the Changes Trie as described in Section
link:#sect-changes-trie[3.3.4]. The parent hash is a SCALE encoded block
hash.

===== Version 1 - Prototype

*Arguments*:

* **: a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the SCALE encoded block hash.
* : a 32-bit pointer to the buffer containing the 256-bit Blake2 changes
root.

[[section-7]]
==== 

Get the next key in storage after the given one in lexicographic order
(Definition
link:#defn-lexicographic-ordering[[defn-lexicographic-ordering]]). The
key provided to this function may or may not exist in storage.

===== Version 1 - Prototype

*Arguments*:

* **: a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the key.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the SCALE encoded as defined in Definition
link:#defn-option-type[[defn-option-type]] containing the next key in
lexicographic order.

[[sect-ext-storage-start-transaction]]
==== 

Start a new nested transaction. This allows to either commit or roll
back all changes that are made after this call. For every transaction
there must be a matching call to either
(link:#sect-ext-storage-rollback-transaction[12.1.12]) or
(link:#sect-ext-storage-commit-transaction[12.1.13]). This is also
effective for all values manipulated using the child storage API
(link:#sect-child-storage-api[12.2]).

 

*Warning*: This is a low level API that is potentially dangerous as it
can easily result in unbalanced transactions. Runtimes should use high
level storage abstractions.

===== Version 1 - Prototype

 

*Arguments*:

* None.

[[sect-ext-storage-rollback-transaction]]
==== 

Rollback the last transaction started by
(link:#sect-ext-storage-start-transaction[12.1.11]). Any changes made
during that transaction are discarded.

 

*Warning*: Panics if there is no open transaction (
(link:#sect-ext-storage-start-transaction[12.1.11]) was not called)

===== Version 1 - Prototype

 

*Arguments*:

* None.

[[sect-ext-storage-commit-transaction]]
==== 

Commit the last transaction started by
(link:#sect-ext-storage-start-transaction[12.1.11]). Any changes made
during that transaction are committed to the main state.

 

*Warning*: Panics if there is no open transaction (
(link:#sect-ext-storage-start-transaction[12.1.11]) was not called)

===== Version 1 - Prototype

 

*Arguments*:

* None.

[[sect-child-storage-api]]
=== Child Storage

Interface for accessing the child storage from within the runtime.

[#defn-child-storage-type]##[defn-child-storage-type]##*Child storage*
key is a unprefixed location of the child trie in the main trie.

[[section-8]]
==== 

Sets the value under a given key into the child storage.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the child storage key as defined in Definition
link:#defn-child-storage-type[[defn-child-storage-type]].
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the key.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the value.

[[section-9]]
==== 

Retrieves the value associated with the given key from the child
storage.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the child storage key as defined in Definition
link:#defn-child-storage-type[[defn-child-storage-type]].
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the key.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the SCALE encoded as defined in Definition
link:#defn-option-type[[defn-option-type]] containing the value.

[[section-10]]
==== 

Gets the given key from storage, placing the value into a buffer and
returning the number of bytes that the entry in storage has beyond the
offset.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the child storage key as defined in Definition
link:#defn-child-storage-type[[defn-child-storage-type]].
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the key.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the buffer to which the value will be written to. This function will
never write more then the length of the buffer, even if the value’s
length is bigger.
* : an u32 integer containing the offset beyond the value should be read
from.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the SCALE encoded as defined in Definition
link:#defn-option-type[[defn-option-type]] containing the number of
bytes written into the *value_out* buffer. Returns if the entry does not
exists.

[[section-11]]
==== 

Clears the storage of the given key and its value from the child
storage.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the child storage key as defined in Definition
link:#defn-child-storage-type[[defn-child-storage-type]].
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the key.

[[section-12]]
==== 

Clears an entire child storage.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the child storage key as defined in Definition
link:#defn-child-storage-type[[defn-child-storage-type]].

[[section-13]]
==== 

Checks whether the given key exists in the child storage.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the child storage key as defined in Defintion
link:#defn-child-storage-type[[defn-child-storage-type]].
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the key.
* : an i32 integer value equal to if the key exists or a value equal to
if otherwise.

[[section-14]]
==== 

Clears the child storage of each key/value pair where the key starts
with the given prefix.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the child storage key as defined in Definition
link:#defn-child-storage-type[[defn-child-storage-type]].
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the prefix.

[[section-15]]
==== 

Commits all existing operations and computes the resulting child storage
root.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the child storage key as defined in Definition
link:#defn-child-storage-type[[defn-child-storage-type]].
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the SCALE encoded storage root.

[[section-16]]
==== 

Gets the next key in storage after the given one in lexicographic order
(Definition
link:#defn-lexicographic-ordering[[defn-lexicographic-ordering]]). The
key provided to this function may or may not exist in storage.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the child storage key as defined in Definition
link:#defn-child-storage-type[[defn-child-storage-type]].
* **: a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the key.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the SCALE encoded as defined in Definition
link:#defn-option-type[[defn-option-type]] containing the next key in
lexicographic order. Returns if the entry cannot be found.

=== Crypto

Interfaces for working with crypto related types from within the
runtime.

[#defn-key-type-id]##[defn-key-type-id]##Cryptographic keys are stored
in seperate key stores based on their intended use case. The seperate
key stores are identified by a 4-byte ASCII *key type identifier*. The
following known types are available:

.Table of known key type identifiers
[cols="<,<",options="header",]
|===
|*Id* |*Description*
|acco |Key type for the controlling accounts
|babe |Key type for the Babe module
|gran |Key type for the Grandpa module
|imon |Key type for the ImOnline module
|audi |Key type for the AuthorityDiscovery module
|para |Key type for the Parachain Validator Key
|asgn |Key type for the Parachain Assignment Key
|===

[#defn-ecdsa-verify-error]##[defn-ecdsa-verify-error]##*EcdsaVerifyError*
is a varying data type as defined in Definition
link:#defn-varrying-data-type[[defn-varrying-data-type]] and specifies
the error type when using ECDSA recovery functionality. Following values
are possible:

.Table of error types in ECDSA recovery
[cols="<,<",]
|===
|*Id* |*Description*
|0 |Incorrect value of R or S
|1 |Incorrect value of V
|2 |Invalid signature
|===

[[section-17]]
==== 

Returns all public keys for the given key identifier from the keystore.

===== Version 1 - Prototype

*Arguments*:

* **: a 32-bit pointer to the key type identifier as defined in
Defintion link:#defn-key-type-id[[defn-key-type-id]].
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] to an SCALE
encoded  256-bit public keys.

[[section-18]]
==== 

Generates an key for the given key type using an optional BIP-39 seed
and stores it in the keystore.

 

*Warning*: Panics if the key cannot be generated, such as when an
invalid key type or invalid seed was provided.

===== Version 1 - Prototype

*Arguments*:

* **: a 32-bit pointer to the key type identifier as defined in
Definition link:#defn-key-type-id[[defn-key-type-id]].
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the SCALE encoded as defined in Definition
link:#defn-option-type[[defn-option-type]] containing the BIP-39 seed
which must be valid UTF8.
* : a 32-bit pointer to the buffer containing the 256-bit public key.

[[section-19]]
==== 

Signs the given message with the key that corresponds to the given
public key and key type in the keystore.

===== Version 1 - Prototype

*Arguments*:

* **: a 32-bit pointer to the key type identifier as defined in
Definition link:#defn-key-type-id[[defn-key-type-id]].
* : a 32-bit pointer to the buffer containing the 256-bit public key.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the message that is to be signed.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the SCALE encoded as defined in Definition
link:#defn-option-type[[defn-option-type]] containing the 64-byte
signature. This function returns if the public key cannot be found in
the key store.

[[sect-ext-crypto-ed25519-verify]]
==== 

Verifies an signature. Returns when the verification is either
successful or batched. If no batching verification extension is
registered, this function will fully verify the signature and return the
result. If batching verification is registered, this function will push
the data to the batch and return immediately. The caller can then get
the result by calling
(link:#sect-ext-crypto-finish-batch-verify[12.3.16]).

 

The verification extension is explained more in detail in
(link:#sect-ext-crypto-start-batch-verify[12.3.15]).

===== Version 1 - Prototype

*Arguments*:

* **: a 32-bit pointer to the buffer containing the 64-byte signature.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the message that is to be verified.
* : a 32-bit pointer to the buffer containing the 256-bit public key.
* : a i32 integer value equal to if the signature is valid or batched or
a value equal to if otherwise.

[[section-20]]
==== 

Returns all public keys for the given key id from the keystore.

===== Version 1 - Prototype

*Arguments*:

* **: a 32-bit pointer to the key type identifier as defined in
link:#defn-key-type-id[[defn-key-type-id]].
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the SCALE encoded 256-bit public keys.

[[section-21]]
==== 

Generates an key for the given key type using an optional BIP-39 seed
and stores it in the keystore.

 

*Warning*: Panics if the key cannot be generated, such as when an
invalid key type or invalid seed was provided.

===== Version 1 - Prototype

*Arguments*:

* **: a 32-bit pointer to the key identifier as defined in Definition
link:#defn-key-type-id[[defn-key-type-id]].
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the SCALE encoded as defined in Definition
link:#defn-option-type[[defn-option-type]] containing the BIP-39 seed
which must be valid UTF8.
* : a 32-bit pointer to the buffer containing the 256-bit public key.

[[section-22]]
==== 

Signs the given message with the key that corresponds to the given
public key and key type in the keystore.

===== Version 1 - Prototype

*Arguments*:

* **: a 32-bit pointer to the key identifier as defined in Definition
link:#defn-key-type-id[[defn-key-type-id]]
* : a 32-bit pointer to the buffer containing the 256-bit public key.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the message that is to be signed.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the SCALE encoded as defined in Definition
link:#defn-option-type[[defn-option-type]] containing the 64-byte
signature. This function returns if the public key cannot be found in
the key store.

[[sect-ext-crypto-sr25519-verify]]
==== 

Verifies an signature. Only version 1 of this function supports
deprecated Schnorr signatures introduced by the _schnorrkel_ Rust
library version 0.1.1 and should only be used for backward
compatibility.

 

Returns when the verification is either successful or batched. If no
batching verification extension is registered, this function will fully
verify the signature and return the result. If batching verification is
registered, this function will push the data to the batch and return
immediately. The caller can then get the result by calling
(link:#sect-ext-crypto-finish-batch-verify[12.3.16]).

 

The verification extension is explained more in detail in
(link:#sect-ext-crypto-start-batch-verify[12.3.15]).

===== Version 2 - Prototype

*Arguments*:

* **: a 32-bit pointer to the buffer containing the 64-byte signature.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the message that is to be verified.
* : a 32-bit pointer to the buffer containing the 256-bit public key.
* : a i32 integer value equal to if the signature is valid or a value
equal to if otherwise.

===== Version 1 - Prototype

*Arguments*:

* **: a 32-bit pointer to the buffer containing the 64-byte signature.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the message that is to be verified.
* : a 32-bit pointer to the buffer containing the 256-bit public key.
* : a i32 integer value equal to if the signature is valid or a value
equal to if otherwise.

[[section-23]]
==== 

Returns all public keys for the given key id from the keystore.

===== Version 1 - Prototype

*Arguments*:

* **: a 32-bit pointer to the key type identifier as defined in
link:#defn-key-type-id[[defn-key-type-id]].
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the SCALE encoded 33-byte compressed public keys.

[[section-24]]
==== 

Generates an key for the given key type using an optional BIP-39 seed
and stores it in the keystore.

 

*Warning*: Panics if the key cannot be generated, such as when an
invalid key type or invalid seed was provided.

===== Version 1 - Prototype

*Arguments*:

* **: a 32-bit pointer to the key identifier as defined in Definition
link:#defn-key-type-id[[defn-key-type-id]].
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the SCALE encoded as defined in Definition
link:#defn-option-type[[defn-option-type]] containing the BIP-39 seed
which must be valid UTF8.
* : a 32-bit pointer to the buffer containing the 33-byte compressed
public key.

[[section-25]]
==== 

Signs the given message with the key that corresponds to the given
public key and key type in the keystore.

===== Version 1 - Prototype

*Arguments*:

* **: a 32-bit pointer to the key identifier as defined in Definition
link:#defn-key-type-id[[defn-key-type-id]]
* : a 32-bit pointer to the buffer containing the 33-byte compressed
public key.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the message that is to be signed.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the SCALE encoded as defined in Definition
link:#defn-option-type[[defn-option-type]] containing the signature. The
signature is 65-bytes in size, where the first 512-bits represent the
signature and the other 8 bits represent the recovery ID. This function
returns if the public key cannot be found in the key store.

[[sect-ext-crypto-ecdsa-verify]]
==== 

Verifies an signature. Returns when the verification is either
successful or batched. If no batching verification extension is
registered, this function will fully verify the signature and return the
result. If batching verification is registered, this function will push
the data to the batch and return immediately. The caller can then get
the result by calling
(link:#sect-ext-crypto-finish-batch-verify[12.3.16]).

 

The verification extension is explained more in detail in
(link:#sect-ext-crypto-start-batch-verify[12.3.15]).

===== Version 1 - Prototype

*Arguments*:

* **: a 32-bit pointer to the buffer containing the 65-byte signature.
The signature is 65-bytes in size, where the first 512-bits represent
the signature and the other 8 bits represent the recovery ID.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the message that is to be verified.
* : a 32-bit pointer to the buffer containing the 33-byte compressed
public key.
* : a i32 integer value equal to if the signature is valid or a value
equal to if otherwise.

[[section-26]]
==== 

Verify and recover a ECDSA signature.

===== Version 1 - Prototype

*Arguments*:

* **: a 32-bit pointer to the buffer containing the 65-byte signature in
RSV format. V should be either or .
* : a 32-bit pointer to the buffer containing the 256-bit Blake2 hash of
the message.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the SCALE encoded as defined in Definition
link:#defn-result-type[[defn-result-type]]. On success it contains the
64-byte recovered public key or an error type as defined in Definition
link:#defn-ecdsa-verify-error[[defn-ecdsa-verify-error]] on failure.

[[section-27]]
==== 

Verify and recover a ECDSA signature.

===== Version 1 - Prototype

*Arguments*:

* **: a 32-bit pointer to the buffer containing the 65-byte signature in
RSV format. V should be either or .
* : a 32-bit pointer to the buffer containing the 256-bit Blake2 hash of
the message.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the SCALE encoded as defined in Definiton
link:#defn-result-type[[defn-result-type]]. On success it contains the
33-byte recovered public key in compressed form on success or an error
type as defined in Definition
link:#defn-ecdsa-verify-error[[defn-ecdsa-verify-error]] on failure.

[[sect-ext-crypto-start-batch-verify]]
==== 

Starts the verification extension. The extension is a separate
background process and is used to parallel-verify signatures which are
pushed to the batch with (link:#sect-ext-crypto-ed25519-verify[12.3.4]),
(link:#sect-ext-crypto-sr25519-verify[12.3.8]) or
(link:#sect-ext-crypto-ecdsa-verify[12.3.12]). Verification will start
immediatly and the Runtime can retrieve the result when calling
(link:#sect-ext-crypto-finish-batch-verify[12.3.16]).

===== Version 1 - Prototype

*Arguments*:

* None.

[[sect-ext-crypto-finish-batch-verify]]
==== 

Finish verifying the batch of signatures since the last call to this
function. Blocks until all the signatures are verified. Panics if the
verification extension was not registered
(link:#sect-ext-crypto-start-batch-verify[12.3.15]) was not called).

 

*Warning*: Panics if no verification extension is registered
(link:#sect-ext-crypto-start-batch-verify[12.3.15]) was not called.)

===== Version 1 - Prototype

*Arguments*:

* : an i32 integer value equal to if all the signatures are valid or a
value equal to if one or more of the signatures are invalid.

=== Hashing

Interface that provides functions for hashing with different algorithms.

[[section-28]]
==== 

Conducts a 256-bit Keccak hash.

===== Version 1 - Prototype

*Arguments*:

* **: a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the data to be hashed.
* : a 32-bit pointer to the buffer containing the 256-bit hash result.

[[section-29]]
==== 

Conducts a 512-bit Keccak hash.

===== Version 1 - Prototype

*Arguments*:

* **: a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the data to be hashed.
* : a 32-bit pointer to the buffer containing the 512-bit hash result.

[[section-30]]
==== 

Conducts a 256-bit Sha2 hash.

===== Version 1 - Prototype

*Arguments*:

* **: a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the data to be hashed.
* : a 32-bit pointer to the buffer containing the 256-bit hash result.

[[section-31]]
==== 

Conducts a 128-bit Blake2 hash.

===== Version 1 - Prototype

*Arguments*:

* **: a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the data to be hashed.
* : a 32-bit pointer to the buffer containing the 128-bit hash result.

[[section-32]]
==== 

Conducts a 256-bit Blake2 hash.

===== Version 1 - Prototype

*Arguments*:

* **: a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the data to be hashed.
* : a 32-bit pointer to the buffer containing the 256-bit hash result.

[[section-33]]
==== 

Conducts a 64-bit xxHash hash.

===== Version 1 - Prototype

*Arguments*:

* **: a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the data to be hashed.
* : a 32-bit pointer to the buffer containing the 64-bit hash result.

[[section-34]]
==== 

Conducts a 128-bit xxHash hash.

===== Version 1 - Prototype

*Arguments*:

* **: a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the data to be hashed.
* : a 32-bit pointer to the buffer containing the 128-bit hash result.

[[section-35]]
==== 

Conducts a 256-bit xxHash hash.

===== Version 1 - Prototype

*Arguments*:

* **: a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the data to be hashed.
* : a 32-bit pointer to the buffer containing the 256-bit hash result.

=== Trie

Interface that provides trie related functionality.

[[section-36]]
==== 

Compute a 256-bit Blake2 trie root formed from the iterated items.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the iterated items from which the trie root gets formed. The items
consist of a SCALE encoded array containing arbitrary key/value pairs.
* : a 32-bit pointer to the buffer containing the 256-bit trie root.

[[section-37]]
==== 

Compute a 256-bit Blake2 trie root formed from the enumerated items.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the enumerated items from which the trie root gets formed. The items
consist of a SCALE encoded array containing only values, where the
corresponding key of each value is the index of the item in the array,
starting at 0. The keys are compact encoded integers as described in
Definition link:#defn-sc-len-encoding[[defn-sc-len-encoding]].
* : a 32-bit pointer to the buffer containing the 256-bit trie root
result.

[[section-38]]
==== 

Compute a 256-bit Keccak trie root formed from the iterated items.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the iterated items from which the trie root gets formed. The items
consist of a SCALE encoded array containing arbitrary key/value pairs.
* result: a 32-bit pointer to the buffer containing the 256-bit trie
root.

[[section-39]]
==== 

Compute a 256-bit Keccak trie root formed from the enumerated items.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the enumerated items from which the trie root gets formed. The items
consist of a SCALE encoded array containing only values, where the
corresponding key of each value is the index of the item in the array,
starting at 0. The keys are compact encoded integers as described in
Definition link:#defn-sc-len-encoding[[defn-sc-len-encoding]].
* : a 32-bit pointer to the buffer containing the 256-bit trie root
result.

=== Miscellaneous

Interface that provides miscellaneous functions for communicating
between the runtime and the node.

[[section-40]]
==== 

Returns the current relay chain identifier.

===== Version 1 - Prototype

*Arguments*:

* : the current relay chain identifier.

[[section-41]]
==== 

Print a number.

===== Version 1 - Prototype

*Arguments*:

* : the number to be printed.

[[section-42]]
==== 

Print a valid buffer.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the valid buffer to be printed.

[[section-43]]
==== 

Print any buffer in hexadecimal representation.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the buffer to be printed.

[[section-44]]
==== 

Extract the Runtime version of the given Wasm blob by calling as defined
in Definition link:#defn-rt-core-version[13.3.1.1]. Returns the SCALE
encoded runtime version or as defined in Definition
link:#defn-option-type[[defn-option-type]] if the call fails. This
function gets primarily used when upgrading Runtimes.

 

*Warning*: Calling this function is very expensive and should only be
done very occasionally. For getting the runtime version, it requires
instantiating the Wasm blob as described in Section
link:#sect-loading-runtime-code[3.1.1] and calling a function in this
blob.

===== Version 1 - Prototype

*Arguments*:

* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the Wasm blob.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the SCALE encoded as defined in Definition
link:#defn-option-type[[defn-option-type]] containing the Runtime
version of the given Wasm blob.

[[sect-ext-allocator]]
=== Allocator

The Polkadot Runtime does not include a memory allocator and relies on
the Host API for all heap allocations. The beginning of this heap is
marked by the symbol exported by the Polkadot Runtime. No memory should
be allocated below that address, to avoid clashes with the stack and
data section. The same allocator made accessible by this Host API should
be used for any other WASM memory allocations and deallocations outside
the runtime e.g. when passing the SCALE-encoded parameters to Runtime
API calls.

[[section-45]]
==== 

Allocates the given number of bytes and returns the pointer to that
memory location.

===== Version 1 - Prototype

*Arguments*:

* : the size of the buffer to be allocated.
* : a 32-bit pointer to the allocated buffer.

[[section-46]]
==== 

Free the given pointer.

===== Version 1 - Prototype

*Arguments*:

* : a 32-bit pointer to the memory buffer to be freed.

=== Logging

Interface that provides functions for logging from within the runtime.

[#defn-logging-log-level]##[defn-logging-log-level]##*Log Level* is a
varying data type as defined in Definition
link:#defn-varrying-data-type[[defn-varrying-data-type]] and implies the
emergency of the log. Possible levels and it’s identifiers are defined
in the following table.

.Log Levels for the logging interface
[cols="<,<",options="header",]
|===
|*Id* |*Level*
|0 |Error = 1
|1 |Warn = 2
|2 |Info = 3
|3 |Debug = 4
|4 |Trace = 5
|===

[[section-47]]
==== 

Request to print a log message on the host. Note that this will be only
displayed if the host is enabled to display log messages with given
level and target.

 

===== Version 1 - Prototype

*Arguments*:

* : the log level as defined in Definition
link:#defn-logging-log-level[[defn-logging-log-level]].
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the string which contains the path, module or location from where the
log was executed.
* : a pointer-size as defined in Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]] indicating
the log message.

latexmath:[$\Box$]

 

[[sect-runtime-entries]]
== Polkadot Runtime API

=== General Information

The Polkadot Host assumes that at least the constants and functions
described in this Chapter are implemented in the Runtime Wasm blob.

It should be noted that the API can change through the Runtime updates.
Therefore, a host should check the API versions of each module returned
in the field by (Section link:#defn-rt-core-version[13.3.1.1]) after
every Runtime upgrade and warn if an updated API is encountered and that
this might require an update of the host.

[[sect-json-rpc-api]]
==== JSON-RPC API for external services

Polkadot Host implementers are encouraged to implement an API in order
for external, third-party services to interact with the node. The
https://github.com/w3f/PSPs/blob/master/PSPs/drafts/psp-6.md[JSON-RPC
Interface for Polkadot Nodes] (PSP Number 006) is a Polkadot Standard
Proposal for such an API and makes it easier to integrate the node with
existing tools available in the Polkadot ecosystem, such as
https://polkadot.js.org/[polkadot.js.org]. The Runtime API has a few
modules designed specifically for use in the official RPC API.

=== Runtime Constants

[[section-48]]
==== 

This constant indicates the beginning of the heap in memory. The space
below is reserved for the stack and the data section. For more details
please refer to Section link:#sect-ext-allocator[12.7].

=== Runtime Functions

In this section, we describe all Runtime API functions alongside their
arguments and the return values. The functions are organized into
modules with each being versioned independently.

[#defn-runtime-api-convention]##[defn-runtime-api-convention]##The
describes that all functions receive and return SCALE-encoded data and
as a result have the following prototype signature:

where points to the SCALE encoded tuple of the parameters passed to the
function and is the length of this data, while is a pointer-size
(Definition
link:#defn-runtime-pointer-size[[defn-runtime-pointer-size]]) to the
SCALE-encoded return data.

See Section link:#sect-code-executor[3.1.2] for more information about
the behaviour of the Wasm Runtime. Do note that any state changes
created by calling any of the Runtime functions are not necessarily to
be persisted after the call is ended. See Section
link:#sect-handling-runtime-state-update[3.1.2.4] for more information.

[[sect-runtime-core-module]]
==== Core Module (Version 3)

[[defn-rt-core-version]]
===== 

Returns the version identifiers of the Runtime. This function can be
used by the Polkadot Host implementation when it seems appropriate, such
as for the JSON-RPC API as described in Section
link:#sect-json-rpc-api[13.1.1].

 

*Arguments*:

* None

*Return*:

* A datastructure of the following format:
+
 
+
.Details of the version that the data type returns from the Runtime
function.
[cols="<,<,<",options="header",]
|===
|Name |Type |Description
| |String |Runtime identifier

| |String |the name of the implementation (e.g. C++)

| |UINT32 |the version of the authorship interface

| |UINT32 |the version of the Runtime specification

| |UINT32 |the version of the Runtime implementation

| |ApisVec (link:#defn-rt-apisvec[[defn-rt-apisvec]]) |List of supported
APIs along with their version

| |UINT32 |the version of the transaction format
|===
+
[#defn-rt-apisvec]##[defn-rt-apisvec]##*ApisVec* is a specialized type
for the (link:#defn-rt-core-version[13.3.1.1]) function entry. It
represents an array of tuples, where the first value of the tuple is an
array of 8-bytes containing the Blake2b hash of the API name. The second
value of the tuple is the version number of the corresponding API.
+
[latexmath]
++++
\[\begin{aligned}
      \ensuremath{\operatorname{ApiVec}} & :=& (T_0, \ldots, T_n)\\
      T & :=& ((b_0, \ldots, b_7), \ensuremath{\operatorname{UINT}} 32)
    \end{aligned}\]
++++

Requires to be called beforehand.

[[sect-rte-core-execute-block]]
===== 

This function executes a full block and all its extrinsics and updates
the state accordingly. Additionally, some integrity checks are executed
such as validating if the parent hash is correct and that the
transaction root represents the transactions. Internally, this function
performs an operation similar to the process described in Algorithm
link:#algo-build-block[[algo-build-block]], by calling , and .

 

This function should be called when a fully complete block is available
that is not actively being built on, such as blocks received from other
peers. State changes resulted from calling this function are usually
meant to persist when the block is imported successfully.

 

Additionally, the seal digest in the block header, as described in
Section link:#defn-digest[[defn-digest]], must be removed by the
Polkadot host before submitting the block.

 

*Arguments*:

* A block represented as a tuple consisting of a block header, as
described in Section link:#defn-block-header[[defn-block-header]], and
the block body, as described in Section
link:#defn-block-body[[defn-block-body]].

*Return*:

* None.

[[sect-rte-core-initialize-block]]
===== 

Sets up the environment required for building a new block as described
in Algorithm link:#algo-build-block[[algo-build-block]].

 

*Arguments*:

* The header of the new block as defined in
link:#defn-block-header[[defn-block-header]]. The values
latexmath:[$H_r, H_e \ensuremath{\operatorname{and}} H_d$] are left
empty.

*Return*:

* None.

[[sect-runtime-metadata-module]]
==== Metadata Module (Version 1)

[[section-49]]
===== 

Returns native Runtime metadata in an opaque form. This function can be
used by the Polkadot Host implementation when it seems appropriate, such
as for the JSON-RPC API as described in Section
link:#sect-json-rpc-api[13.1.1]. and returns all the information
necessary to build valid transactions.

 

*Arguments*:

* None.

*Return*:

* A byte array of varying size containing the metadata in an opaque
form.

[[sect-runtime-blockbuilder-module]]
==== BlockBuilder Module (Version 4)

All calls in this module require (Section
link:#sect-rte-core-initialize-block[13.3.1.3]) to be called beforehand.

[[sect-rte-apply-extrinsic]]
===== 

Apply the extrinsic outside of the block execution function. This does
not attempt to validate anything regarding the block, but it builds a
list of transaction hashes.

 

*Arguments*:

* A byte array of varying size containing the opaque extrinsic.

*Return*:

* Returns the varying datatype as defined in Definition
link:#defn-rte-apply-extrinsic-result[[defn-rte-apply-extrinsic-result]].
This structure lets the block builder know whether an extrinsic should
be included into the block or rejected.
+
 

[#defn-rte-apply-extrinsic-result]#[defn-rte-apply-extrinsic-result]# is
the varying data type as defined in Definition
link:#defn-result-type[[defn-result-type]]. This structure can contain
multiple nested structures, indicating either module dispatch outcomes
or transaction invalidity errors.

.Possible values of varying data type *ApplyExtrinsicResult*.
[cols="<,<,<",options="header",]
|===
|*Id* |*Description* |*Type*
|0 |Outcome of dispatching the extrinsic. |DispatchOutcome
(link:#defn-rte-dispatch-outcome[[defn-rte-dispatch-outcome]])

|1 |Possible errors while checking the |TransactionValidityError
(link:#defn-rte-transaction-validity-error[[defn-rte-transaction-validity-error]])

| |validity of a transaction. |
|===

As long as a
(link:#defn-rte-dispatch-outcome[[defn-rte-dispatch-outcome]]) is
returned, the extrinsic is always included in the block, even if the
outcome is a dispatch error. Dispatch errors do not invalidate the block
and all state changes are persisted.

[#defn-rte-dispatch-outcome]##[defn-rte-dispatch-outcome]##*DispatchOutcome*
is the varying data type as defined in Definition
link:#defn-result-type[[defn-result-type]].

.Possible values of varying data type *DispatchOutcome*.
[cols="<,<,<",options="header",]
|===
|*Id* |*Description* |*Type*
|0 |Extrinsic is valid and was submitted successfully. |None

|1 |Possible errors while dispatching the extrinsic. |DispatchError
(link:#defn-rte-dispatch-error[[defn-rte-dispatch-error]])
|===

[#defn-rte-dispatch-error]##[defn-rte-dispatch-error]##*DispatchError*
is a varying data type as defined in Definition
link:#defn-varrying-data-type[[defn-varrying-data-type]]. Indicates
various reasons why a dispatch call failed.

.Possible values of varying data type *DispatchError*.
[cols="<,<,<",options="header",]
|===
|*Id* |*Description* |*Type*
|0 |Some unknown error occurred. |SCALE encoded byte array contain-

| | |ing a valid UTF-8 sequence.

|1 |Failed to lookup some data. |None

|2 |A bad origin. |None

|3 |A custom error in a module. |CustomModuleError
(link:#defn-rte-custom-module-error[[defn-rte-custom-module-error]])
|===

[#defn-rte-custom-module-error]##[defn-rte-custom-module-error]##*CustomModuleError*
is a tuple appended after a possible error in as defined in Defintion
link:#defn-rte-dispatch-error[[defn-rte-dispatch-error]].

.Possible values of varying data type *CustomModuleError*.
[cols="<,<,<",options="header",]
|===
|*Name* |*Description* |*Type*
|Index |Module index matching the |Unsigned 8-bit integer.

| |metadata module index. |

|Error |Module specific error value. |Unsigned 8-bit integer

| | |

|Message |Optional error message. |Varying data type *Option*
(link:#defn-option-type[[defn-option-type]]).

| | |The optional value is a SCALE

| | |encoded byte array containing a

| | |valid UTF-8 sequence.
|===

Whenever
(link:#defn-rte-transaction-validity-error[[defn-rte-transaction-validity-error]])
is returned, the contained error type will indicate whether an extrinsic
should be outright rejected or requested for a later block. This
behaviour is clarified further in Definition
link:#defn-rte-invalid-transaction[[defn-rte-invalid-transaction]]
respectively Definition
link:#defn-rte-unknown-transaction[[defn-rte-unknown-transaction]].

[#defn-rte-transaction-validity-error]##[defn-rte-transaction-validity-error]##*TransactionValidityError*
is a varying data type as defined in Definition
link:#defn-varrying-data-type[[defn-varrying-data-type]]. It indicates
possible errors that can occur while checking the validity of a
transaction.

.Possible values of varying data type *TransactionValidityError*.
[cols="<,<,<",options="header",]
|===
|*Id* |*Description* |*Type*
|0 |Transaction is invalid. |InvalidTransaction
(link:#defn-rte-invalid-transaction[[defn-rte-invalid-transaction]])

|1 |Transaction validity can’t be determined. |UnknownTransaction
(link:#defn-rte-unknown-transaction[[defn-rte-unknown-transaction]])
|===

[#defn-rte-invalid-transaction]##[defn-rte-invalid-transaction]##*InvalidTransaction*
is a varying data type as defined in Definition
link:#defn-varrying-data-type[[defn-varrying-data-type]] and specifies
the invalidity of the transaction in more detail.

.Possible values of varying data type *InvalidTransaction*.
[cols="<,<,<,<",options="header",]
|===
|*Id* |*Description* |*Type* |*Reject*
|0 |Call of the transaction is not expected. |None |Yes
|1 |General error to do with the inability to pay |None |Yes
| |some fees (e.g. account balance too low). | |
|2 |General error to do with the transaction |None |No
| |not yet being valid (e.g. nonce too high). | |
|3 |General error to do with the transaction being |None |Yes
| |outdated (e.g. nonce too low). | |
|4 |General error to do with the transactions’ |None |Yes
| |proof (e.g. signature) | |
|5 |The transaction birth block is ancient. |None |Yes
|6 |The transaction would exhaust the resources |None |No
| |of the current block. | |
|7 |Some unknown error occured. |Unsigned |Yes
| | |8-bit integer |
|8 |An extrinsic with mandatory dispatch resulted |None |Yes
| |in an error. | |
|9 |A transaction with a mandatory dispatch (only in- |None |Yes
| |herents are allowed to have mandatory dispatch). | |
|===

[#defn-rte-unknown-transaction]##[defn-rte-unknown-transaction]##*UnknownTransaction*
is a varying data type as defined in Definition
link:#defn-varrying-data-type[[defn-varrying-data-type]] and specifies
the unknown invalidity of the transaction in more detail.

.Possible values of varying data type *UnknownTransaction*.
[cols="<,<,<,<",options="header",]
|===
|*Id* |*Description* |*Type* |*Reject*
|0 |Could not lookup some information that is required to |None |Yes
| |validate the transaction. | |
|1 |No validator found for the given unsigned transaction. |None |Yes
|2 |Any other custom unknown validity that is not covered |Unsigned |Yes
| |by this type. |8-bit integer |
|===

[[defn-rt-blockbuilder-finalize-block]]
===== 

Finalize the block - it is up to the caller to ensure that all header
fields are valid except for the state root. State changes resulting from
calling this function are usually meant to persist upon successful
execution of the function and appending of the block to the chain.

 

*Arguments*:

* None.

*Return*:

* The header of the new block as defined in
link:#defn-block-header[[defn-block-header]].

[[defn-rt-builder-inherent-extrinsics]]
===== 

Generates the inherent extrinsics, which are explained in more detail in
Section link:#sect-inherents[3.2.3]. This function takes a SCALE-encoded
hash table as defined in Section
link:#defn-scale-list[[defn-scale-list]] and returns an array of
extrinsics. The Polkadot Host must submit each of those to the ,
described in Section link:#sect-rte-apply-extrinsic[13.3.3.1]. This
procedure is outlined in Algorithm
link:#algo-build-block[[algo-build-block]].

 

*Arguments*:

* A Inherents-Data structure as defined in
link:#defn-inherent-data[[defn-inherent-data]].

*Return*:

* A byte array of varying size containing extrinisics. Each extrinsic is
a byte array of varying size.

[[section-50]]
===== 

Checks whether the provided inherent is valid. This function can be used
by the Polkadot Host when deemed appropriate, e.g. during the
block-building process.

 

*Arguments*:

* A block represented as a tuple consisting of a block header as
described in Section link:#defn-block-header[[defn-block-header]] and
the block body as described in Section
link:#defn-block-body[[defn-block-body]].
* A Inherents-Data structure as defined in
link:#defn-inherent-data[[defn-inherent-data]].

*Return*:

* A datastructure of the following format:
+
[latexmath]
++++
\[(o, f_e, e)\]
++++
where
** latexmath:[$o$] is a boolean indicating whether the check was
successful.
** latexmath:[$f_e$] is a boolean indicating whether a fatal error was
encountered.
** latexmath:[$e$] is a Inherents-Data structure as defined in
link:#defn-inherent-data[[defn-inherent-data]] containing any errors
created by this Runtime function.

[[sect-runtime-txqueue-module]]
==== TaggedTransactionQueue (Version 2)

All calls in this module require (Section
link:#sect-rte-core-initialize-block[13.3.1.3]) to be called beforehand.

[[sect-rte-validate-transaction]]
===== 

This entry is invoked against extrinsics submitted through a transaction
network message link:#sect-msg-transactions[4.8.3] or by an offchain
worker through the Host API (Section
link:#sect-ext-offchain-submit-transaction[[sect-ext-offchain-submit-transaction]]).
It indicates if the submitted blob represents a valid extrinsics, the
order in which it should be applied and if it should be gossiped to
other peers. Furthermore this function gets called internally when
executing blocks with the runtime function as described in Section
link:#sect-rte-core-execute-block[13.3.1.2].

 

*Arguments*:

* The source of the transaction as defined in Definition
link:#defn-transaction-source[[defn-transaction-source]].
* A byte array that contains the transaction.
+
 

[#defn-transaction-source]#[defn-transaction-source]# is an enum
describing the source of a transaction and can have one of the following
values:

.The enum
[cols="<,<,<",options="header",]
|===
|Id |Name |Description
|0 | |Transaction is already included in a block.
|1 | |Transaction is coming from a local source, e.g. off-chain worker.
|2 | |Transaction has been received externally, e.g. over the network.
|===

*Return*: This function returns a as defined in Definition
link:#defn-result-type[[defn-result-type]] which contains the type __ as
defined in Definition
link:#defn-valid-transaction[[defn-valid-transaction]] on success and
the type __ as defined in Definition
link:#defn-rte-transaction-validity-error[[defn-rte-transaction-validity-error]]
on failure.

[#defn-valid-transaction]##[defn-valid-transaction]##*ValidTransaction*
is a tuple that contains information concerning a valid transaction.

 

.The tuple provided by in the case the transaction is judged to be
valid.
[cols="<,<,<",options="header",]
|===
|*Name* |*Description* |*Type*
|Priority |Determines the ordering of two transactions that have
|Unsigned 64bit

| |all their dependencies (required tags) are satisfied. |integer

|Requires |List of tags specifying extrinsics which should be applied
|Array containing

| |before the current exrinsics can be applied. |inner arrays

|Provides |Informs Runtime of the extrinsics depending on the tags in
|Array containing

| |the list that can be applied after current extrinsics are being
applied. |inner arrays

| |Describes the minimum number of blocks for the validity to be correct
|

|Longevity |After this period, the transaction should be removed from
the |Unsigned 64bit

| |pool or revalidated. |integer

|Propagate |A flag indicating if the transaction should be gossiped to
|Boolean

| |other peers. |
|===

*Note*: If _Propagate_ is set to the transaction will still be
considered for inclusion in blocks that are authored on the current
node, but should not be gossiped to other peers.

 

*Note*: If this function gets called by the Polkadot Host in order to
validate a transaction received from peers, the Polkadot Host disregards
and rewinds state changes resulting in such a call.

[[sect-runtime-offchainapi-module]]
==== OffchainWorkerApi Module (Version 2)

Does not require (Section
link:#sect-rte-core-initialize-block[13.3.1.3]) to be called beforehand.

[[section-51]]
===== 

Starts an off-chain worker and generates extrinsics. [To do: when is
this called?]

 

*Arguments*:

* The block header as defined in
link:#defn-block-header[[defn-block-header]].

*Return*:

* None.

==== ParachainHost Module (Version 1)

[[section-52]]
===== 

{empty}[To do: future-reserved]

[[section-53]]
===== 

{empty}[To do: future-reserved]

[[section-54]]
===== 

{empty}[To do: future-reserved]

[[section-55]]
===== 

{empty}[To do: future-reserved]

[[section-56]]
===== 

{empty}[To do: future-reserved]

[[section-57]]
===== 

{empty}[To do: future-reserved]

[[section-58]]
===== 

{empty}[To do: future-reserved]

[[section-59]]
===== 

{empty}[To do: future-reserved]

[[section-60]]
===== 

{empty}[To do: future-reserved]

[[section-61]]
===== 

{empty}[To do: future-reserved]

[[section-62]]
===== 

{empty}[To do: future-reserved]

[[section-63]]
===== 

{empty}[To do: future-reserved]

[[section-64]]
===== 

{empty}[To do: future-reserved]

==== GrandpaApi Module (Version 2)

All calls in this module require (Section
link:#sect-rte-core-initialize-block[13.3.1.3]) to be called beforehand.

[[sect-rte-grandpa-auth]]
===== 

This entry fetches the list of GRANDPA authorities according to the
genesis block and is used to initialize an authority list at genesis,
defined in Definition link:#defn-authority-list[[defn-authority-list]].
Any future authority changes get tracked via Runtime-to-consensus engine
messages, as described in Section
link:#sect-consensus-message-digest[6.1.2].

 

*Arguments*:

* None.

*Return*:

* An authority list as defined in Definition
link:#defn-authority-list[[defn-authority-list]].

[[sect-grandpaapi_submit_report_equivocation_unsigned_extrinsic]]
===== 

A GRANDPA equivocation occurs when a validator votes for multiple blocks
during one voting subround, as described further in Section
link:#defn-equivocation[[defn-equivocation]]. The Polkadot Host is
expected to identify equivocators and report those to the Runtime by
calling this function.

 

*Arguments*:

* The equivocation proof of the following format:
+
[latexmath]
++++
\[\begin{aligned}
    G_{\ensuremath{\operatorname{Ep}}} & = & (\ensuremath{\operatorname{id}}_{\mathbb{V}}, e, r, A_{\ensuremath{\operatorname{id}}}, B^1_h,
    B^1_n A^1_{\ensuremath{\operatorname{sig}}}, B^2_h, B^2_n, A^2_{\ensuremath{\operatorname{sig}}})\\
    e & = & \left\{\begin{array}{l}
      0 \quad \text{{{\em Equivocation at prevote stage.\/}}}\\
      \text{1\quad{{\em Equivocation at precommit stage\/}}}
    \end{array}\right.
  \end{aligned}\]
++++
where
** latexmath:[$\ensuremath{\operatorname{id}}_{\mathbb{V}}$] is the
authority set as defined in Section
link:#defn-authority-set-id[[defn-authority-set-id]].
** latexmath:[$e$] indicates the stage at which the equivocation
occurred.
** latexmath:[$r$] is the round number the equivocation occurred.
** latexmath:[$A_{\ensuremath{\operatorname{id}}}$] is the public key of
the equivocator.
** latexmath:[$B^1_h$] is the block hash of the first block the
equivocator voted for.
** latexmath:[$B^1_n$] is the block number of the first block the
equivocator voted for.
** latexmath:[$A^1_{\ensuremath{\operatorname{sig}}}$] is the
equivocators signature of the first vote.
** latexmath:[$B^2_h$] is the block hash of the second block the
equivocator voted for.
** latexmath:[$B^2_n$] is the block number of the second block the
equivocator voted for.
** latexmath:[$A^2_{\ensuremath{\operatorname{sig}}}$] is the
equivocators signature of the second vote.
* A proof of the key owner in an opaque form as described in Section
link:#sect-grandpaapi_generate_key_ownership_proof[13.3.7.3].

*Return*:

* A SCALE encoded as defined in Definition
link:#defn-option-type[[defn-option-type]] containing an empty value on
success.

[[sect-grandpaapi_generate_key_ownership_proof]]
===== 

Generates proof of the membership of a key owner in the specified block
state. The returned value is used to report equivocations as described
in Section
link:#sect-grandpaapi_submit_report_equivocation_unsigned_extrinsic[13.3.7.2].

 

*Arguments*:

* The authority set Id as defined in Definition
link:#defn-authority-set-id[[defn-authority-set-id]].
* The 256-bit public key of the authority.

*Return*:

* A SCALE encoded as defined in Definition
link:#defn-option-type[[defn-option-type]] containing the proof in an
opaque form.

==== BabeApi Module (Version 2)

All calls in this module require (Section
link:#sect-rte-core-initialize-block[13.3.1.3]) to be called beforehand.

[[sect-rte-babeapi-epoch]]
===== 

This entry is called to obtain the current configuration of the BABE
consensus protocol.

 

*Arguments*:

* None.

*Return*:

* A tuple containing configuration data used by the Babe consensus
engine.

.The tuple provided by *BabeApi_configuration*.
[cols="<,<,<",options="header",]
|===
|*Name* |*Description* |*Type*
|SlotDuration |The slot duration in milliseconds. Currently, only the
value provided |Unsigned 64bit

| |by this type at genesis will be used. Dynamic slot duration may be
|integer

| |supported in the future. |

|EpochLength |The duration of epochs in slots. |Unsigned 64bit

| | |integer

|Constant |A constant value that is used in the threshold calculation
formula |Tuple containing

| |as defined in definition
link:#defn-babe-constant[[defn-babe-constant]]. |two unsigned

| | |64bit integers

| | |

|Genesis |The authority list for the genesis epoch as defined in
Definition link:#defn-authority-list[[defn-authority-list]]. |Array of
tuples

|Authorities | |containing a 256-bit

| | |byte array and a

| | |unsigned 64bit

| | |integer

|Randomness |The randomness for the genesis epoch |32-byte array

|SecondarySlot |Whether this chain should run with secondary slots and
wether |8bit enum

| |they are assigned in a round-robin manner or via a second VRF. |
|===

[[section-65]]
===== 

Finds the start slot of the current epoch.

 

*Arguments*:

* None.

*Return*:

* A unsigned 64-bit integer indicating the slot number.

[[sect-babeapi_current_epoch]]
===== 

Produces information about the current epoch.

 

*Arguments*:

* None.

*Return*:

* A datastructure of the following format:
+
[latexmath]
++++
\[(e_i, s_s, d, A, r)\]
++++
where:
** latexmath:[$e_i$] is a unsigned 64-bit integer representing the epoch
index.
** latexmath:[$s_s$] is a unsigned 64-bit integer representing the
starting slot of the epoch.
** latexmath:[$d$] is a unsigned 64-bit integer representing the
duration of the epoch.
** latexmath:[$A$] is an authority list as defined in Definition
link:#defn-authority-list[[defn-authority-list]].
** latexmath:[$r$] is an 256-bit array containing the randomness for the
epoch as defined in Definition
link:#defn-epoch-randomness[[defn-epoch-randomness]].

[[section-66]]
===== 

Produces information about the next epoch.

 

*Arguments*:

* None.

*Return*:

* Returns the same datastructure as described in Section
link:#sect-babeapi_current_epoch[13.3.8.3].

[[sect-babeapi_generate_key_ownership_proof]]
===== 

Generates a proof of the membership of a key owner in the specified
block state. The returned value is used to report equivocations as
described in Section
link:#sect-babeapi_submit_report_equivocation_unsigned_extrinsic[13.3.8.6].

 

*Arguments*:

* The unsigned 64-bit integer indicating the slot number.
* The 256-bit public key of the authority.

*Return*:

* A SCALE encoded as defined in Definition
link:#defn-option-type[[defn-option-type]] containing the proof in an
opaque form.

[[sect-babeapi_submit_report_equivocation_unsigned_extrinsic]]
===== 

A BABE equivocation occurs when a validator produces more than one block
at the same slot. The proof of equivocation are the given distinct
headers that were signed by the validator and which include the slot
number. The Polkadot Host is expected to identify equivocators and
report those to the Runtime using this function.

If there are more than two blocks which cause an equivocation, the
equivocation only needs to be reported once i.e. no additional
equivocations must be reported for the same slot.

*Arguments*:

* The equivocation proof of the following format:
+
[latexmath]
++++
\[\begin{aligned}
    B_{\ensuremath{\operatorname{Ep}}} & = & (A_{\ensuremath{\operatorname{id}}}, s, h_1, h_2)
  \end{aligned}\]
++++
where
** latexmath:[$A_{\ensuremath{\operatorname{id}}}$] is the public key of
the equivocator.
** latexmath:[$s$] is the slot as described in Section
link:#sect-babe[6.2] at which the equivocation occurred.
** latexmath:[$h_1$] is the block header of the first block produced by
the equivocator.
** latexmath:[$h_2$] is the block header of the second block produced by
the equivocator.
+
Unlike during block execution, the Seal in both block headers is not
removed before submission. The block headers are submitted in its full
form.
* An proof of the key owner in an opaque form as described in Section
link:#sect-babeapi_generate_key_ownership_proof[13.3.8.5].

*Return*:

* A SCALE encoded as defined in Definition
link:#defn-option-type[[defn-option-type]] containing an empty value on
success.

==== AuthorityDiscoveryApi Module (Version 1)

All calls in this module require (Section
link:#sect-rte-core-initialize-block[13.3.1.3]) to be called beforehand.

[[section-67]]
===== 

A function which helps to discover authorities.

 

*Arguments*:

* None.

*Return*:

* A byte array of varying size containing 256-bit pulic keys of the
authorities.

[[sect-runtime-sessionkeys-module]]
==== SessionKeys Module (Version 1)

All calls in this module require (Section
link:#sect-rte-core-initialize-block[13.3.1.3]) to be called beforehand.

[[section-68]]
===== 

Generates a set of session keys with an optional seed. The keys should
be stored within the keystore exposed by the Host Api. The seed needs to
be valid and UTF-8 encoded.

 

*Arguments*:

* A SCALE-encoded as defined in Definition
link:#defn-option-type[[defn-option-type]] containing an array of
varying sizes indicating the seed.

*Return*:

* A byte array of varying size containg the encoded session keys.

[[section-69]]
===== 

Decodes the given public session keys. Returns a list of raw public keys
including their key type.

 

*Arguments*:

* An array of varying size containing the encoded public session keys.

*Return*:

* An array of varying size containing tuple pairs of the following
format:
+
[latexmath]
++++
\[(k, k_{\ensuremath{\operatorname{id}}})\]
++++
where latexmath:[$k$] is an array of varying sizes containg the raw
public key and latexmath:[$k_{\ensuremath{\operatorname{id}}}$] is a
4-byte array indicating the key type.

==== AccountNonceApi Module (Version 1)

All calls in this module require (Section
link:#sect-rte-core-initialize-block[13.3.1.3]) to be called beforehand.

[[sect-accountnonceapi-account-nonce]]
===== 

Get the current nonce of an account. This function can be used by the
Polkadot Host implementation when it seems appropriate, such as for the
JSON-RPC API as described in Section link:#sect-json-rpc-api[13.1.1].

 

*Arguments*:

* The 256-bit public key of the account.

*Return*:

* A 32-bit unsigned integer indicating the nonce of the account.

==== TransactionPaymentApi Module (Version 1)

All calls in this module require (Section
link:#sect-rte-core-initialize-block[13.3.1.3]) to be called beforehand.

[[section-70]]
===== 

Returns information of a given extrinsic. This function is not aware of
the internals of an extrinsic, but only interprets the extrinsic as some
encoded value and accounts for its weight and length, the Runtime’s
extrinsic base weight and the current fee multiplier.

 

This function can be used by the Polkadot Host implementation when it
seems appropriate, such as for the JSON-RPC API as described in Section
link:#sect-json-rpc-api[13.1.1].

 

*Arguments*:

* A byte array of varying sizes containing the extrinsic.
* The length of the extrinsic. [To do: why is this needed?]

*Return*:

* A data structure of the following format:
+
[latexmath]
++++
\[(w, c, f)\]
++++
where:
** latexmath:[$w$] is the weight of the extrinsic.
** latexmath:[$c$] is the ``class'' of the extrinsic, where class is a
varying data type defined as:
+
[latexmath]
++++
\[c = \left\{\begin{array}{l}
         0 \quad \ensuremath{\operatorname{Normal}} \ensuremath{\operatorname{extrinsic}}\\
         1 \quad \ensuremath{\operatorname{Operational}} \ensuremath{\operatorname{extrinsic}}\\
         2 \quad \ensuremath{\operatorname{Mandatory}} \ensuremath{\operatorname{extrinsic}}, \ensuremath{\operatorname{which}} \ensuremath{\operatorname{is}}
         \ensuremath{\operatorname{always}} \ensuremath{\operatorname{included}}
       \end{array}\right.\]
++++
** latexmath:[$f$] is the inclusion fee of the extrinsic. This does not
include a tip or anything else that depends on the signature.

[[section-71]]
===== 

Query the detailed fee of a given extrinsic. This function can be used
by the Polkadot Host implementation when it seems appropriate, such as
for the JSON-RPC API as described in Section
link:#sect-json-rpc-api[13.1.1].

 

*Arguments*:

* A byte array of varying sizes containing the extrinsic.
* The length of the extrinsic.

*Return*:

* A data structure of the following format:
+
[latexmath]
++++
\[(f, t)\]
++++
where
** latexmath:[$f$] is a SCALE encoded as defined in Definition
link:#defn-option-type[[defn-option-type]] containing the following
datastructure:
+
[latexmath]
++++
\[(f_b, f_l, f_a)\]
++++
where
*** latexmath:[$f_b$] is the minimum required fee for an extrinsic.
*** latexmath:[$f_l$] is the length fee, the amount paid for the encoded
length (in bytes) of the extrinsic.
*** latexmath:[$f_a$] is the ``adjusted weight fee'', which is a
multiplication of the fee multiplier and the weight fee. The fee
multiplier varies depending on the usage of the network.
** latexmath:[$t$] is the tip for the block author.

latexmath:[$\Box$]

 

 

== Glossary

 

 
