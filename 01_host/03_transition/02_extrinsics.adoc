[#sect-extrinsics]
=== Extrinsics

The block body consists of an array of extrinsics. In a broad sense,
extrinsics are data from outside of the state which can trigger state
transitions. This section describes extrinsics and their inclusion into
blocks.

==== Preliminaries

The extrinsics are divided into two main categories defined as follows:

*Transaction extrinsics* are extrinsics which are signed using either of the key
types (<<sect-cryptographic-keys>>) and broadcasted between the nodes. *Inherent
extrinsics* are unsigned extrinsics which are generated by Polkadot Host and
only included in the blocks produced by the node itself. They are broadcasted as
part of the produced blocks rather than being gossiped as individual extrinsics.

The Polkadot Host does not specify or limit the internals of each extrinsics and
those are defined and dealt with by the Runtime (<<defn-state-machine>>). From the
Polkadot Host point of view, each extrinsics is simply a SCALE-encoded blob
(<<sect-scale-codec>>).

==== Transactions

Transaction are submitted and exchanged through _Transactions_ network messages
(<<sect-msg-transactions>>). Upon receiving a Transactions message, the Polkadot
Host decodes the SCALE-encoded blob and splits it into individually
SCALE-encoded transactions.

Alternative transaction can be submitted to the host by offchain worker through
the Host API (<<sect-ext-offchain-submit-transaction>>).

Any new transaction should be submitted to the Runtime
(<<sect-rte-validate-transaction>>). This will allow the Polkadot Host to check
the validity of the received transaction against the current stat and if it
should be gossiped to other peers. If it considers the submitted transaction as
valid, the Polkadot Host should store it for inclusion in future blocks. The
whole process of handling new transactions is described in more detail by
<<algo-validate-transactions>>.

Additionally valid transactions that are supposed to be gossiped are
propagated to connected peers of the Polkadot Host. While doing so the
Polkadot Host should keep track of peers already aware of each
transaction. This includes peers which have already gossiped the
transaction to the node as well as those to whom the transaction has
already been sent. This behavior is mandated to avoid resending
duplicates and unnecessarily overloading the network. To that aim, the
Polkadot Host should keep a _transaction pool_ and a _transaction queue_
defined as follows:

[#defn-transaction-queue]
.<<defn-transaction-queue,Transaction Queue>>
====
The *Transaction Queue* of a block producer node, formally referred to as
stem:[TQ] is a data structure which stores the transactions ready to be included
in a block sorted according to their priorities (<<sect-msg-transactions>>). The
*Transaction Pool*, formally referred to as stem:[TP], is a hash table in which
the Polkadot Host keeps the list of all valid transactions not in the
transaction queue.
====

Furthermore <<algo-validate-transactions>> updates the transaction pool and
the transaction queue according to the received message:

****
.Validate-Transactions-and-Store
[pseudocode#algo-validate-transactions]
++++
\state $L \leftarrow Dec_{SC}(M_T)$

\forall{$\{T \in L \mid T \notin TQ \mid T \notin TP\}$}

    \state $B_d \leftarrow$ \textsc{Head}$($\textsc{Longest-Chain}$(BT))$

    \state $N \leftarrow H_n(B_d)$

    \state $R \leftarrow$ \textsc{Call-Runtime-Entry}$\left(\texttt{TaggedTransactionQueue\_validate\_transaction}, N, T\right)$

    \if{\textsc{Valid}$(R)$}

        \if{\textsc{Requires}$(R) \subset \bigcup_{\forall T \in (TQ~\cup~B_i \mid \exists i < d)}$ \textsc{Provided-Tags}$(T)$}

            \state \textsc{Insert-At}$(TQ, T,$ \textsc{Requires}$(R),$ \textsc{Priority}$(R))$

        \else

            \state \textsc{Add-To}$(TP,T)$

        \endif

        \state \textsc{Maintain-Transaction-Pool}$()$

        \if{\textsc{ShouldPropagate}$(R)$}

            \state \textsc{Propagate}$(T)$

        \endif

    \endif

\endfor
++++

where::
* stem:[M_T] is the transaction message (offchain transactions?)
* stem:["Dec"_(SC)] decodes the SCALE encoded message.
* stem:["Longest-Chain"] is defined in <<defn-longest-chain>>.
* stem:[tt "TaggedTransactionQueue_validate_transaction"] is a Runtime entrypoint
specified in <<sect-rte-validate-transaction>> and stem:[Requires(R)],
stem:[Priority(R)] and stem:[Propagate(R)] refer to the corresponding fields in
the tuple returned by the entrypoint when it deems that stem:[T] is valid.
* stem:["Provided-Tags"(T)] is the list of tags that transaction stem:[T]
provides. The Polkadot Host needs to keep track of tags that transaction
stem:[T] provides as well as requires after validating it.
* stem:["Insert-At"(TQ,T,"Requires"(R),"Priority"(R))] places stem:[T]
into stem:[TQ] approperietly such
that the transactions providing the tags which stem:[T] requires
or have higher priority than stem:[T] are ahead of
stem:[T].
* stem:["Maintain-Transaction-Pool"] is described in <<algo-maintain-transaction-pool>>.
* stem:["ShouldPropagate"] indictes whether the transaction should be propagated
based on the `Propagate` field in the `ValidTransaction`` type as defined in 
<<defn-valid-transaction>>, which is returned by stem:[tt
"TaggedTransactionQueue_validate_transaction"].
* stem:["Propagate"(T)] sends stem:[T] to all connected
peers of the Polkadot Host who are not already aware of stem:[T].
****

****
.Maintain-Transaction-Pool
[pseudocode#algo-maintain-transaction-pool]
++++
\state Scan the pool for ready transactions
\state Move them to the transaction queue
\state Drop invalid transactions
++++

NOTE: This has not been defined yet.
****

[#sect-inherents]
==== Inherents

Inherents are unsigned extrinsics inserted into a block by the block author and
as a result are not stored in the transaction pool or gossiped across the
network. Instead they are generated by the Polkadot Host by passing the required
inherent data, as listed in <<tabl-inherent-data>>, to the Runtime method
stem:[tt "BlockBuilder_inherent_extrinsics"]
(<<defn-rt-builder-inherent-extrinsics>>). The then returned extrinsics should
be included in the current block as explained in <<algo-build-block>>.

[#tabl-inherent-data]
[cols="1,3,6"]
.Inherent Data
|===
|Identifier |Value Type |Description

|timstap0
|Unsigned 64-bit integer
|Unix epoch time (<<defn-unix-time>>)
|===

.<<defn-inherent-data, Inherent Data>>
[#defn-inherent-data]
====
`Inherent-Data` is a hashtable (<<defn-scale-list>>), an array of key-value
pairs consisting of the inherent 8-byte identifier and its value, representing
the totality of inherent extrinsics included in each block. The entries of this
hash table which are listed in <<tabl-inherent-data>> are collected or generated
by the Polkadot Host and then handed to the Runtime for inclusion
(<<algo-build-block>>).
====
