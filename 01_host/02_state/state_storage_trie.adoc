[#sect-state-storage]
=== State Storage and Storage Trie

For storing the state of the system, Polkadot Host implements a hash
table storage where the keys are used to access each data entry. There
is no assumption either on the size of the key nor on the size of the
data stored under them, besides the fact that they are byte arrays with
specific upper limits on their length. The limit is imposed by the
encoding algorithms to store the key and the value in the storage trie.

==== Accessing System Storage 

The Polkadot Host implements various functions to facilitate access to the
system storage for the Runtime (<<sect-entries-into-runtime>>). Here we
formalize the access to the storage when it is being directly accessed by the
Polkadot Host (in contrast to Polkadot runtime).

[#defn-stored-value]
.<<defn-stored-value, Stored Value>>
====
The stem:[sf "StoredValue"] function retrieves the value stored under a specific
key in the state storage and is formally defined as:

[stem]
++++
sf "StoredValue" ": " cc K -> cc V\
k -> {(v,"if " (k,v), "exists in state storage"),(phi,,"otherwise"):}
++++

where stem:[cc K sub bbb B] and stem:[cc V sub bbb B] are respectively
the set of all keys and values stored in the state storage.
====

==== The General Tree Structure

In order to ensure the integrity of the state of the system, the stored data
needs to be re-arranged and hashed in a _modified Merkle Patricia Tree_, which
hereafter we refer to as the _*Trie*_. This rearrangment is necessary to be able
to compute the Merkle hash of the whole or part of the state storage,
consistently and efficiently at any given time.

The Trie is used to compute the _state root_, stem:[H_r],
(<<defn-block-header>>), whose purpose is to authenticate the validity of the
state database. Thus, the Polkadot Host follows a rigorous encoding algorithm to
compute the values stored in the trie nodes to ensure that the computed Merkle
hash, stem:[H_r], matches across the Polkadot Host implementations.

The Trie is a _radix-16_ tree (<<defn-radix-tree>>). Each key value identifies a
unique node in the tree. However, a node in a tree might or might not be
associated with a key in the storage.

When traversing the Trie to a specific node, its key can be reconstructed by
concatenating the subsequences of the key which are stored either explicitly in
the nodes on the path or implicitly in their position as a child of their
parent.

To identify the node corresponding to a key value, stem:[k], first we need to
encode stem:[k] in a consistent with the Trie structure way. Because each node
in the trie has at most 16 children, we represent the key as a sequence of 4-bit
nibbles:

[#defn-trie-key-encode]
.<<defn-trie-key-encode, Key Encode>>
====
For the purpose of labeling the branches of the Trie, the key stem:[k] is
encoded to stem:[k_("enc")] using stem:[sf "KeyEncode"] functions:

[stem]
++++
k_("enc") := (k_("enc"_1), ..., k_("enc"_(2n))) := sf "KeyEncode"(k)
++++

such that:

[stem]
++++
sf "KeyEncode"(k): {(bbb B,->,"Nibbles"^4),(k:=(b_1,...,b_n),->,(b_1^(1),b_1^2,b_2^1,b_2^2,...,b_n^1,b_n^2)),(,,:=(k_("enc"_1),...,k_("enc"_(2n)))):}
++++

where stem:["Nibble"^4] is the set of all nibbles of 4-bit arrays and
stem:[b_i^1] and stem:[b_i^2] are 4-bit nibbles, which are the big endian
representations of stem:[b_i]:

[stem]
++++
(b_i^1,b_i^2) := (b_i -: 16,b_i mod 16)
++++
====

By looking at stem:[k_("enc")] as a sequence of nibbles, one can walk the radix
tree to reach the node identifying the storage value of stem:[k].

[#sect-state-storage-trie-structure]
==== Trie Structure

In this subsection, we specify the structure of the nodes in the Trie as
well as the Trie structure:

[#defn-trie-nodeset]
.<<defn-trie-nodeset, Set of Nodes>>
====
We refer to the *set of the nodes of Polkadot state trie* by stem:[cc N]. By
stem:[N in cc N] to refer to an individual node in the trie.
====

[#defn-nodetype]
.<<defn-nodetype, State Trie>>
====
The State Trie is a radix-16 tree. Each Node in the Trie is identified with a
unique key latexmath:[k_N] such that:

* stem:[k_N] is the shared prefix of the key of all the
descendants of stem:[N] in the Trie.

and, at least one of the following statements holds:

* stem:[(k_N, v)] corresponds to an existing entry in the State Storage.
* stem:[N] has more than one child.

Conversely, if stem:[(k, v)] is an entry in the State Trie then there is a node
stem:[N in cc N] such that stem:[k_N = k].
====

[#defn-trie-branch]
.<<defn-trie-branch, Branch>>
====
A *branch* node is a node which has one child or more. A branch node can have at
most 16 children. A *leaf* node is a childless node. Accordingly:

[stem]
++++
cc N_b := {N in cc N | N " is a branch node"}\
cc N_i := {N in cc N | N " is a leaf node"}
++++
====

For each node, part of stem:[k_N] is built while the trie is traversed from root
to stem:[N] part of stem:[k_N] is stored in stem:[N] (<<defn-node-key>>).

[#defn-node-key]
.<<defn-node-key, Aggregated Prefix Key>>
====
For any stem:[N in cc N], its key stem:[k_N] is divided into an *aggregated
prefix key, stem:["pk"_N^("Agr")]*, aggregated by the algorithm as defined in
<<algo-aggregate-key>> and a *partial key*, *stem:["pk"_N]* of length
stem:[0 <= l_("pk"_N) <= 65535] in nibbles such that:

[stem]
++++
"pk"_N := (k_("enc"_i),...,k_("enc"_(i+l_("pk"_N))))
++++

where stem:["pk"_N^("Agr")] is a suffix subsequence of stem:[k_N]; stem:[i] is the length
of stem:["pk"_N^("Agr")] in nibbles and so we have:

[stem]
++++
sf "KeyEncode"(k_N) = "pk"_N^("Agr") || "pk"_N = (k_("enc"_1), ..., k_("enc"_(i-1)),k_("enc"_i),k_("enc"_(i+l_("pk"_N))))
++++
====

Part of stem:["pk"_N^("Agr")] is explicitly stored in stem:[N]â€™s ancestors.
Additionally, for each ancestor, a single nibble is implicitly derived while
traversing from the ancestor to its child included in the traversal path using
the stem:["Index"_N] function (<<defn-index-function>>).

[#defn-index-function]
.<<defn-index-function, Index>>
====
For stem:[N in cc N_b] and stem:[N_c] child of stem:[N], we define
stem:[sf "Index"_N] function as:

[stem]
++++
sf "Index"_N: {N_C in cc N | N_c " is a child of " N} -> "Nibbles"_1^4\
N_c -> i
++++

such that

[stem]
++++
k_(N_c) = k_N || i || "pk"_(N_c)
++++
====

Assuming that stem:[P_N] is the path (<<defn-path-graph>>) from the Trie root to
node stem:[N], the algorithm defined in <<algo-aggregate-key>> rigorously
demonstrates how to build stem:["pk"_N^("Agr")] while traversing stem:[P_N].

[#algo-aggregate-key]
===== Aggregate Key
****
Algorithm: stem:[sf "Aggregate-Key"(P_N := ("TrieRoot" = N_1,...,N_j = N))]

. stem:["pk"_N^("Agr") larr phi]
. stem:[i larr 1]
. stem:["while" (N_i != N)]
. stem:["    " pk_N^(Agr) larr pk_N^(Agr)"||"pk_(N_i)]
. stem:["    " pk_N^(Agr) larr pk_N^(Agr)"||""Index"_(N_i)(N_(i+1))]
. stem:["    " i larr i + 1]
. stem:[pk_N^(Agr) larr pk_N^(Agr)"||"pk_(N_i)]
. stem:["return " pk_N^(Agr)]
****

[#defn-node-value]
.<<defn-node-value, Node Value>>
====
A node stem:[N in cc N] stores the *node value*, stem:[v_N], which consists of
the following concatenated data:

[stem]
++++
"Node Header"||"Partial Key"||"Node Subvalue"
++++

Formally noted as:

[stem]
++++
v_N := "Head"_N||"Enc"_("HE")(pk_N)||sv_N
++++

where stem:["Head"_N], stem:[pk_N], stem:["Enc"_("nibbles")] and stem:[sv_N] are
defined in <<defn-node-header>>, <<defn-node-key>>, <<defn-hex-encoding>> and
<<defn-node-subvalue>>, respectively.
====

[#defn-node-header]
.<<defn-node-header, Node Header>>
====
The *node header*, consisting of stem:[>= 1] bytes, stem:[N_1...N_n], specifies
the node variant and the size of the partial key in 4-bit nibbles. Both pieces
of information are represented in bits, where the amount of bits to be
interpreted varies for both indicators depend on the indicator of the variant.
The node header, stem:[h], is formally defined as:

[stem]
++++
h = N_1^(0..x)||N_1^((x+1)..7)||N_2^(0..7)||N_3^(0..7)||...
++++

where the first few bits indicate the node variant, defined as:

[stem]
++++
N_1^(0..x) = {
    (01,"Leaf"),
    (10,"Branch without value"),
    (11, "Branch with value"),
    (001,"Leaf containing hash"),
    (0001,"Branch containing hash"),
    (0000 0000,"Empty"),
    (0001 0000,"Reserved for compact encoding")
    :}
++++

For any non-empty, not-reserved variant, the remaining stem:[y] bits of
stem:[N_1] (stem:[y = 7-x+1]) are interpreted as the size, stem:[l], of the
partial key. If the remaining bits are equal to the maximum possible value the
stem:[y] bits can represent, respectively stem:[l = 2^y-1], the value of the
next 8 bits of stem:[N_2] are added to the length, which can equal zero. If the
value of those bits equals stem:[2^8-1], the value of the next 8 bits of
stem:[N_3] are added to the length stem:[l]. This process is repeated for every
sequence of 8 bits (stem:[N_n...N_(n+m)]) where its value equals stem:[2^8-1].
The first stem:[< 2^8-1] value implies that the remaining bytes are not to be
interpreted as a addition to the partial key length.

Formally, if stem:[v_(N_1)^(0..1) = 11], then the partial length is calculated
as:

[stem]
++++
l = N_1^(2..7) + N_2^(0..7) + N_3^(0..7) + ...
++++

as long as stem:[N_n^(a..b) < 2^(b+1)-1].
====

[#sect-merkl-proof]
==== Merkle Proof

To prove the consistency of the state storage across the network and its
modifications both efficiently and effectively, the Trie implements a
Merkle tree structure. The hash value corresponding to each node needs
to be computed rigorously to make the inter-implementation data
integrity possible.

The Merkle value of each node should depend on the Merkle value of all its
children as well as on its corresponding data in the state storage. This
recursive dependancy is encompassed into the subvalue part of the node value
which recursively depends on the Merkle value of its children. Additionally, as
<<sect-child-trie-structure>> clarifies, the Merkle proof of each *child trie*
must be updated first before the final Polkadot state root can be calculated.

We use the auxilary function introduced in <<defn-children-bitmap>> to encode
and decode information stored in a branch node.

[#defn-children-bitmap]
.<<defn-children-bitmap, Children Bitmap>>
====
Suppose stem:[N_b, N_c in cc N] and stem:[N_c] is a child of stem:[N_b]. We
define where bit stem:[b_i : = 1] if stem:[N] has a child with partial key
stem:[i], therefore we define *ChildrenBitmap* functions as follows:

[stem]
++++
"ChildrenBitmap:"\
cc N_b -> bbb B_2\
N -> (b_(15), ...,b_8,b_7,...,b_0)_2
++++

where

[stem]
++++
b_i := {(1, EE N_c in cc N: k_(N_c) = k_(N_b)||i||pk_(N_c)),(0, "otherwise"):}
++++
====

[#defn-node-subvalue]
.<<defn-node-subvalue, Subvalue>>
====
For a given node stem:[N], the *subvalue* of stem:[N], formally referred to as
stem:[sv_N], is determined as follows:

[stem]
++++
sv_N := {("StoredValue"_("SC")),("Enc"_("SC")("ChildrenBitmap"(N)||"StoredValue"_("SC")||"Enc"_("SC")(H(N_(C_1))),...,"Enc"_("SC")(H(N_(C_n))))):}
++++

where the first variant is a leaf node and the second variant is a branch node.

[stem]
++++
"StoredValue"_("SC") := {("Enc"_("SC")("StoredValue"(k_N)),"if StoredValue"(k_N) = v),(phi,"if StoredValue"(k_N) = phi):}
++++
====

stem:[N_(C_1) ... N_(C_n)] with stem:[n <= 16] are the children nodes of the
branch node stem:[N] and stem:["Enc"_("SC")], stem:["StoredValue"], stem:[H], and
stem:["ChildrenBitmap"(N)] are defined in <<sect-scale-codec>>,
<<defn-stored-value>>, <<defn-merkle-value>> and <<defn-children-bitmap>>
respectively.

The Trie deviates from a traditional Merkle tree where node value
(<<defn-node-value>>), stem:[v_N], is presented instead of its hash if it
occupies less space than its hash.

[#defn-merkle-value]
.<<defn-merkle-value, Merkle Value>>
====
For a given node stem:[N], the *Merkle value* of stem:[N], denoted by
stem:[H(N)] is defined as follows:

[stem]
++++
H: bbb B -> U_(i -> 0)^(32) bbb B_32\
H(N): {(v_N,||v_N|| < 32 " and " N != R),("Blake2b"(v_n),||v_N|| >= 32 " or " N + R):}
++++

Where stem:[v_N] is the node value of stem:[N] (<<defn-node-value>>) and
stem:[R] is the root of the Trie. The *Merkle hash* of the Trie is defined to be
latexmath:[H(R)].
====
