[#sect-defn-conv]
=== Definitions and Conventions

[#defn-state-machine]
==== Discrete State Machine (DSM)
****
A *Discrete State Machine(DSM)* is a state transition system whose set of states
and set of transitions are countable and admits a starting state. Formally, it
is a tuple of

[stem]
++++
(\Sigma, S, s_0, \delta)
++++
where

* stem:[\Sigma] is the countable set of all possible transitions.
* stem:[S] is a countable set of all possible states.
* stem:[s_0 in S] is the initial state.
* stem:[\delta] is the state-transition function, known as *Runtime* in the
Polkadot vocabulary, such that

[stem]
++++
\delta : S \times \Sigma \rightarrow S
++++
****

[#defn-path-graph]
==== Path Graph
****
A *path graph* or a *path* of stem:[n] nodes formally referred to as *stem:[P_n]*,
is a tree with two nodes of vertex degree 1 and the other n-2 nodes of vertex
degree 2. Therefore, stem:[P_n] can be represented by sequences of stem:[(v_1,
\ldots, v_n)] where stem:[e_i = (v_i, v_{i + 1})] for stem:[1 <= i <= n - 1] is
the edge which connect stem:[v_i] and stem:[v_{i + 1}].
****

[#defn-radix-tree]
==== Radix-r Tree
****
A *Radix-r tree* is a variant of  a trie in which:

* Every node has at most stem:[r] children where stem:[r = 2^x] for some
stem:[x];
* Each node that is the only child of a parent, which does not
represent a valid key is merged with its parent.

As a result, in a radix tree, any path whose interior vertices all have only one
child and does not represent a valid key in the data set, is compressed into a
single edge. This improves space efficiency when the key space is sparse.
****

==== Sequence of Bytes
****
By a *sequences of bytes* or a *byte array*, stem:[b], of length
stem:[n], we refer to

[stem]
++++
b := (b_0, b_1, ..., b_{n - 1}) " such that " 0 <= b_i <= 255
++++

We define stem:[bbb "B"_n] to be the
*set of all byte arrays of length stem:[n]*. Furthermore, we
define:

[stem]
++++
bbb "B" := uuu_(i=0)^infty bbb "B"_i
++++

We represent the concatenation of byte arrays
stem:[a :=(a_0, ..., a_n)] and
stem:[b :=(b_0, ..., b_m)] by:

[stem]
++++
a |\| b :=(a_0, ..., a_n, b_0, ..., b_m)
++++
****

[#defn-bit-rep]
==== Bitwise Representation
****
For a given byte stem:[b] the *bitwise representation* of stem:[b] is defined as

[stem]
++++
b :=b^7 ... b^0
++++

where

[stem]
++++
b = 2^0 b^0 + 2^1 b^1 + ... + 2^7 b^7
++++
****

[#defn-little-endian]
==== Little Endian
****
By the *little-endian* representation of a non-negative integer, stem:[I],
represented as

[stem]
++++
I = (B_n ... B_0)_256
++++

in base 256, we refer to a byte array
stem:[B = (b_0, b_1, ..., b_n)] such that

[stem]
++++
b_i :=B_i
++++

Accordingly, we define the function stem:[sf "Enc"_(sf "LE")]:

[stem]
++++
sf "Enc"_(sf "LE"):{(bbb "Z"^+ -> bbb "B"),((B_n ... B_0)_256 -> (B_{0,} B_1, ... , B_n)):}
++++
****

==== UINT32
****
By *UINT32* we refer to a non-negative integer stored in a byte array of
length stem:[4] using little-endian encoding format.
****

==== Blockchain 

****
A *blockchain* stem:[C] is a directed path graph. Each node of the graph is
called *Block* and indicated by *stem:[B]*. The unique sink of stem:[C] is
called *Genesis Block*, and the source is called the stem:[sf "Head"] of stem:[C]. For any
vertex stem:[(B_1, B_2)] where stem:[B_1 -> B_2] we say stem:[B_2] is the
*parent* of stem:[B_1] and we indicate it by

[stem]
++++
B_2 := P(B_1)
++++
****

[#defn-unix-time]
==== Unix Time
****
By *Unix time*, we refer to the unsigned, little-endian encoded 64-bit integer
which stores the number of *milliseconds* that have elapsed since the Unix
epoch, that is the time 00:00:00 UTC on 1 January 1970, minus leap seconds. Leap
seconds are ignored, and every day is treated as if it contained exactly 86’400
seconds.
****

[#defn-block-tree]
==== Block 
****
In the course of formation of a (distributed) blockchain, it is possible
that the chain forks into multiple subchains in various block positions.
We refer to this structure as a _block tree_.

The *block tree* of a blockchain, denoted by stem:[BT] is the union of all
different versions of the blockchain observed by the Polkadot Host such that
every block is a node in the graph and stem:[B_1] is connected to stem:[B_2] if
stem:[B_1] is a parent of stem:[B_2].

When a block in the block tree gets finalized, there is an opportunity
to prune the block tree to free up resources into branches of blocks
that do not contain all of the finalized blocks or those that can never
be finalized in the blockchain. For a definition of finality, see
Section link:#sect-finality[6.3].
****

[#defn-pruned-tree]
==== Pruned Block Tree
****
By Pruned Block Tree*, denoted by stem:[PBT], we refer to a subtree of the block
tree obtained by eliminating all branches which do not contain the most recent
finalized blocks, as defined in Definition
link:#defn-finalized-block[[defn-finalized-block]]. By *pruning*, we refer to
the procedure of stem:[BT larr PBT]. When there is no risk of ambiguity and is
safe to prune BT, we use stem:[BT] to refer to stem:[PBT].

Definition link:#defn-chain-subchain[[defn-chain-subchain]] gives the
means to highlight various branches of the block tree.
****

[#defn-chain-subchain]
==== Subchain
****
Let stem:[G] be the root of the block tree and stem:[B] be one of its nodes. By
stem:[Chain(B)], we refer to the path graph from stem:[G] to stem:[B] in
stem:[P(BT)]. Conversely, for a chain stem:[C = sf "Chain"(b)], we define *the
head of stem:[C]* to be stem:[B], formally noted as stem:[B := sf "Head"(C)]. We
define stem:[|C|], the length of stem:[C] as a path graph. If stem:[B'] is
another node on stem:[sf "Chain"(B)], then by stem:[sf "SubChain"(B', B)] we
refer to the subgraph of stem:[sf "Chain"(B)] path graph which contains both
stem:[B] and stem:[B'] and by stem:[sf "SubChain"(B', B)] we refer to its
length. Accordingly, stem:[bbb "C"_(B')((P)BT)] is the set of all subchains of
stem:[(P)BT] rooted at stem:[B']. The set of all chains of stem:[(P)BT],
stem:[bbb "C"_G((P)BT})] is denoted by stem:[bbb "C"((P)BT)] or simply
stem:[bbb "C"], for the sake of brevity.
****

[#defn-longest-chain]
==== Longest Chain
****
We define the following complete order over stem:[bbb "C"] such that for
stem:[C_1, C_2 in bbb "C"] if stem:[|C_1| != |C_2|] we say stem:[C_1 > C_2] if
and only if stem:[|C_1| > |C_2|].

If stem:[|C_1| =| C_2|] we say stem:[C_1 > C_2] if and only if the block arrival
time of stem:[sf "Head"(C_1)] is less than the block arrival time of stem:[sf
"Head"(C_2)] as defined in Definition link:#defn-block-time[[defn-block-time]].
We define the stem:[sf "Longest-Chain(BT)] too be the maximum chain given by
this order.
****

[#defn-longest-path]
==== Longest Path
****
stem:[sf "Longest-Path"(BT)] returns the path graph of stem:[(P)BT] which is the
longest among all paths in stem:[(P)BT] and has the earliest block arrival time
as defined in Definition link:#defn-block-time[[defn-block-time]]. stem:[sf
"Deepest-Leaf"(BT)] returns the head of stem:[sf "Longest-Path"(BT)] chain.

Because every block in the blockchain contains a reference to its parent, it is
easy to see that the block tree is de facto a tree. A block tree naturally
imposes partial order relationships on the blocks as follows:
****

==== Descendant
****
We say *B is descendant of stem:[B']*, formally noted as stem:[B > B'] if
stem:[B] is a descendant of stem:[B'] in the block tree.
****