[#sect-network-messages]
=== Network Messages

The Polkadot Host must actively communicate with the network in order to
participate in the validation process or act as a full node.

NOTE: The Polkadot network originally only used SCALE encoding for all message
formats. Meanwhile, Protobuf has been adopted for certain messages. The encoding
of each message is explicitly mentioned in their corresponding definition.
Encoding and message formats are subject to change.

[#sect-msg-block-announce]
==== Announcing blocks

When the node creates or receives a new block, it must be announced to the
network. Other nodes within the network will track this announcement and can
request information about this block. The mechanism for tracking announcements
and requesting the required data is implementation-specific.

Block announcements, requests and responses are sent over the substream as
defined in Definition
link:#defn-block-announce-handshake[[defn-block-announce-handshake]].

[#defn-block-announce-handshake]
===== Definition: Block Announce Handshake
****
The `BlockAnnounceHandshake` initializes a substream to a remote peer. Once
established, all `BlockAnounce` messages, as defined in Definition
link:#defn-block-announce[[defn-block-announce]], and created by the node are
sent to the `/dot/block-announces/1` substream.

The `BlockAnnounceHandshake` is a SCALE-encoded structure of the following
format:

[stem]
++++
BA_h = "Enc"_(SC)(R,N_B,h_B,h_G)
++++

where:

[stem]
++++
R = {(1,"The node is a full node"),(2,"The node is a light client"),(4,"The node is a validator"):}\
N_B = "Best block number according to the node"\
h_B = "Best block hash according to the node"\
h_G = "Genesis block hash according to the node"
++++
****

[#defn-block-announce]
===== Definition: Block Announce
****
The `BlockAnnounce` message is sent to the specified substream and indicates to
remote peers that the node has either created or received a new block.

The message is a SCALE-encoded structure of the following format:

[stem]
++++
BA = "Enc"_(SC)("Head"(B),b)
++++

where:

[stem]
++++
"Head"(B) = "Header of the announced block"\
b = {(0,"Is not part of the best chain"),(1,"Is the best block according to the node"):}
++++
****

[#sect-msg-block-request]
==== Requesting Blocks
Block requests can be used to retrieve a range of blocks from peers. Those
messages are sent over the `/dot/sync/2` substream.

[#defn-msg-block-request]
===== Definition: Block Request
****
The `BlockRequest` message is a Protobuf serialized structure of the following format:

[cols="2,1,4,1"]
|===
|Type |Id |Description |Value

|`uint32`
|1
|Bits of block data to request
|stem:[B_f]

|`oneof`
|
|Start from this block
|stem:[B_S]

|`bytes``
|4
|End at this block (_optional_)
|stem:[B_e]

|_Direction_
|5
|Sequence direction
|

|`uint32`
|6
|Maximum amount (_optional_)
|stem:[B_m]
|===

where:

* stem:[B_f] indicates all the fields that should be included in the request.
its *big-endian* encoded bitmask that applies to all desired fields with bitwise
OR operations. For example, the stem:[B_f] value to request _Header_ and
_Justification_ is _0001 0001_ (17).
+
|===
|Field |Value

|Header
|0000 0001

|Body
|0000 0010

|Justification
|0001 0000
|===
* stem:[B_s] is a Protobuf structure indicating a varying data
type of the following values:
+
[cols="2,2,4"]
|===
|Type |Id |Description

|`bytes`
|2
|The block hash

|`bytes`
|3
|The block number
|===
* stem:[B_e] is either the block hash or block number depending
on the value of stem:[B_s]. an implementation-defined maximum is
used when unspecified.
* _Direction_ is a Protobuf structure indicating the sequence direction of the
requested blocks. the structure is a varying data type, as defined in
definition link:#defn-varrying-data-type[[defn-varrying-data-type]], of
the following format:
+
[cols="1,4"]
|===
|Id |Description

|0
|Enumerate in ascending order (from child to parent)

|1
|Enumerate in descending order (from parent to canonical child)
|===
* stem:[B_m] is the number of blocks to be returned. An implementation defined
maximum is used when unspecified.
****

[#defn-msg-block-response]
===== Definition: Block Response
****
The `BlockResponse` message is received after sending a `BlockRequest` message
to a peer. The message is a Protobuf serialized structure of the following
format:

[cols="3,1,5"]
|===
|Type |Id |Description

|Repeated _BlockData_
|1
|Block data for the requested sequence
|===

where _BlockData_ is a Protobuf structure containing the requested blocks. Do
note that the optional values are either present or absent depending on the
requested fields (bitmask value). The structure has the following format:

[cols="2,1,5,3"]
|===
|Type |Id |Description |Value

|`bytes`
|1
|Block header hash
|Def. link:#defn-block-header-hash[[defn-block-header-hash]]

|`bytes`
|2
|Block header (optional)
|Def. link:#defn-block-header[[defn-block-header]]

|repeated `bytes`
|3
|Block body (optional)
|Def. link:#defn-block-body[[defn-block-body]]

|`bytes`
|4
|Block receipt (optional)
|

|`bytes`
|5
|Block message queue (optional)
|

|`bytes`
|6
|Justification (optional)
|Def. link:#defn-grandpa-justification[[defn-grandpa-justification]]

|`bool`
|7
|Indicates whether the justification is empty (i.e. should be ignored)
|
|===
****

[#sect-msg-transactions]
==== Transactions

Transactions, as defined and described in Section link:#sect-extrinsics[3.2],
are sent directly to peers with which the Polkadot Host has an open transaction
substream, as defined in Definition
link:#defn-transactions-message[[defn-transactions-message]]. Polkadot Host
implementers should implement a mechanism that only sends a transaction once to
each peer and avoids sending duplicates. Sending duplicate transactions might
result in undefined consequences such as being blocked for bad behaviour by
peers.

The mechanism for managing transactions is further described in Section
link:#sect-extrinsics[3.2].

[#defn-transactions-message]
===== Definition: Transaction Message
****
The *transactions message* is the structure of how the transactions are sent
over the network. It is represented by stem:[M_T] and is defined as follows:

[stem]
++++
M_T := "Enc"_(SC)(C_1,...,C_n)
++++

in which:

[stem]
++++
C_i := "Enc"_(SC)(E_i)
++++

Where each stem:[E_i] is a byte array and represents a separate
extrinsic. The Polkadot Host is agnostic about the content of an
extrinsic and treats it as a blob of data.

Transactions are sent over the `/dot/transactions/1` substream.
****

[#sect-msg-grandpa]
==== GRANDPA Messages

The exchange of GRANDPA messages is conducted on the substream. The process for
the creation and distributing these messages is described in Section
link:#sect-finality[6.3]. The underlying messages are specified in this section.

[#defn-gossip-message]
===== Definition: Grandpa Gossip Message
****
A *GRANDPA gossip message*, stem:[M], is a varying datatype as defined in
Definition link:#defn-varrying-data-type[[defn-varrying-data-type]], which
identifies the message type that is cast by a voter followed by the message itself.

TODO: Clarify propagation.
TODO: Reference additional message.

[stem]
++++
M = {(0,"Vote message", V_m),(1,"Commit message", C_m),(2,"Neighbor message", N_m),(3,"Catch-up request message",R_m),(4,"Catch-up message",U_m):}
++++
****

[#defn-grandpa-vote-msg]
===== Definition: GRANDPA Vote Messages
****
A *GRANDPA vote message* by voter stem:[v], stem:[M_v^(r,"stage")], is gossip to
the network by voter stem:[v] with the following structure:

[stem]
++++
M_v^(r,"stage")(B) := "Enc"_(SC)(r,"id"_(bbb "V"),"SigMsg")\
"SigMsg" := ("msg","Sig"_(v_i)^(r,"stage"),v_("id"))\
"msg" := "Enc"_(SC)("stage",V_v^(r,"stage")(B))
++++

where:

TODO: References.

* stem:[r] is an unsigned 64-bit integer indicating the Grandpa round number.
* stem:["id"_(bbb "V")] is an unsigned 64-bit integer indicating the authority Set Id.
* stem:["Sig"_(v_i)^(r,"stage")] is a 512-bit byte array containing the signature of the authority.
* stem:[v_(id)] is a 256-bit byte array containing the _ed25519_ public key of the authority.
* stem:["stage"] is a 8-bit integer of value _0_ if it's a pre-vote sub-round, _1_ if it's a pre-commit sub-round or _2_ if it's a primary proposal message.
* stem:[V_v^(r,"stage")(B)] is the GRANDPA vote for block stem:[B].

This message is the sub-component of the GRANDPA gossip message as defined in
Definition link:#defn-gossip-message[[defn-gossip-message]] of type Id 0.
****

[#defn-grandpa-justifications-compact]
===== Definition: GRANDPA Compact Justification Format
****
The *GRANDPA compact justification format* is an optimized data structure to
store a collection of pre-commits and their signatures to be submitted as part
of a commit message. Instead of storing an array of justifications, it uses the
following format:

TODO: Reference
TODO: Double check format.

[stem]
++++
J_(v_(0,...n))^(r,"comp") := ({V_(v_0)^(r,pc),... V_(v_n)^(r,pc)},{("Sig"_(v_0)^(r,pc),v_("id"_0)), ... ("Sig"_(v_n)^(r,pc),v_("id"_n))})
++++

where:

* stem:[V_(v_i)^(r,pc)] is a 256-bit byte array (TODO: and 32-bit integer) containing the pre-commit vote of authority stem:[v_i].
* stem:["Sig"_(v_i)^(r,pc)] is a 512-bit byte array containing the pre-commit signature of authority stem:[v_i].
* stem:[v_("id"_n)] is a 256-bit byte array containing the public key of authority stem:[v_i].
****

[#defn-grandpa-commit-msg]
===== Definition: GRANDPA Commit Message
****
A *GRANDPA commit message* for block stem:[B] in round stem:[r],
stem:[M_v^(r,"Fin")(B)], is a message broadcasted by voter stem:[v] to the
network indicating that voter stem:[v] has finalized block stem:[B] in round
stem:[r]. It has the following structure:

[stem]
++++
M_v^(r,"Fin")(B) := "Enc"_(SC)(r,"id"_(bbb "V"),V_v^r(B),J_(v_(0,...n))^(r,"comp"))
++++

where:

TODO: References
TODO: Check if the GRANDPA vote is correct.

* stem:[r] is an unsigned 64-bit integer indicating the round number.
* stem:[id_(bbb "V")] is the authority set Id.
* stem:[V_v^r(B)] is a 256-bit array (TODO: and 32-bit integer?) containing the GRANDPA vote for block stem:[B].
* stem:[J_(v_(0,...n))^(r,"comp")] (TODO: type?) is the compacted GRANDPA justification containing observed pre-commit of authorities stem:[v_0] to stem:[v_n].

This message is the sub-component of the GRANDPA gossip message as defined in
Definition link:#defn-gossip-message[[defn-gossip-message]] of type Id 1.
****

[#sect-grandpa-neighbor-msg]
===== GRANDPA Neighbor Messages

Neighbor messages are sent to all connected peers but they are not
repropagated on reception. A message should be send whenever the
messages values change and at least every 5 minutes. The sender should
take the recipients state into account and avoid sending messages to
peers that are using a different voter sets or are in a different round.
Messages received from a future voter set or round can be dropped and
ignored.

====== GRANDPA Neighbor Message
****
A *GRANDPA Neighbor Message* is defined as:

TODO: Consider renaming variables.
TODO: References.

[stem]
++++
M^("neigh") := "Enc"_(SC)("version",r,"id"_(bbb "V"),H_h(B_("last")))
++++

where:

* stem:["version"] is an unsigned 8-bit integer indicating the version of the neighbor message, currently _1_.
* stem:[r] is an unsigned 64-bit integer indicating the round number.
* stem:["id"_(bbb "V")] is an unsigned 64-bit integer indicating the authority Id.
* stem:[H_i(B_("last"))] is an unsigned 32-bit integer indicating the block number of the last finalized block stem:[B_("last")].

This message is the sub-component of the GRANDPA gossip message as defined in
Definition link:#defn-gossip-message[[defn-gossip-message]] of type Id _2_.
****

[#sect-grandpa-catchup-messages]
===== GRANDPA Catch-up Messages

Whenever a Polkadot node detects that it is lagging behind the finality
procedure, it needs to initiate a _catch-up_ procedure. GRANDPA Neighbor
messages (see Section
link:#defn-grandpa-neighbor-msg[[defn-grandpa-neighbor-msg]]) reveal the round
number for the last finalized GRANDPA round which the nodeâ€™s peers have
observed. This provides the means to identify a discrepancy in the latest
finalized round number observed among the peers. If such a discrepancy is
observed, the node needs to initiate the catch-up procedure explained in Section
link:#sect-grandpa-catchup[6.4.1].

In particular, this procedure involves sending a _catch-up request_ and
processing _catch-up response_ messages.

====== Catch-Up Request Message
****
A *GRANDPA catch-up request message* for round stem:[r],
stem:[M_(i,v)^("Cat"-q)("id"_(bbb "V"),r)], is a message sent from node stem:[i]
to its voting peer node stem:[v] requesting the latest status of a GRANDPA round
stem:[r' >r] of the authority set stem:[bbb "V"_("id")] along with the
justification of the status and has the following structure:

[stem]
++++
M_(i,v)^(r,"Cat"-q) := "Enc"_(SC)(r,"id"_(bbb "V"))
++++

This message is the sub-component of the GRANDPA Gossip message as defined in
Definition link:#defn-gossip-message[[defn-gossip-message]] of type Id _3_.
****

====== Catch-Up Response Message
****
A *GRANDPA catch-up response message* for round stem:[r],
stem:[M_(v,i)^("Cat"-s)("id"_(bbb "V"),r)], is a message sent by a node stem:[v]
to node stem:[i] in response of a catch-up request
stem:[M_(v,i)^("Cat"-q)("id"_(bbb "V"),r')] in which stem:[r >= r'] is the
latest GRANDPA round which v has prove of its finalization and has the following
structure:

TODO: Reference

[stem]
++++
M_(v,i)^("Cat"-s) := "Enc"_(SC)("id"_(bbb "V"), r, J_(0,...n)^(r,pv)(B), J_(0,...m)^(r,pc)(B),H_h(B'),H_i(B'))
++++

Where stem:[B] is the highest block which stem:[v] believes to be finalized in
round stem:[r]. stem:[B'] is the highest ancestor of all blocks voted on in the
arrays of justifications stem:[J_(0,...n)^(r,pv)(B)] and
stem:[J_(0,...m)^(r,pc)(B)] with the exception of the equivocationary votes.

This message is the sub-component of the GRANDPA Gossip message as defined in
Definition link:#defn-gossip-message[[defn-gossip-message]] of type Id _4_.
****
