[#sect-network-messages]
=== Network Messages

The Polkadot Host must actively communicate with the network in order to
participate in the validation process or act as a full node.

NOTE: The Polkadot network originally only used SCALE encoding for all message
formats. Meanwhile, Protobuf has been adopted for certain messages. The encoding
of each message is explicitly mentioned in their corresponding definition.
Encoding and message formats are subject to change.

[#sect-msg-block-announce]
==== Announcing blocks

When the node creates or receives a new block, it must be announced to the
network. Other nodes within the network will track this announcement and can
request information about this block. The mechanism for tracking announcements
and requesting the required data is implementation-specific.

Block announcements, requests and responses are sent over the substream as
defined in Definition
link:#defn-block-announce-handshake[[defn-block-announce-handshake]].

[#defn-block-announce-handshake]
===== Definition: Block Announce Handshake
****
The `BlockAnnounceHandshake` initializes a substream to a remote peer. Once
established, all `BlockAnounce` messages, as defined in Definition
link:#defn-block-announce[[defn-block-announce]], and created by the node are
sent to the `/dot/block-announces/1` substream.

The `BlockAnnounceHandshake` is a SCALE-encoded structure of the following
format:

[stem]
++++
BA_h = "Enc"_(SC)(R,N_B,h_B,h_G)
++++

where:

[stem]
++++
R = {(1,"The node is a full node"),(2,"The node is a light client"),(4,"The node is a validator"):}\
N_B = "Best block number according to the node"\
h_B = "Best block hash according to the node"\
h_G = "Genesis block hash according to the node"
++++
****

[#defn-block-announce]
===== Definition: Block Announce
****
The `BlockAnnounce` message is sent to the specified substream and indicates to
remote peers that the node has either created or received a new block.

The message is a SCALE-encoded structure of the following format:

[stem]
++++
BA = "Enc"_(SC)("Head"(B),b)
++++

where:

[stem]
++++
"Head"(B) = "Header of the announced block"\
b = {(0,"Is not part of the best chain"),(1,"Is the best block according to the node"):}
++++
****

[#sect-msg-block-request]
==== Requesting Blocks
Block requests can be used to retrieve a range of blocks from peers. Those
messages are sent over the `/dot/sync/2` substream.

[defn-msg-block-request]
===== Definition: Block Request
****
The `BlockRequest` message is a Protobuf serialized structure of the following format:

[cols="2,1,4,1"]
|===
|Type |Id |Description |Value

|`uint32`
|1
|Bits of block data to request
|stem:[B_f]

|`oneof`
|
|Start from this block
|stem:[B_S]

|`bytes``
|4
|End at this block (_optional_)
|stem:[B_e]

|_Direction_
|5
|Sequence direction
|

|`uint32`
|6
|Maximum amount (_optional_)
|stem:[B_m]
|===

where:

* stem:[B_f] indicates all the fields that should be included in the request.
its *big-endian* encoded bitmask that applies to all desired fields with bitwise
OR operations. For example, the stem:[B_f] value to request _Header_ and
_Justification_ is _0001 0001_ (17).
+
|===
|Field |Value

|Header
|0000 0001

|Body
|0000 0010

|Justification
|0001 0000
|===
* stem:[B_s] is a Protobuf structure indicating a varying data
type of the following values:
+
[cols="2,2,4"]
|===
|Type |Id |Description

|`bytes`
|2
|The block hash

|`bytes`
|3
|The block number
|===
* stem:[B_e] is either the block hash or block number depending
on the value of stem:[B_s]. an implementation-defined maximum is
used when unspecified.
* _Direction_ is a Protobuf structure indicating the sequence direction of the
requested blocks. the structure is a varying data type, as defined in
definition link:#defn-varrying-data-type[[defn-varrying-data-type]], of
the following format:
+
[cols="1,4"]
|===
|Id |Description

|0
|Enumerate in ascending order (from child to parent)

|1
|Enumerate in descending order (from parent to canonical child)
|===
* stem:[B_m] is the number of blocks to be returned. An implementation defined
maximum is used when unspecified.
****

[defn-msg-block-response]
===== Definition: Block Response
The `BlockResponse` message is received after sending a `BlockRequest` message
to a peer. The message is a Protobuf serialized structure of the following
format:

[cols="3,1,5"]
|===
|Type |Id |Description

|Repeated _BlockData_
|1
|Block data for the requested sequence
|===

where _BlockData_ is a Protobuf structure containing the requested blocks. Do
note that the optional values are either present or absent depending on the
requested fields (bitmask value). The structure has the following format:

[cols="2,1,5,3"]
|===
|Type |Id |Description |Value

|`bytes`
|1
|Block header hash
|Def. link:#defn-block-header-hash[[defn-block-header-hash]]

|`bytes`
|2
|Block header (optional)
|Def. link:#defn-block-header[[defn-block-header]]

|repeated `bytes`
|3
|Block body (optional)
|Def. link:#defn-block-body[[defn-block-body]]

|`bytes`
|4
|Block receipt (optional)
|

|`bytes`
|5
|Block message queue (optional)
|

|`bytes`
|6
|Justification (optional)
|Def. link:#defn-grandpa-justification[[defn-grandpa-justification]]

|`bool`
|7
|Indicates whether the justification is empty (i.e. should be ignored)
|
|===
