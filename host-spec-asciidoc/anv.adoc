= Availability & Validity
:description: Availability & Validity
:doctype: book
:toc:
:stem:
:sectnums: all

[preface]
== Introduction

As clarified in Chapter 1, Polkadot serves as a replicated shared-state machine designed to resolve scalability issues and interoperability among blockchains. The validators of Polkadot execute transactions and participate in the consensus of Polkadots primary chain, the so called relay chain. Parachains are independent networks that maintain their own state and are connected to the relay chain. Those parachains can take advantage of the relay chain consensus mechanism, including sending and receiving messages to and from other parachains. Parachain nodes that send parachain blocks, known as candidates, to the validators in order to be inlcuded in relay chain are referred to as collators.

The Polkadot relay chain validators are responsible for guaranteeing the validity of both relay chain and parachain blocks. Additionally, the validators are required to keep enough parachain blocks that should be included in the relay chain available in their local storage in order to make those retrievable by peers, who lack the information, to reliably confirm the issued validity statements about parachain blocks. The Availability & Validity (AnV) protocol consists of multiple steps for successfully upholding those responsibilities.

Parachain blocks themselves are produced by collators as described in Section 7.3, whereas the relay chain validators only verify their validity (and later, their availability). It is possible that the collators of a parachain  produces multiple parachain block candidates for a child of a specific block. Subsequently, they send the block candadiates to the the relay chain validators who are assigned to the specific parachain. The assignment is determined by the Runtime as described in Section 7.4. Those validators are then required to check the validity of submitted candidates as described in Section 7.5, then issue and collect statements about the validity of candidates to other validators as described in Section 7.4.1. This process is known as candidate backing. Once a candidate meets a specified criteria for inclusion, the selected relay chain block author then choses any of the backed candidate for each parachain and includes those into the relay chain block as described in Section 7.4.2.

Every relay chain validator must fetch the proposed candidates and issue votes on whether they have the candidate saved in their local storage, so called availability votes as described in Section 7.6.1, then also collect the votes sent by other validators and include them in the relay chain state, as described in Section 7.4.2. This process ensures that only relay chain blocks get finalized where each candidate is available on enough nodes of validators.

Parachain candidates contained in non-finalized (Section ?) relay chain blocks must then be retrieved by a secondary set of relay chain validators, unrelated from the candidate backing process, who are randomly assigned to determine the validity of specific parachains based on a VRF lottery and are then required to vote on the validity of those candidates as described in Section 7.7. This process is known as approval voting. If a validator does not have the candidate data, it must recover the candidate data as described in Section 7.6.2.

== Preliminaries

[#defn-collator]
.Collator
****
A collator is a parachain node that sends parachain blocks, known as candidates as defined in Definition 7.2, to the relay chain validators. The relay chain validators are not concerned how the collator works or how it creates candidates.
****

[#defn-candidate]
.Candidate
****
A candidate is a submitted parachain block as defined in Definition 7.3 to the relay chain validators. A parachain block stops being referred to as a candidate as soon it has been finalized.
****

[#defn-para-block]
.Parachain Block
****
A parachain block or a Proof-of-Validity block (PoV block) contains the necessary data to for parachain specific state transition logic. Relay chain validators are not concerned with the inner structure of the block and treat it as a byte array.
****

[#defn-head-data]
.Head Data
****
The head data is contains information about a parachain block as defined in Definition 7.3. The head data is returned by executing the parachain Runtime and relay chain validators are not concerned with its inner structure and treat it as a byte arrays.
****

[#defn-para-id]
.Parachain Id
****
The Parachain Id is a unique, unsigned 32-bit integer which serves as an identifier of a parachain, assigned by the Runtime.
****

[#defn-availability-core]
.Availability Core
****
Availability cores are slots used to process parachains. The Runtime assigns each parachain to a availability core and validators can fetch information about the cores, such as parachain block candidates, by calling the appropriate Runtime API as described in Section 7.8.3. Validators are not concerned with the internal workings from the Runtimes perspective.
****

[#defn-validator-groups]
.Validator Groups
****
Validator groups indicate which validators are responsible for creating backable candidates for certain parachains, as described in Section 7.4, and are assigned by the Runtime. Validators are not concerned with the internal workings from the Runtimes perspective. Collators can use this information for submitting blocks.
****

[#defn-upward-message]
.Upward Message
****
An upward message is an opaque byte array sent from a parachain to a relay chain.
****

[#defn-downward-message]
.Downward Message
****
Definition 2. A downward message is an opaque byte array received by the parachain from the relay chain.
****

[#defn-outbound-hrmp-message]
.Outbound HRMP message
****
Definition 3. An outbound HRMP message (Horizontal Relay-routed Message Passing) is sent from the perspective of a sender of a parachain to an other parachain by passing it through the relay chain. It's a datastructure of the following format:

[stem]
++++
(I,M)
++++

where I is the recipient Id as defined in Definition 7.5 and M is an upward message as defined in Definition 7.8. 
****

[#defn-inbound-hrmp-message]
.Inbound HRMP message
****
An inbound HRMP message (Horizontal Relay-routed Message Passing) is seen from the perspective of a recipient parachain sent from an other parachain by passing it through the relay chain. It's a datastructure of the following format:

[stem]
++++
(N,M)
++++

where N is the relay chain block number at which the message was passed down to the recipient parachain and M is a downward message as defined in Definition 7.9.
****
