= Availability & Validity
:description: Availability & Validity
:doctype: book
:toc:
:stem:
:sectnums: all

[preface]
== Introduction

As clarified in Chapter 1, Polkadot serves as a replicated shared-state machine designed to resolve scalability issues and interoperability among blockchains. The validators of Polkadot execute transactions and participate in the consensus of Polkadots primary chain, the so called relay chain. Parachains are independent networks that maintain their own state and are connected to the relay chain. Those parachains can take advantage of the relay chain consensus mechanism, including sending and receiving messages to and from other parachains. Parachain nodes that send parachain blocks, known as candidates, to the validators in order to be inlcuded in relay chain are referred to as collators.

The Polkadot relay chain validators are responsible for guaranteeing the validity of both relay chain and parachain blocks. Additionally, the validators are required to keep enough parachain blocks that should be included in the relay chain available in their local storage in order to make those retrievable by peers, who lack the information, to reliably confirm the issued validity statements about parachain blocks. The Availability & Validity (AnV) protocol consists of multiple steps for successfully upholding those responsibilities.

Parachain blocks themselves are produced by collators as described in Section 7.3, whereas the relay chain validators only verify their validity (and later, their availability). It is possible that the collators of a parachain  produces multiple parachain block candidates for a child of a specific block. Subsequently, they send the block candadiates to the the relay chain validators who are assigned to the specific parachain. The assignment is determined by the Runtime as described in Section 7.4. Those validators are then required to check the validity of submitted candidates as described in Section 7.5, then issue and collect statements about the validity of candidates to other validators as described in Section 7.4.1. This process is known as candidate backing. Once a candidate meets a specified criteria for inclusion, the selected relay chain block author then choses any of the backed candidate for each parachain and includes those into the relay chain block as described in Section 7.4.2.

Every relay chain validator must fetch the proposed candidates and issue votes on whether they have the candidate saved in their local storage, so called availability votes as described in Section 7.6.1, then also collect the votes sent by other validators and include them in the relay chain state, as described in Section 7.4.2. This process ensures that only relay chain blocks get finalized where each candidate is available on enough nodes of validators.

Parachain candidates contained in non-finalized (Section ?) relay chain blocks must then be retrieved by a secondary set of relay chain validators, unrelated from the candidate backing process, who are randomly assigned to determine the validity of specific parachains based on a VRF lottery and are then required to vote on the validity of those candidates as described in Section 7.7. This process is known as approval voting. If a validator does not have the candidate data, it must recover the candidate data as described in Section 7.6.2.

== Preliminaries

[#defn-collator]
.Collator
****
A collator is a parachain node that sends parachain blocks, known as candidates as defined in Definition 7.2, to the relay chain validators. The relay chain validators are not concerned how the collator works or how it creates candidates.
****

[#defn-candidate]
.Candidate
****
A candidate is a submitted parachain block as defined in Definition 7.3 to the relay chain validators. A parachain block stops being referred to as a candidate as soon it has been finalized.
****

[#defn-para-block]
.Parachain Block
****
A parachain block or a Proof-of-Validity block (PoV block) contains the necessary data to for parachain specific state transition logic. Relay chain validators are not concerned with the inner structure of the block and treat it as a byte array.
****

[#defn-head-data]
.Head Data
****
The head data is contains information about a parachain block as defined in Definition 7.3. The head data is returned by executing the parachain Runtime and relay chain validators are not concerned with its inner structure and treat it as a byte arrays.
****

[#defn-para-id]
.Parachain Id
****
The Parachain Id is a unique, unsigned 32-bit integer which serves as an identifier of a parachain, assigned by the Runtime.
****

[#defn-availability-core]
.Availability Core
****
Availability cores are slots used to process parachains. The Runtime assigns each parachain to a availability core and validators can fetch information about the cores, such as parachain block candidates, by calling the appropriate Runtime API as described in Section 7.8.3. Validators are not concerned with the internal workings from the Runtimes perspective.
****

[#defn-validator-groups]
.Validator Groups
****
Validator groups indicate which validators are responsible for creating backable candidates for certain parachains, as described in Section 7.4, and are assigned by the Runtime. Validators are not concerned with the internal workings from the Runtimes perspective. Collators can use this information for submitting blocks.
****

[#defn-upward-message]
.Upward Message
****
An upward message is an opaque byte array sent from a parachain to a relay chain.
****

[#defn-downward-message]
.Downward Message
****
Definition 2. A downward message is an opaque byte array received by the parachain from the relay chain.
****

[#defn-outbound-hrmp-message]
.Outbound HRMP message
****
Definition 3. An outbound HRMP message (Horizontal Relay-routed Message Passing) is sent from the perspective of a sender of a parachain to an other parachain by passing it through the relay chain. It's a datastructure of the following format:

[stem]
++++
(I,M)
++++

where I is the recipient Id as defined in Definition 7.5 and M is an upward message as defined in Definition 7.8. 
****

[#defn-inbound-hrmp-message]
.Inbound HRMP message
****
An inbound HRMP message (Horizontal Relay-routed Message Passing) is seen from the perspective of a recipient parachain sent from an other parachain by passing it through the relay chain. It's a datastructure of the following format:

[stem]
++++
(N,M)
++++

where N is the relay chain block number at which the message was passed down to the recipient parachain and M is a downward message as defined in Definition 7.9.
****

[#sect-collations]
== Collations

Collations are proposed <<defn-candidate, candidates>> to the Polkadot relay chain validators. The Polkodat network protocol is agnostic on what candidate productionis mechanism each parachain uses and does not specify or mandate any of such production methods (e.g. BABE-GRANDPA, Aura, etc). Furthermore, the relay chain validator host implementation itself does not directly interpret or process teh internal transactions of the candidate, but rather rely on the parachain Runtime to validate the candidate, as described in Section 7.5. Collators, which are parachain nodes which produce candidate proposals and send them to the relay chain validator, must prepare pieces of data specified in Definition 7.12 in order to correctly comply with the requirements of the parachain protocol.

[#defn-collation]
.Collation
****
A collation is a datastructure which contains the proposed parachain candidate, including an optional validation parachain Runtime update and upward messages. The collation datastructure, C, is a datastructure of the following format:

[stem]
++++
C = (M,H,R,h,P,p,w)\
M = (u_n,…u_m)\
H = (z_n,…z_m)
++++

where

• stem:[M] is an array of upward messages, u, interpreted by the relay chain itself, as defined in Definition 7.8.
• stem:[H] is an array of outbound horizontal messages, z, interpreted by other parachains, as defined in Definition 7.10
• stem:[R] is an Option type as defined in Definition ? which can contain a parachain Runtime update. The new Runtime code is an array of bytes.
• stem:[h] is the head data as defined in Definition 7.4 produced as a result of execution of the parachain specific logic.
• stem:[P] is the PoV block as defined in Definition ?.
• stem:[p] is an unsigned 32-bit integer indicating the number of downward messages processed as defined in Definition 7.9.
• stem:[w] is an unsigned 32-bit integer indicating the mark up to which all inbound HRMP messages have been processed by the parachain.
****

[#sect-candidate-backing]
== Candidate Backing

The Polkadot validator receives an arbitrary number of parachain candidates with associated proofs from untrusted collators. The validator must verify and select a specific quantity of the proposed candidates and issue those as backable candidates to its peers. A candidate is considered backable when at least 2/3 of all assigned validators have issued a Valid statement about that candidate, as described in Section 7.4.1. Validators can retrieve information about assignments via the Runtime APIs 7.8.2 respectively 7.8.3.

[#sect-statements]
=== Statements

The assigned validator checks the validity of the proposed parachains blocks as described in Section 7.5 and issues Valid statements as defined in Definition 7.13 to its peers if the verification succeeded. Broadcasting failed verification as Valid statements is a slashable offense. The validator must only issue one Seconded statement, based on an arbitrary metric, which implies an explicit vote for a candidate to be included in the relay chain.

WARNING: TODO: reference disputes

This protocol attempts to produce as many backable candidates as possible, but does not attempt to determine a final candidate for inclusion. Once a parachain candidate has been seconded by at least one other validator and enough Valid statements have been issued about that candidate to meet the 2/3 quorum, the candidate is ready to be inlcuded in the relay chain as described in Section 7.4.2.

The validator issues validity statements votes in form of a validator protocol message as defined in Definition 7.35.

[#defn-statement]
.Statement
****
A statement, stem:[S], is a datastructure of the following format:

[stem]
++++
S = (d,A_i,A_s)\
d = {(1,->,C_r),(2,->,C_h):}
++++

where

•  stem:[d] is a varying datatype where 1 indicates that the validator “seconds” a candidate, meaning that the candidate should be included in the relay chain, followed by the committed candidate receipt, stem:[C_r], as defined in Definition 7.17. 2 indicates that the validator has deemed the candidate valid, followed by the candidate hash.
•  stem:[C_h] is the candidate hash.
•  stem:[A_i] is the validator index in the authority set that signed this statement.
•  stem:[A_s] is the signature of the validator.
****

[#defn-bitfield-array]
.Bitfield Array
****
A bitfield array contains single-bit values which indidate whether a candidate is available. The number of items is equal of to the number of availability cores as defined in Definition 7.6 and each bit represents a vote on the corresponding core in the given order. Respectively, if the single bit equals 1, then the Polkadot validator claims that the availability core is occupied, there exists a committed candidate receipt as defined in Definition 7.17 and that the validator has a stored chunk of the parachain block as defined in Definition 7.6.2.
****

== Inclusion

The Polkadot validator includes the backed candidates as inherent data as defined in Definition 7.15 into a block as described in Section ?. The relay chain block author decides on whatever metric which candidate should be selected for inclusion, as long as that candidate is valid and meets the validity quorum of 2/3+ as described in Section 7.4.1. The candidate approval process as described in Section 7.7 ensures that only relay chain blocks are finalized where each candidate for each availability core meets the requirement of 2/3+ availability votes.

[#defn-parachain-inherent-data]
.Parachain Inherent Data
****
The parachain inherent data contains backed candidates and is included when authoring a relay chain block. The datastructure, stem:[I], is of the following format:

[stem]
++++
I = (A,T,D,P_h)\
T = (C_0,…C_n)\
D = (*d_n,…d_m)\
C = (R,V,i)\
V = (a_n,…a_m)\
a = {(1,->,s),(2,->,s):}\
A = (L_n,…L_m)\
L = (b,v_i,s)
++++

where

•  stem:[A] is an array of signed bitfields by validators claiming the candidate is available (or not). The array must be sorted by validator index corresponding to the authority set as described in Section ?.
•  stem:[T] is an array of backed candidates for inclusing in the current block.
•  stem:[D] is an array of disputes.
•  stem:[P_h] is the parachain parent head data as defined in Definition 7.4.
•  stem:[d] is a dispute statement as described in Section 7.7.3.
•  stem:[R] is a committed candidate receipt as defined in Definition 7.17.
•  stem:[V] is an array of validity votes themselves, expressed as signatures.
•  stem:[i] is a bitfield of indices of the validators within the validator group as defined in Definition 7.7.
•  stem:[a] is either an implicit or explicit attestation of the validity of a parachain candidate, where 1 implies an implicit vote (in correspondence of a Seconded statement) and 2 implies an explicit attestation (in correspondence of a Valid statement). Both variants are followed by the signature of the validator.
•  stem:[s] is the signature of the validator.
•  stem:[b] the availability bitfield as described in Section 7.6.1.
•  stem:[v_i] is the validator index of the authority set as defined in Definition ?.
****

[#defn-candidate-receipt]
.Candidate Receipt
****
A candidate receipt, stem:[R], contains information about the candidate and a proof of the results of its execution. It's a datastructure of the following format:

[stem]
++++
R = (D,C_h)
++++

where stem:[D] is the candidate descriptor as defined in Definition 7.18 and stem:[C_h] is the hash of candidate commitments as defined in Definition 7.19.
****

.Committed Candidate Receipt
****
The committed candidate receipt, stem:[R], contains information about the candidate and the the result of its execution that is included in the relay chain. This type is similiar to the candidate receipt as defined in Definition 7.16, but actually contains the execution results rather than just a hash of it. It's a datastructure of the following format:

[stem]
++++
R = (D,C)
++++

where stem:[D] is the candidate descriptor as defined in Definition 7.18 and stem:[C] is the candidate commitments as defined in Definition 7.19.
****

.Candidate Descriptor
****
The candidate descriptor, stem:[D], is a unique descriptor of a candidate receipt. It's a datastructure of the following format:

[stem]
++++
D = (p,H,C_i,V,B,r,s,p_h,R_h)
++++

where

•  stem:[p] is the parachain Id as defined in Definition 7.5.
•  stem:[H] is the hash of the relay chain block the candidate is executed in the context of.
•  stem:[C_i] is the collators public key.
•  stem:[V] is the hash of the persisted validation data as defined in Definition 7.33.
•  stem:[B] is the hash of the PoV block.
•  stem:[r] is the root of the block's erasure encoding Merkle tree. [clarify]
•  stem:[s] the collator signature of the concatenated components p, H, R_h and B.
•  stem:[p_h] is the hash of the parachain head data as described in Definition 7.4 of this candidate.
•  stem:[R_h] is the hash of the parachain Runtime.
****

.Candidate Commitments
****
The candidate commitments, stem:[C], is the result of the execution and validation of a parachain (or parathread) candidate whose produced values must be committed to the relay chain. Those values are retrieved from the validation result as defined in Definition 7.21. A candidate commitment is a datastructure of the following format:

[stem]
++++
C =(M_u,M_h,R,h,p,w)
++++

where:

•  stem:[M_u] is an array of upward messages sent by the parachain. Each individual message, m, is an array of bytes.
•  stem:[M_h] is an array of outbound horizontal messages sent by the parachain. Each individual messages, t, is a datastructure as defined in Definition 7.10.
•  stem:[R] is an Option value as described in Section ? that can contain a new parachain Runtime in case of an update.
•  stem:[h] is the parachain head data as described in Definition 7.4.
•  stem:[p] is a unsigned 32-bit intiger indicating the number of downward messages that were processed by the parachain. It is expected that the parachain processes the messages from frist to last.
•  stem:[w] is a unsigned 32-bit integer indicating the watermark which specifies the relay chain block number up to which all inbound horizontal messages have been processed.
****

== Candidate Validation

Received candidates submitted by collators and must have its validity verified by the assigned Polkadot validators. For each candidate to be valid, the validator must successfully verify the following conditions in the following order:

. The candidate does not exceed any parameters in the persisted validation data as defined in Definition 7.33.
. The signature of the collator is valid.
. Validate the candidate by executing the parachain Runtime as defined in Definition 7.5.1.

If all steps are valid, the Polkadot validator must create the necessary candidate commitments as defined in Definition 7.19 and submit the appropriate statement for each candidate as described in Section 7.4.1.

=== Parachain Runtime

Parachain Runtimes are stored in the relay chain state, and can either be fetched by the parachain Id or the Runtime hash via the relay chain Runtime API as described in Section 7.8.7 and 7.8.8 respectively. The retrieved parachain Runtime might need to be decompressed based on the magic identifier as described in Section 7.5.2.

In order to validate a parachain block, the Polkadot validator must prepare the validation parameters as defined in Definition 7.20, then use its local Wasm execution environment as described in Section ? to execute the validate_block parachain Runtime API by passing on the validation parameters as an argument. The parachain Runtime function returns the validation result as defined in Definition 7.21.

.Validation Parameters
****
The validation parameters structure, stem:[P], is required to validate a candidate against a parachain Runtime. It's a datastructure of the following format:

[stem]
++++
P = (h,b,B_i,S_r)
++++

where

•  stem:[h] is the parachain head data as defined in Definition 7.4.
•  stem:[b] is the block body as defined in Definition 7.3.
•  stem:[B_i] is the latest relay chain block number.
•  stem:[S_r] is the relay chain block storage root as defined in Definition ?.
****

.Validation Result
****
The validation result is returned by the validate_block parachain Runtime API after attempting to validate a parachain block. Those results are then used in candidate commitments as defined in Definition ?., which then will be inserted into the relay chain via the parachain inherent data as described in Definition 7.15. The validation result, stem:[V], is a datastructure of the following format:

[stem]
++++
V   = (h,R,M_u,M_h,p_,w)\
M_u = (m_0,…m_n)\
M_h = (t_0,…t_n)
++++

where

•  stem:[h] is the parachain head data as defined in Definition 7.4.
•  stem:[R] is an Option value as described in Section ? that can contain a new parachain Runtime in case of an update.
•  stem:[M_u] is an array of upward messages sent by the parachain. Each individual message, m, is an array of bytes.
•  stem:[M_h] is an array of outbound horizontal messages sent by the parachain. Each individual message, t, is a datastructure as defined in Definition 7.10.
•  stem:[p] is a unsigned 32-bit integer indicating the number of downward messages that were processed by the parachain. It is expected that the parachain processes the messages from first to last.
•  stem:[w] is a unsigned 32-bit integer indicating the watermark which specifies the relay chain block number up to which all inbound horizontal messages have been processed.
****

=== Runtime Compression

WARNING: TODO

== Availability

=== Availability Votes

The Polkadot validator must issue a bitfield as defined in Definition 7.14 which indicates votes for the availabilty of candidates. Issued bitfields can be used by the validator and other peers to determine which backed candidates meet the 2/3+ availability quorum.

Candidates are inserted into the relay chain in form of inherent data by a block author, as described in Section 7.4.2. A validator can retrieve that data by calling the appropriate Runtime API entry as described in Section 7.8.3, then create a bitfield indicating for which candidate the validator has availability data stored and broadcast it to the network as defined in Definition 7.38. When sending the bitfield distrubtion message, the validator must ensure B_h is set approriately, therefore clarifying to which state the bitfield is referring to, given that candidates can vary based on the chain fork.

Missing availability data of candidates must be recovered by the validator as described in Section 7.6.2. If previously issued bitfields are no longer accurate, i.e. the availability data has been recovered or the candidate of an availablity core has changed, the validator must create a new bitfield and boradcast it to the network. Candidates must be kept available by validators for a specific amount of time. If a candidate does not receive any backing, validators should keep it available for about one hour, in case the state of backing does change. Backed and even approved candidates (described in Section 7.7) must be kept by validators for about 25 hours, since disputes (described in Section [todo]) can occure and the candidate needs to be checked again.

The validator issues availability votes in form of a validator protocol message as defined in Definition 7.35.

=== Candidate Recovery

The availability distribution of the Polkadot validator must be able to recover parachain candidates that the validator is assigned to, in order to determine whether the candidate should be backed as described in Section 7.4 repsectively whether the candidate should be approved as described in Section 7.7. Additionally, peers can send availability requests as defined in Definition 7.42 and Definition 7.44 to the validator, which the validator should be able to respond to.

Candidates are recovered by sending requests for specific indices of erasure encoded chunks. Erasure encoding is described in Section [todo]. A validator should request chunks by picking peers randomly and must recover at least stem:[f+1] chunks, where stem:[n=3f+k] and stem:[k in {1,2,3}]. stem:[n] is the number of validators as specified in the session info, which can be fetched by the Runtime API as described in Section 7.8.11.

== Approval Voting

The approval voting process ensures that only valid parachain blocks are finalized on the relay chain. After backable parachain candidates were submitted to the relay chain, as described in Section 7.4.2, which can be retrieved by the Runtime API as described in Section 7.8.3, validators need to determine their assignments for each parachain and issue approvals for valid candidates, respectively disputes for invalid candidates. Since it cannot be expected that each validator verifies every single parachain candidate, this mechanism ensures that enough honest validators are selected to verify parachain candidates in order prevent the finalization of invalid blocks. If an honest validator detects an invalid block which was approved by one or more validators, the honest validator must issue a disputes which wil cause escalations, resulting in consequences for all malicious parties, i.e. slashing. This mechanism is described more in Section 7.7.1.

=== Assignment Criteria

Validators determine their assignment based on a VRF mechanism, similiar to the BABE consensus mechanism. First, validators generate an availability core VRF assignment as defined in Definition 7.23, which indicates which availability core a validator is assigned to. Then a delayed availability core VRF assignment is generated which indicates at what point a validator should start the approval process. The delays are based on “tranches”, as described in Section 7.7.2.

An assigned validator never broadcasts their assignment until relevant. Once the assigned validator is ready to check a candidate, the validator broadcasts their assignment by issuing an approval distribution message as defined in Definition 7.39, where M is of variant 0. Other assigned validators that receive that network message must keep track of if, expecting an approval vote following shortly after. Assigned validators can retrieve the candidate by using the availability recovery as described in Section 7.6.2 and then validate the candidate as described in Section 7.5.

The validator issues approval votes in form of a validator protocol message as defined in Definition 7.34 and disputes as described in Section 7.7.3.

=== Tranches

Validators use a subjective, tick-based system to determine when the approval process should start. A validator starts the tick-based system when a new availability core candidates have been proposed, which can be retrieved via the Runtime API as described in Section 7.8.3, and increments the tick every 500 Milliseconds. Each tick/increment is referred to as a “tranche”, represented as an integer, starting at 0.

As described in Section 7.7.1, the validator first executes the VRF mechanism to determine which parachains (availability cores) the validator is assigned to, then an additional VRF mechanism for each assigned parachain to determine the delayed assignment. The delayed assignment indicites the tranche at which the validator should start the approval process. A tranche of value 0 implies that the assignment should be started immediately, while later assignees of later tranches wait until it's their term to issue assignments, determined by their subjective, tick-based system.

Validators are required to track broadcasted assignments by other validators assigned to the same parachain, including verifying the VRF output. Once a valid assignment from a peer was received, the validator must wait for the following approval vote within a certain period as described in Section 7.8.11 by orienting itself on its local, tick-based system. If the waiting time after a broadcasted assignment exceeds the specified period, the validator interprets this behavior as a “no-show”, indicating that more validators should commit on their tranche until enough approval votes have been collected.

If enough approval votes have been collected as described in Section 7.8.11, then assignees of later tranches do not have to start the approval process. Therefore, this tranche system serves as a mechanism to ensure that enough candidate approvals from a random set of validators are created without requiring all assigned validators to check the candidate.

.Relay VRF Story
****
The relay VRF story is an array of random bytes derived from the VRF submitted within the block by the block author. The relay VRF story, T, is used as input to determine approval voting criteria and generated the following way:

[stem]
++++
T = sf "Transcript"(b_r,b_s,e_i,A)
++++

where

•  stem:[sf "Transcript"] constructs a VRF transcript as defined in Definition [todo].
•  stem:[b_r] is the BABE randomness of the current epoch as defined in Definition [todo].
•  stem:[b_s] is the current BABE slot as defined in Definition [todo].
•  stem:[e_i] is the current BABE epoch index as defined in Definition [todo].
•  stem:[A] is the public key of the authority.
****

.Availability Core VRF Assignment
****
An availability core VRF assignment, T, is computed by a relay chain validator to determine which availability core as defined in Definition 7.6 a validator is assigned to and should vote for approvals. The assignment consits of a VRF pair, v, as defined in Definition 7.25 and a VRF proof, p, as defined in Definition 7.26:

[stem]
++++
T = (v,p)
++++

The Runtime dictates how many assignments should be conducted by a validator, as specified in the session index which can be retrieved via the Runtime API as described in Section 7.8.11. The amount of assignments is referred to as “samples”. For each iteration of the number of samples, the validator calculates an individual assignment, T, where the little-endian encoded sample number, S, is incremented by one. At the beginning of the iteration, S starts at value 0.

The validator executes the following steps to retrieve a (possibly valid) core index:

[stem]
++++
t larr sf "Create-Transcript"(''A&V MOD'')\
t larr sf "Meta-Ad"(t,''RC-VRF'',R_s)\
t larr sf "Meta-Ad"(t,''sample'',S)\
e larr sf "Evaluate-VRF"(s_k,t)\
b larr sf "Make-Bytes"(e,4,''A&V CORE'')\
c_i larr sf "LE"(b) mod  a_c
++++

where

•  stem:[sf "Create-Transcript"] is a function defined in Definition 7.30. 
•  stem:[sf "Meta-Ad"] is a function defined in Definition [todo].
•  stem:[sf "Evaluate-VRF"] is a function defined in Definition 7.28.
•  stem:[sf "LE"] implies that the 4-byte input is converted to a little-endian encoded 32-bit interger.
•  stem:[sf "Make-Bytes"] is a function defined in Definition 7.31.
•  stem:[R_s] is the relay VRF story as defined in Definition 7.22.
•  stem:[s_k] is the secret key of the validator.
•  stem:[a_c] is the number of availablity cores used during the active session, as defined in the session info retrieved by the Runtime API as defined in Definition 7.8.11.

The resulting integer, c_i, indicates the parachain Id as defined in Definition 7.5. If the Id doesn't exist, as can be retrieved by the Runtime API as described in Section 7.8.3, the validator discards that value and continues with the next iteration. If the Id does exist, the validators continues with the following steps:

[stem]
++++
t larr sf "Create-Transcript"(''A&V ASSIGNED'')\
t larr sf "Meta-Ad"(t,''core'',c_i)\
(p,phi) larr sf "DLEQ-Proove"(s_k,t,e)\
T = (e,p)
++++

where stem:[sf "DLEQ-Proove"] is a function defined in Definition 7.29. Hence, the full list of available core VRF assignments is represtend as:

[stem]
++++
{T_n,…,T_m}
++++

where each stem:[T_x] corresponds to a sample number. The amount of individual assignments does not necessarily equal the number of samples, but the amount must not exceed the number of samples.
****

.Delayed Availability Core VRF Assignment
****
The delayed availability core VRF assignments determined at what point a validator should start the approval process as described in Section 7.7.2. The validator executes the following steps:

[stem]
++++
t larr sf "Create-Transcript"(''A&V DELAY'')\
t larr sf "Meta-Ad"(t,''RC-VRF'',R_s)\
t larr sf "Meta-Ad"(t,''core'',c_i)\
e larr sf "Evaluate-VRF"(s_k,t_)\
t larr sf "Create-Transcript"(''VRF'')\
(p,x) larr sf "DLEQ-Proove"(s_k,t,e)
++++

The resulting values e and p are the VRF pair as defined in Definition 7.25 respectively the VRF proof as defined in Definition 7.26.

The tranche, stem:[d], is determined as:

[stem]
++++
b = sf "Make-Bytes"(e,4,''A&V TRANCHE'')\
d = sf "LE"(b) mod (d_c+d_z) - d_z
++++

where

•  stem:[sf "Make-Bytes"] is a function defined in Definition 7.31.
•  stem:[sf "LE"] implies that the 4-byte input is converted to a little-endian encoded 32-bit interger.
•  stem:[d_c] is the number of delayed tranches by total as specified by the session info, retrieved via the Runtime API as described in Section 7.8.11.
•  stem:[d_z] is the zeroth delay tranche width as specified by the session info, retrieved via the Runtime API as described in Section 7.8.11.

The resulting tranche, stem:[n], cannot be less than stem:[0]. If the tranche is less than stem:[0], then stem:[d=0].
****

== Runtime API

=== `validators`

Returns the validator set at the current state. The specified validators are responsible for backing parachains for the current state.

Arguments::
* None.

Return::
* An array of public keys representing the validators.

=== `validator_groups`

Returns the validator groups as defined in Definition 7.7 used during the current session. The validators in the groups are referred to by the validator set Id as defined in Definition ?.

Arguments::
* None

Return::
* An array of tuples, stem:[T], of the following format:

[stem]
++++
T = (I,G)\
I = (v_n,…v_m)\
G = (B_s,f,B_c)
++++

where

•  stem:[I] is an array the validator set Ids as defined in Definition ?.
•  stem:[B_s] indicates the block number where the session started.
•  stem:[f] indicates how often groups rotate. 0 means never.
•  stem:[B_c] indicates the current block number. 

=== `availability_cores`

Returns information on all availability cores as defined in Definition 7.6.

Arguments::
* None

Return::
* An array of core states, S, of the following format:

[stem]
++++
S = {(0,->,C_o),(1,->,C_s),(2,->,phi):}\
C_o = (n_u,B_o,B_t,n_t,b,G_i,C_h,C_d)\
C_s = (P_id,C_i)
++++

where

• stem:[S] specifies the core state. stem:[0] indicates that the core is occupied, stem:[1] implies it's currently free but scheduled and given the opportunity to occupy and stem:[2] implies it's free and there's nothing scheduled.
• stem:[n_u] is an Option as described in Definition ? which can contain a stem:[C_s] value if the core was freed by the Runtime and indicates the assignment that is next scheduled on this core. An empty value indicates there is nothing scheduled.
• stem:[B_o] indicates the relay chain block number at which the core got occupied.
• stem:[B_t] indicates the relay chain block number the core will time-out at, if any.
• stem:[n_t] is an Option as described in Definition ? which can contain a stem:[C_s] value if the core is freed by a time-out and indicates the assignment that is next scheduled on this core. An empty value indicates there is nothing scheduled.
• stem:[b] is a bitfield array as defined in Definition 7.14. A stem:[>2/3] majority of assigned validators voting with stem:[1] values means that the core is available.
• stem:[G_i] indicates the assigned validator group index as defined in Definition 7.7 is to distribute availability pieces of this candidate.
• stem:[C_h] indicates the hash of the candidate occypying the core.
• stem:[C_d] is the candidate descriptor as defined in Definition 7.18.
• stem:[C_i] is an Option as described in Definition ? which can contain the collators public key indicating who should author the block.

=== `persisted_validation_data`

Returns the persisted validation data for the given parachain Id and a given occupied core assumption.

Arguments::
* The parachain Id as defined in Definition 7.5.
* An occupied core assumption as defined in Definition 7.32.

Return::
* An _Option_ as described in Definition ? which can contain the persisted validation data as defined in Definition 7.33. The value is empty if the parachain Id is not registered or the core assumption is of index stem:[2], meaning that the core was freed.

.Occupied Core Assumption
****
A occupied core assumption is used for fetching certain pieces of information about a parachain by using the relay chain API. The assumption indicates how the Runtime API should compute the result. [how does the node make assumptions?] The assumptions, A, is a varying datatype of the following format:

[stem]
++++
A = {(0,->,phi),(1,->,phi),(2,->,phi):}
++++

where stem:[0] indicates that the candidate occupying the core was made available and included to free the core, stem:[1] indicates that it timed-out and freed the core without advancing the parachain and stem:[2] indicates that the core was not occupied to begin with.
****

.Persisted Validation Data
****
The persisted validation data provides information about how to create the inputs for the validation of a candidate by calling the Runtime. This information is derived from the parachain state and will vary from parachain to parachain, although some of the fields may be the same for every parachain. This validation data acts as a way to authorize the additional data (such as messages) the collator needs to pass to the validation function.

The persisted validation data, stem:[D_{pv}], is a datastructure of the following format:

[stem]
++++
D_{pv} = (P_h,H_i,H_r,m_b)
++++

where

• stem:[P_h] is the parent head data as defined in Definition 7.4.
• stem:[H_i] is the relay chain block number this is in the context of.
• stem:[H_r] is the relay chain storage root this is in the context of.
• stem:[m_b] is the maximum legal size of the PoV block, in bytes.

The persisted validation data is fetched via the Runtime API as described in Section 7.8.4.
****

=== `check_validation_outputs`

Checks if the given validation outputs pass the acceptance criteria.

Arguments::
* The parachain Id as defined in Definition 7.5.
* The candidate commitments as defined in Definition 7.19.

Return::
* A boolean indicating whether the candidate commitments pass the acceptance criteria.

=== `session_index_for_child`

Returns the session index that is expected at the child of a block.

WARNING: TODO clarify session index

Arguments::
* None

Return::
* A unsigned 32-bit integer representing the session index.

=== `validation_code`

Fetches the validation code (Runtime) of a parachain by parachain Id.

Arguments::
* The parachain Id as defined in Definition 7.5.
* The occupied core assumption as defined in Definition 7.32.

Return::
* An _Option_ value as defined in Definition ? containing the full validation code in an byte array. This value is empty if the parachain Id cannot be found or the assumption is wrong.

=== `validation_code_by_hash`

Returns the validation code (Runtime) of a parachain by its hash.

Arguments::
* The hash value of the validation code.

Return::
* An _Option_ value as defined in Definition ? containing the full validation code in an byte array. This value is empty if the parachain Id cannot be found or the assumption is wrong.

=== `candidate_pending_availability`

Returns the receipt of a candidate pending availability for any parachain assigned to an occupied availability core.

Arguments::
* The parachain Id as defined in Definition 7.5.

Return::
* An Option value as defined in Definition ? containing the committed candidate receipt as defined in Definition 7.16. This value is empty if the given parachain Id is not assigned to an occupied availability cores.

=== `candidate_events`

Returns an array of candidate events that occurred within the latest state.

Arguments::
* None

Return::
* An array of single candidate events, E, of the following format:
+
[stem]
++++
E = {(0,->,d),(1,->,d),(2,->,(C_r,h,I_c)):}\
d = (C_r,h,I_c,G_i)
++++
+
where
+
* stem:[E] specifies the the event type of the candidate. stem:[0] indicates that the candidate receipt was backed in the latest relay chain block, stem:[1] indicates that it was included and became a parachain block at the latest relay chain block and stem:[2] indicates that the candidate receipt was not made available and timed-out.
* stem:[C_r] is the candidate receipt as defined in Definition 7.16.
* stem:[h] is the parachain head data as defined in Definition 7.4.
* stem:[I_c] is the index of the availability core as can be retrieved in Section 7.8.3 that the candidate is occupying. If stem:[E] is of variant stem:[2], then this indicates the core index the candidate was occupying.
* stem:[G_i] is the group index as defined in Definition 7.7 that is responsible of backing the candidate.

=== `session_info`

Get the session info of the given session, if available.

Arguments::
* The unsigned 32-bit integer indicating the session index.

Return::
* An Option type as defined in Definition ? which can contain the session info structure, S, of the following format:
+
[stem]
++++
S = (A,D,K,G,c,z,s,d,x,a)\
A = (v_n,…v_m)\
D = (v_(_n),…v_m)\
K = (v_n,…v_m)\
G = (g_n,…g_m)\
g = (A_n,…A_m)
++++
+
where
+
•  stem:[A] indicates the validators of the current session, in canonical order. There might be more validators in the current session than validators participating in parachain consensus, as returned by the Runtime API as defined in Section 7.8.1.
•  stem:[D] indicates the validator authority discovery keys for the given session in canonical order. The first couple of validators are equal to the corresponding validators participating in the parachain consensus, as returned by the Runtime API as defined in Section 7.8.1. The remaining authorities are not participating in the parachain consensus.
•  stem:[K] indicates the assignment keys for validators. There might be more authorities in the session that validators participating in parachain consensus, as returned by the Runtime API as defined in Section 7.8.1.
•  stem:[G] indicates the validator groups in shuffled order. [what's the purpose of this?]
•  stem:[v_n] is public key of the authority.
•  stem:[A_n] is the authority set Id as defined in Definition [todo].
•  stem:[c] is an unsigned 32-bit integer indicating the number of availability cores used by the protocol during the given session.
•  stem:[z] is an unsigned 32-bit integer indicating the zeroth delay tranche width.
•  stem:[s] is an unsigned 32-bit integer indicating the number of samples an assigned validator should do for approval voting.
•  stem:[d] is an unsigned 32-bit integer indicating the number of delay tranches in total.
•  stem:[x] is an unsigned 32-bit integer indicating how many BABE slots must pass before an assignment is considered a “no-show”. [clarify how to convert between BABE slots and “ticks”]
•  stem:[a] is an unsigned 32-bit integer indicating the number of validators needed to approve a block.

=== `dmq_contents`

Returns all the pending inbound messages in the downward message queue for a given parachain.

Arguments::
* The parachain Id as defined in Definition 7.5.

Return::
* An array of inbound downward messages as defined in (TODO: reference messaging chapter)

=== `inbound_hrmp_channels_contents`

Returns the contents of all channels addressed to the given recipient. Channels that have no messages in them are also included.

Arguments::
* The parachain Id as defined in Definition 7.5.

Return::
* An array of inbound HRMP messages as defined in (TODO: reference messaging chapter)

=== `disputes_info`

WARNING: TODO looks like this was renamed (and modified) into on_chain_votes?

Returns information about all disputes known by the Runtime, including which validators the Runtime will accept disputes from.

Arguments::
* None

Return::
* A dispute information structure, I, of the following format:
+
[stem]
++++
I = ((D_0,…D_n),T)\
D = (i,C_h,S,l)\
T = (m,(p_0,…p_n))\
p = (i,(s_0,…s_n))
++++
+
where
+
•  stem:[D] represents a dispute.
•  stem:[T] represents information about spam slots [clarify]
•  stem:[i] is the session index as defined in Definition [todo].
•  stem:[C_h] is the candidate hash [receipt?].
•  stem:[S] is the dispute state as defined in Definition [todo].
•  stem:[l] is a boolean indacting  . . .  [?].
•  stem:[m] is a unsigned 32-bit integer indicating the maximum spam slots [clarify].
•  stem:[s] is a unsigned 32-bit integer indicating the spam slot.

=== `candidates_included`

WARNING: TODO looks like this was removed?

Checks which candidates have been included within the local chain.

Arguments::
* An array for pairs, p, of the following format:
+
[stem]
++++
p = (i,C_h)
++++
+
where stem:[i] is the session index as defined in Definition [todo] and stem:[C_h] is the candidate hash.

Return::
* An array of booleans which indicate whether the a candidate is included (_true_) or not (_false_). The order of booleans corresponds to the order of the passed on pairs stem:[p].
