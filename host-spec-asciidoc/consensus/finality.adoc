[#sect-finality]
=== Finality

The Polkadot Host uses GRANDPA Finality protocol to finalize blocks.
Finality is obtained by consecutive rounds of voting by the validator
nodes. Validators execute GRANDPA finality process in parallel to Block
Production as an independent service. In this section, we describe the
different functions that GRANDPA service performs to successfully
participate in the block-finalization process.

[#defn-grandpa-voter]
==== GRANDPA Voter
A *GRANDPA Voter*,
stem:[v], represented by a key pair
stem:[(K_v^("pr"),v_("id"))]
where stem:[k_v^("pr")] represents an
_ed25519_ private key, is a
node running a GRANDPA protocol and broadcasting votes to finalize
blocks in a Polkadot Host-based chain. The *set of all GRANDPA voters*
for a given block B is indicated by stem:[bbb "V"_B]. In that
regard, we have [To do: change function name, only call at genesis,
adjust V_B over the sections]

[stem]
++++
bbb "V" = tt "grandpa_authorities"(B)
++++

where stem:[tt "grandpa_authorities"] is the entry into the Runtime described in
Section link:#sect-rte-grandpa-auth[13.3.7.1]. We refer to stem:[bbb "V"_B] as
stem:[bbb "V"] when there is no chance of ambiguity.

Analogously we say that a Polkadot node is a *non-voter node* for block
stem:[B], if it does not own any of the key pairs in
stem:[bbb "V"_B].

[#defn-authority-set-id]
==== Authority Set Id
The *authority set Id* (stem:["id"_(bbb "V")]) is an incremental counter which
tracks the amount of authority list changes that occurred (Definition
link:#defn-consensus-message-digest[[defn-consensus-message-digest]]). Starting
with the value of zero at genesis, the Polkadot Host increments this value by
one every time a *Scheduled Change* or a *Forced Change* occurs. The authority
set Id is an unsigned 64-bit integer.

==== GRANDPA State
TODO: verify V_id and id_V usage, unify

The *GRANDPA state*, stem:["GS"], is defined as:

[stem]
++++
"GS" := {bbb "V", "id"_(bbb "V"),r}
++++

where:

* stem:[bbb "V"]: is the set of voters.
* stem:["id"_(bbb "V")]: is the authority set ID as defined in Definition
link:#defn-authority-set-id[[defn-authority-set-id]].
* stem:[r]: is the voting round number.

[#defn-vote]
==== GRANDPA Vote
A *GRANDPA vote* or simply a vote for block stem:[B] is an ordered pair defined
as

[stem]
++++
V(B) := (H_h(B),H_i(B))
++++

where stem:[H_h(B)] and stem:[H_i (B)] are the block hash and the block number
defined in Definitions link:#defn-block-header[[defn-block-header]] and
link:#defn-block-header-hash[[defn-block-header-hash]] respectively.

==== Voting Rounds
Voters engage in a maximum of two sub-rounds of voting for each round stem:[r].
The first sub-round is called *pre-vote* and the second sub-round is called
*pre-commit*.

By stem:[V_v^(r,"pv")] and stem:[V_v^(r,"pc")] we refer to the vote cast by
voter stem:[v] in round stem:[r] (for block stem:[B]) during the pre-vote and
the pre-commit sub-round respectively.

Voting is done by means of broadcasting voting messages to the network. The
structure of these messages is described in Section
link:#sect-msg-grandpa[4.8.4]. Validators inform their peers about the block
finalized in round stem:[r] by broadcasting a commit message (see Algorithm
link:#algo-grandpa-round[[algo-grandpa-round]] for more details).

[#defn-sign-round-vote]
==== Vote Signature
stem:["Sign"_(v_i)^(r,"stage")] refers to the signature of a voter for a specific
message in a round and is formally defined as:

[stem]
++++
"Sign"_(v_i)^(r,"stage") := "Sig"_("ed25519")("msg",r,"id"_(bbb "V"))
++++

where:

* stem:["msg"]: is an byte array containing the message to be signed (TODO: format of the message?).
* stem:[r]: is an unsigned 64-bit integer is the round number.
* stem:["id"_(bbb "V")]: is an unsigned 64-bit integer indicating the authority set Id (TODO: Reference).

[#defn-grandpa-justification]
==== Justification
The *justification* for block stem:[B] in round stem:[r],
stem:[J^(r,"stage")(B)], is a vector of pairs of the type:

[stem]
++++
(V(B'),"Sign"_(v_i)^(r,"stage")(B'),v_("id"))
++++

in which either

[stem]
++++
B' >= B
++++

or stem:[V_(v_i)^(r,"pc")(B')] is an equivocatory vote.

In all cases, stem:["Sign"_(v_i)^(r,"stage")(B')], as defined in Definition
link:#defn-sign-round-vote[[defn-sign-round-vote]], is the signature of voter
stem:[v_i in bbb "V"_B] broadcasted during either the pre-vote (stage = pv) or
the pre-commit (stage = pc) sub-round of round r. A *valid justification* must
only contain up-to-one valid vote from each voter and must not contain more than
two equivocatory votes from each voter.

[#defn-finalizing-justification]
==== Finalizing Justification
We say stem:[J^(r,"pc")(B)] *justifies the finalization* of stem:[B' >= B] *for
a non-voter node* stem:[n] if the number of valid signatures in
stem:[J^(r,"pc")(B)] for stem:[B'] is greater than stem:[2/3|bbb "V"_B|].

Note that stem:[J^(r,"pc")(B)] can only be used by a non-voter node to finalize
a block. In contrast, a voter node can only be assured of the finality of block
stem:[B] by actively participating in the voting process. That is by invoking
Algorithm link:#algo-grandpa-round[[algo-grandpa-round]]. See Definition
link:#defn-finalized-block[[defn-finalized-block]] for more details.

The GRANDPA protocol dictates how an honest voter should vote in each
sub-round, which is described in Algorithm
link:#algo-grandpa-round[[algo-grandpa-round]]. After defining what
constitutes a vote in GRANDPA, we define how GRANDPA counts votes.

[#defn-equivocation]
==== Equivocation
Voter stem:[v] *equivocates* if they broadcast two or more valid votes to blocks
during one voting sub-round. In such a situation, we say that stem:[v] is an
*equivocator* and any vote stem:[V_v^(r,"stage")(B)] cast by stem:[v] in that
sub-round is an *equivocatory vote*, and

[stem]
++++
cc "E"^(r,"stage")
++++

represents the set of all equivocators voters in sub-round _stage_ of
round stem:[r]. When we want to refer to the number of equivocators whose
equivocation has been observed by voter stem:[v] we refer to it by:

[stem]
++++
cc "E"_("obs"(v))^(r,"stage")
++++

The Polkadot Host must detect equivocations committed by other validators and
submit those to the Runtime as described in Section
link:#sect-grandpaapi_submit_report_equivocation_unsigned_extrinsic[13.3.7.2].

A vote stem:[V_v^(r,"stage") = V(B)] is *invalid* if

* stem:[H (B)] does not correspond to a valid block.
* stem:[B] is not an (eventual) descendant of a previously finalized block.
* stem:[M_v^(r,"stage")] does not bear a valid signature.
* stem:["id"_(bbb "V")] does no match the current stem:[bbb "V"].
* stem:[V_v^(r,"stage")] is an equivocatory vote.

==== Set of Observed Votes
For validator stem:[v], *the set of observed direct votes for Block stem:[B] in
round stem:[r]*, formally denoted by stem:["VD"_("obs"(v))^(r,"stage")(B)] is
equal to the union of:

* set of _valid_ votes stem:[V_(v_i)^(r,"stage")] cast in round stem:[r] and
received by stem:[v] such that stem:[V_(v_i)^(r,"stage") = V(B)].

[#defn-observed-votes]
==== Set of Total Observed Votes
We refer to *the set of total votes observed by voter stem:[v] in sub-round
_stage_ of round stem:[r]* by stem:[V_("obs"(v))^(r,"stage")].

The *set of all observed votes by stem:[v] in the sub-round stage of round
stem:[r] for block stem:[B]*, *stem:[V_("obs"(v))^(r,"stage")]* is equal to all
of the observed direct votes cast for block stem:[B] and all of the stem:[B]â€™s
descendants defined formally as:

[stem]
++++
V_("obs"(v))^(r,"stage")(B) := uuu_(v_i in bbb "V", B >= B') "VD"_("obs"(v))^(r,"stage")(B')
++++

The *total number of observed votes for Block stem:[B] in round stem:[r]* is
defined to be the size of that set plus the total number of equivocator voters:

[stem]
++++
#V_("obs"(v))^(r,"stage")(B) := |V_("obs"(v))^(r,"stage")(B)|+|cc "E"_("obs"(v))^(r,"stage")|
++++

Note that for genesis state we always have
stem:[#V_("obs"(v))^(r,"pv")(B) = |bbb "V"|].

[#defn-total-potential-votes]
==== Set of Total Potential Votes
Let stem:[V_("unobs"(v))^(r,"stage")] be the set of voters whose vote in the
given stage has not been received. We define the *total number of potential
votes for Block stem:[B] in round stem:[r]* to be:

[stem]
++++
#V_("obs"(v),"pot")^(r,"stage")(B) := |V_("obs"(v))^(r,"stage")(B)|+|V_("unobs"(v))^(r,"stage")|+"Min"(1/3|bbb "V"|,|bbb "V"|-|V_("obs"(v))^(r,"stage")(B)|-|V_("unobs"(v))^(r,"stage")|)
++++

==== Current Pre-Voted Block
The current *pre-voted* block stem:[B_v^(r,"pv")] also know as GRANDPA GHOST is
the block chosen by Algorithm link:#algo-grandpa-ghost[[algo-grandpa-ghost]]:

[stem]
++++
B_v^(r,"pv") := "GRANDPA-GHOST"(r)
++++

Finally, we define when a voter stem:[v] sees a round as completable, that is
when they are confident that stem:[B_v^(r,"pv")] is an upper bound for what is
going to be finalized in this round.

[#defn-grandpa-completable]
==== Completable Round
We say that
round stem:[r] is *completable* if
stem:[|V_("obs"(v))^(r,"pc")|+ cc "E"_("obs"(v))^(r,"pc") > 2/3 bbb "V"]
and for all stem:[B' > B_v^(r,"pv")]:

[stem]
++++
|V_("obs"(v))^(r,"pc")|- cc "E"_("obs"(v))^(r,"pc") - |V_("obs"(v))^(r,"pc")(B')|> 2/3|bbb "V"|
++++

Note that in practice we only need to check the inequality for those stem:[B' >
B_v^(r,"pv")] where stem:[|V_("obs"(v))^(r,"pc")(B')| > 0].
