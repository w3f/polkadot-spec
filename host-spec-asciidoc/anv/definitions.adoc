[#sect-anv-definitions]
== Definitions

[#defn-collator]
=== Collator
A collator is a parachain node that sends parachain blocks, known as candidates as defined in Definition 7.2, to the relay chain validators. The relay chain validators are not concerned how the collator works or how it creates candidates.

[#defn-candidate]
=== Candidate
A candidate is a submitted parachain block as defined in Definition 7.3 to the relay chain validators. A parachain block stops being referred to as a candidate as soon it has been finalized.

[#defn-para-block]
=== Parachain Block
A parachain block or a Proof-of-Validity block (PoV block) contains the necessary data to for parachain specific state transition logic. Relay chain validators are not concerned with the inner structure of the block and treat it as a byte array.

[#defn-head-data]
=== Head Data
The head data is contains information about a parachain block as defined in Definition 7.3. The head data is returned by executing the parachain Runtime and relay chain validators are not concerned with its inner structure and treat it as a byte arrays.

[#defn-para-id]
=== Parachain Id
The Parachain Id is a unique, unsigned 32-bit integer which serves as an identifier of a parachain, assigned by the Runtime.

[#defn-availability-core]
=== Availability Core
Availability cores are slots used to process parachains. The Runtime assigns each parachain to a availability core and validators can fetch information about the cores, such as parachain block candidates, by calling the appropriate Runtime API as described in Section 7.8.3. Validators are not concerned with the internal workings from the Runtimes perspective.

[#defn-validator-groups]
=== Validator Groups
Validator groups indicate which validators are responsible for creating backable candidates for certain parachains, as described in Section 7.4, and are assigned by the Runtime. Validators are not concerned with the internal workings from the Runtimes perspective. Collators can use this information for submitting blocks.

[#defn-upward-message]
=== Upward Message
An upward message is an opaque byte array sent from a parachain to a relay chain.

[#defn-downward-message]
=== Downward Message
A downward message is an opaque byte array received by the parachain from the relay chain.

[#defn-outbound-hrmp-message]
=== Outbound HRMP Message
An outbound HRMP message (Horizontal Relay-routed Message Passing) is sent from the perspective of a sender of a parachain to an other parachain by passing it through the relay chain. It's a datastructure of the following format:

[stem]
++++
(I,M)
++++

where I is the recipient Id as defined in Definition 7.5 and M is an upward message as defined in Definition 7.8. 

[#defn-inbound-hrmp-message]
=== Inbound HRMP Message
An inbound HRMP message (Horizontal Relay-routed Message Passing) is seen from the perspective of a recipient parachain sent from an other parachain by passing it through the relay chain. It's a datastructure of the following format:

[stem]
++++
(N,M)
++++

where N is the relay chain block number at which the message was passed down to the recipient parachain and M is a downward message as defined in Definition 7.9.

[#defn-relay-vrf-story]
.Relay VRF Story
=== Relay VRF Story
The relay VRF story is an array of random bytes derived from the VRF submitted within the block by the block author. The relay VRF story, T, is used as input to determine approval voting criteria and generated the following way:

[stem]
++++
T = sf "Transcript"(b_r,b_s,e_i,A)
++++

where

•  stem:[sf "Transcript"] constructs a VRF transcript as defined in Definition [todo].
•  stem:[b_r] is the BABE randomness of the current epoch as defined in Definition [todo].
•  stem:[b_s] is the current BABE slot as defined in Definition [todo].
•  stem:[e_i] is the current BABE epoch index as defined in Definition [todo].
•  stem:[A] is the public key of the authority.

[#defn-availability-core-vrf-assignment]
=== Availability Core VRF Assignment
An availability core VRF assignment, T, is computed by a relay chain validator to determine which availability core as defined in Definition 7.6 a validator is assigned to and should vote for approvals. The assignment consits of a VRF pair, v, as defined in Definition 7.25 and a VRF proof, p, as defined in Definition 7.26:

[stem]
++++
T = (v,p)
++++

The Runtime dictates how many assignments should be conducted by a validator, as specified in the session index which can be retrieved via the Runtime API as described in Section 7.8.11. The amount of assignments is referred to as “samples”. For each iteration of the number of samples, the validator calculates an individual assignment, T, where the little-endian encoded sample number, S, is incremented by one. At the beginning of the iteration, S starts at value 0.

The validator executes the following steps to retrieve a (possibly valid) core index:

[stem]
++++
t larr sf "Create-Transcript"(''A&V MOD'')\
t larr sf "Meta-Ad"(t,''RC-VRF'',R_s)\
t larr sf "Meta-Ad"(t,''sample'',S)\
e larr sf "Evaluate-VRF"(s_k,t)\
b larr sf "Make-Bytes"(e,4,''A&V CORE'')\
c_i larr sf "LE"(b) mod  a_c
++++

where

•  stem:[sf "Create-Transcript"] is a function defined in Definition 7.30. 
•  stem:[sf "Meta-Ad"] is a function defined in Definition [todo].
•  stem:[sf "Evaluate-VRF"] is a function defined in Definition 7.28.
•  stem:[sf "LE"] implies that the 4-byte input is converted to a little-endian encoded 32-bit interger.
•  stem:[sf "Make-Bytes"] is a function defined in Definition 7.31.
•  stem:[R_s] is the relay VRF story as defined in Definition 7.22.
•  stem:[s_k] is the secret key of the validator.
•  stem:[a_c] is the number of availablity cores used during the active session, as defined in the session info retrieved by the Runtime API as defined in Definition 7.8.11.

The resulting integer, c_i, indicates the parachain Id as defined in Definition 7.5. If the Id doesn't exist, as can be retrieved by the Runtime API as described in Section 7.8.3, the validator discards that value and continues with the next iteration. If the Id does exist, the validators continues with the following steps:

[stem]
++++
t larr sf "Create-Transcript"(''A&V ASSIGNED'')\
t larr sf "Meta-Ad"(t,''core'',c_i)\
(p,phi) larr sf "DLEQ-Proove"(s_k,t,e)\
T = (e,p)
++++

where stem:[sf "DLEQ-Proove"] is a function defined in Definition 7.29. Hence, the full list of available core VRF assignments is represtend as:

[stem]
++++
{T_n,…,T_m}
++++

where each stem:[T_x] corresponds to a sample number. The amount of individual assignments does not necessarily equal the number of samples, but the amount must not exceed the number of samples.

[#delayed-availability-core-vrf-assignment]
=== Delayed Availability Core VRF Assignment
The delayed availability core VRF assignments determined at what point a validator should start the approval process as described in Section 7.7.2. The validator executes the following steps:

[stem]
++++
t larr sf "Create-Transcript"(''A&V DELAY'')\
t larr sf "Meta-Ad"(t,''RC-VRF'',R_s)\
t larr sf "Meta-Ad"(t,''core'',c_i)\
e larr sf "Evaluate-VRF"(s_k,t_)\
t larr sf "Create-Transcript"(''VRF'')\
(p,x) larr sf "DLEQ-Proove"(s_k,t,e)
++++

The resulting values e and p are the VRF pair as defined in Definition 7.25 respectively the VRF proof as defined in Definition 7.26.

The tranche, stem:[d], is determined as:

[stem]
++++
b = sf "Make-Bytes"(e,4,''A&V TRANCHE'')\
d = sf "LE"(b) mod (d_c+d_z) - d_z
++++

where

•  stem:[sf "Make-Bytes"] is a function defined in Definition 7.31.
•  stem:[sf "LE"] implies that the 4-byte input is converted to a little-endian encoded 32-bit interger.
•  stem:[d_c] is the number of delayed tranches by total as specified by the session info, retrieved via the Runtime API as described in Section 7.8.11.
•  stem:[d_z] is the zeroth delay tranche width as specified by the session info, retrieved via the Runtime API as described in Section 7.8.11.

The resulting tranche, stem:[n], cannot be less than stem:[0]. If the tranche is less than stem:[0], then stem:[d=0].

[#defn-statement]
=== Statement
A statement, stem:[S], is a datastructure of the following format:

[stem]
++++
S = (d,A_i,A_s)\
d = {(1,->,C_r),(2,->,C_h):}
++++

where

•  stem:[d] is a varying datatype where 1 indicates that the validator “seconds” a candidate, meaning that the candidate should be included in the relay chain, followed by the committed candidate receipt, stem:[C_r], as defined in Definition 7.17. 2 indicates that the validator has deemed the candidate valid, followed by the candidate hash.
•  stem:[C_h] is the candidate hash.
•  stem:[A_i] is the validator index in the authority set that signed this statement.
•  stem:[A_s] is the signature of the validator.

[#defn-bitfield-array]
=== Bitfield Array
A bitfield array contains single-bit values which indidate whether a candidate is available. The number of items is equal of to the number of availability cores as defined in Definition 7.6 and each bit represents a vote on the corresponding core in the given order. Respectively, if the single bit equals 1, then the Polkadot validator claims that the availability core is occupied, there exists a committed candidate receipt as defined in Definition 7.17 and that the validator has a stored chunk of the parachain block as defined in Definition 7.6.2.