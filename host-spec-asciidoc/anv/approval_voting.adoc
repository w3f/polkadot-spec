[#sect-approval-voting]
== Approval Voting

The approval voting process ensures that only valid parachain blocks are finalized on the relay chain. After backable parachain candidates were submitted to the relay chain, as described in Section 7.4.2, which can be retrieved by the Runtime API as described in Section 7.8.3, validators need to determine their assignments for each parachain and issue approvals for valid candidates, respectively disputes for invalid candidates. Since it cannot be expected that each validator verifies every single parachain candidate, this mechanism ensures that enough honest validators are selected to verify parachain candidates in order prevent the finalization of invalid blocks. If an honest validator detects an invalid block which was approved by one or more validators, the honest validator must issue a disputes which wil cause escalations, resulting in consequences for all malicious parties, i.e. slashing. This mechanism is described more in Section 7.7.1.

=== Assignment Criteria

Validators determine their assignment based on a VRF mechanism, similiar to the BABE consensus mechanism. First, validators generate an availability core VRF assignment as defined in Definition 7.23, which indicates which availability core a validator is assigned to. Then a delayed availability core VRF assignment is generated which indicates at what point a validator should start the approval process. The delays are based on “tranches”, as described in Section 7.7.2.

An assigned validator never broadcasts their assignment until relevant. Once the assigned validator is ready to check a candidate, the validator broadcasts their assignment by issuing an approval distribution message as defined in Definition 7.39, where M is of variant 0. Other assigned validators that receive that network message must keep track of if, expecting an approval vote following shortly after. Assigned validators can retrieve the candidate by using the availability recovery as described in Section 7.6.2 and then validate the candidate as described in Section 7.5.

The validator issues approval votes in form of a validator protocol message as defined in Definition 7.34 and disputes as described in Section 7.7.3.

=== Tranches

Validators use a subjective, tick-based system to determine when the approval process should start. A validator starts the tick-based system when a new availability core candidates have been proposed, which can be retrieved via the Runtime API as described in Section 7.8.3, and increments the tick every 500 Milliseconds. Each tick/increment is referred to as a “tranche”, represented as an integer, starting at 0.

As described in Section 7.7.1, the validator first executes the VRF mechanism to determine which parachains (availability cores) the validator is assigned to, then an additional VRF mechanism for each assigned parachain to determine the delayed assignment. The delayed assignment indicites the tranche at which the validator should start the approval process. A tranche of value 0 implies that the assignment should be started immediately, while later assignees of later tranches wait until it's their term to issue assignments, determined by their subjective, tick-based system.

Validators are required to track broadcasted assignments by other validators assigned to the same parachain, including verifying the VRF output. Once a valid assignment from a peer was received, the validator must wait for the following approval vote within a certain period as described in Section 7.8.11 by orienting itself on its local, tick-based system. If the waiting time after a broadcasted assignment exceeds the specified period, the validator interprets this behavior as a “no-show”, indicating that more validators should commit on their tranche until enough approval votes have been collected.

If enough approval votes have been collected as described in Section 7.8.11, then assignees of later tranches do not have to start the approval process. Therefore, this tranche system serves as a mechanism to ensure that enough candidate approvals from a random set of validators are created without requiring all assigned validators to check the candidate.

.Relay VRF Story
****
The relay VRF story is an array of random bytes derived from the VRF submitted within the block by the block author. The relay VRF story, T, is used as input to determine approval voting criteria and generated the following way:

[stem]
++++
T = sf "Transcript"(b_r,b_s,e_i,A)
++++

where

•  stem:[sf "Transcript"] constructs a VRF transcript as defined in Definition [todo].
•  stem:[b_r] is the BABE randomness of the current epoch as defined in Definition [todo].
•  stem:[b_s] is the current BABE slot as defined in Definition [todo].
•  stem:[e_i] is the current BABE epoch index as defined in Definition [todo].
•  stem:[A] is the public key of the authority.
****

.Availability Core VRF Assignment
****
An availability core VRF assignment, T, is computed by a relay chain validator to determine which availability core as defined in Definition 7.6 a validator is assigned to and should vote for approvals. The assignment consits of a VRF pair, v, as defined in Definition 7.25 and a VRF proof, p, as defined in Definition 7.26:

[stem]
++++
T = (v,p)
++++

The Runtime dictates how many assignments should be conducted by a validator, as specified in the session index which can be retrieved via the Runtime API as described in Section 7.8.11. The amount of assignments is referred to as “samples”. For each iteration of the number of samples, the validator calculates an individual assignment, T, where the little-endian encoded sample number, S, is incremented by one. At the beginning of the iteration, S starts at value 0.

The validator executes the following steps to retrieve a (possibly valid) core index:

[stem]
++++
t larr sf "Create-Transcript"(''A&V MOD'')\
t larr sf "Meta-Ad"(t,''RC-VRF'',R_s)\
t larr sf "Meta-Ad"(t,''sample'',S)\
e larr sf "Evaluate-VRF"(s_k,t)\
b larr sf "Make-Bytes"(e,4,''A&V CORE'')\
c_i larr sf "LE"(b) mod  a_c
++++

where

•  stem:[sf "Create-Transcript"] is a function defined in Definition 7.30. 
•  stem:[sf "Meta-Ad"] is a function defined in Definition [todo].
•  stem:[sf "Evaluate-VRF"] is a function defined in Definition 7.28.
•  stem:[sf "LE"] implies that the 4-byte input is converted to a little-endian encoded 32-bit interger.
•  stem:[sf "Make-Bytes"] is a function defined in Definition 7.31.
•  stem:[R_s] is the relay VRF story as defined in Definition 7.22.
•  stem:[s_k] is the secret key of the validator.
•  stem:[a_c] is the number of availablity cores used during the active session, as defined in the session info retrieved by the Runtime API as defined in Definition 7.8.11.

The resulting integer, c_i, indicates the parachain Id as defined in Definition 7.5. If the Id doesn't exist, as can be retrieved by the Runtime API as described in Section 7.8.3, the validator discards that value and continues with the next iteration. If the Id does exist, the validators continues with the following steps:

[stem]
++++
t larr sf "Create-Transcript"(''A&V ASSIGNED'')\
t larr sf "Meta-Ad"(t,''core'',c_i)\
(p,phi) larr sf "DLEQ-Proove"(s_k,t,e)\
T = (e,p)
++++

where stem:[sf "DLEQ-Proove"] is a function defined in Definition 7.29. Hence, the full list of available core VRF assignments is represtend as:

[stem]
++++
{T_n,…,T_m}
++++

where each stem:[T_x] corresponds to a sample number. The amount of individual assignments does not necessarily equal the number of samples, but the amount must not exceed the number of samples.
****

.Delayed Availability Core VRF Assignment
****
The delayed availability core VRF assignments determined at what point a validator should start the approval process as described in Section 7.7.2. The validator executes the following steps:

[stem]
++++
t larr sf "Create-Transcript"(''A&V DELAY'')\
t larr sf "Meta-Ad"(t,''RC-VRF'',R_s)\
t larr sf "Meta-Ad"(t,''core'',c_i)\
e larr sf "Evaluate-VRF"(s_k,t_)\
t larr sf "Create-Transcript"(''VRF'')\
(p,x) larr sf "DLEQ-Proove"(s_k,t,e)
++++

The resulting values e and p are the VRF pair as defined in Definition 7.25 respectively the VRF proof as defined in Definition 7.26.

The tranche, stem:[d], is determined as:

[stem]
++++
b = sf "Make-Bytes"(e,4,''A&V TRANCHE'')\
d = sf "LE"(b) mod (d_c+d_z) - d_z
++++

where

•  stem:[sf "Make-Bytes"] is a function defined in Definition 7.31.
•  stem:[sf "LE"] implies that the 4-byte input is converted to a little-endian encoded 32-bit interger.
•  stem:[d_c] is the number of delayed tranches by total as specified by the session info, retrieved via the Runtime API as described in Section 7.8.11.
•  stem:[d_z] is the zeroth delay tranche width as specified by the session info, retrieved via the Runtime API as described in Section 7.8.11.

The resulting tranche, stem:[n], cannot be less than stem:[0]. If the tranche is less than stem:[0], then stem:[d=0].
****
