[#sect-extrinsics]
=== Extrinsics

The block body consists of an array of extrinsics. In a broad sense,
extrinsics are data from outside of the state which can trigger state
transitions. This section describes extrinsics and their inclusion into
blocks.

==== Preliminaries

The extrinsics are divided into two main categories defined as follows:

*Transaction extrinsics* are extrinsics which are signed using either of
the key types described in section link:#sect-cryptographic-keys[9.5]
and broadcasted between the nodes. *Inherent extrinsics* are unsigned
extrinsics which are generated by Polkadot Host and only included in the
blocks produced by the node itself. They are broadcasted as part of the
produced blocks rather than being gossiped as individual extrinsics.

The Polkadot Host does not specify or limit the internals of each
extrinsics and those are defined and dealt with by the Runtime (defined
in Definition link:#defn-runtime[[defn-runtime]]). From the Polkadot
Host point of view, each extrinsics is simply a SCALE-encoded blob as
defined in Section link:#sect-scale-codec[10.1].

==== Transactions

Transaction are submitted and exchanged through _Transactions_ network
messages (see Section link:#sect-msg-transactions[4.8.3]). Upon
receiving a Transactions message, the Polkadot Host decodes the
SCALE-encoded blob and splits it into individually SCALE-encoded
transactions.

Alternative transaction can be submitted to the host by offchain worker
through the Host API, defined in Section
link:#sect-ext-offchain-submit-transaction[[sect-ext-offchain-submit-transaction]].

Any new transaction should be submitted to the Runtime function, defined
in Section link:#sect-rte-validate-transaction[13.3.4.1]. This will
allow the Polkadot Host to check the validity of the received
transaction against the current stat and if it should be gossiped to
other peers. If considers the submitted transaction as valid, the
Polkadot Host should store it for inclusion in future blocks. The whole
process of handeling new transactions is described in more detail by
Algorithm
link:#algo-validate-transactions[[algo-validate-transactions]].

Additionally valid transactions that are supposed to be gossiped are
propagated to connected peers of the Polkadot Host. While doing so the
Polkadot Host should keep track of peers already aware of each
transaction. This includes peers which have already gossiped the
transaction to the node as well as those to whom the transaction has
already been sent. This behavior is mandated to avoid resending
duplicates and unnecessarily overloading the network. To that aim, the
Polkadot Host should keep a _transaction pool_ and a _transaction queue_
defined as follows:

[#defn-transaction-queue]
===== Definition: Transaction Queue
****
The *Transaction Queue* of a block producer node, formally referred to as
stem:[TQ] is a data structure which stores the transactions ready to be included
in a block sorted according to their priorities (Definition
link:#sect-msg-transactions[4.8.3]). The *Transaction Pool*, formally referred
to as stem:[TP], is a hash table in which the Polkadot Host keeps the list of
all valid transactions not in the transaction queue.

Algorithm link:#algo-validate-transactions[[algo-validate-transactions]]
updates the transaction pool and the transaction queue according to the
received message:
****

[#algo-validate-transactions]
===== Algorithm: Validate Transactions and Store
****
Algorithm: stem:["Validate-Transactions-And-Store"(M_T)]

where

* stem:[M_T] is the transaction message.

which executes the following steps:

. stem:[L larr "DEC"_SC(M_T)]
. stem:["for " T " in " L " such that " E !in TQ " and " E !in TP:]
. stem:["    " B_d larr "Head"("Longest-Chain"(BT))]
. stem:["    " N larr H_n(B_d)]
. stem:["    " R larr "Call-Runtime-Entry"(tt "TaggedTransactionQueue_validate_transaction", N, T)]
. stem:["    " "if " R " indicates " E " is Valid:"]
. stem:["    " "    " "if Requires"(R) sub uuu_(AAT in "TQ") "Provided-Tags"(T) uu uuu_(i<d,AAT,T in B_i) "Provided-Tags"(T):]
. stem:["    " "    " "    " "Insert-At"(TQ,T,"Requires"(R),"Priority"(R))]
. stem:["    " "    " "else"]
. stem:["    " "    " "    " "Add-To"(TP,T)]
. stem:["    " "    " "Maintain-Transaction-Pool"]
. stem:["    " "    " "if Should-Propagate"(R)]
. stem:["    " "    " "    " "Propagate"(T)]

in which

* stem:["DEC"_(SC)] decodes
the SCALE encoded message.
* stem:["Longest-Chain"] is defined in Definition
link:#defn-longest-chain[[defn-longest-chain]].
* stem:[tt "TaggedTransactionQueue_validate_transaction"] is a Runtime entry specified in Section
link:#sect-rte-validate-transaction[13.3.4.1] and Requires(R),
Priority(R) and Propagate(R) refer to the corresponding fields in the
tuple returned by the entry when it deems that stem:[T] is valid.
* stem:["Provided-Tags"(T)] is the list of tags that transaction stem:[T]
provides. The Polkadot Host needs to keep track of tags that transaction
stem:[T] provides as well as requires after validating it.
* stem:["Insert-At"(TQ,T,"Requires"(R),"Priority"(R))] places stem:[T]
into stem:[TQ] approperietly such
that the transactions providing the tags which stem:[T] requires
or have higher priority than stem:[T] are ahead of
stem:[T].
* stem:["Maintain-Transaction-Pool"] is described in Algorithm
link:#algo-maintain-transaction-pool[[algo-maintain-transaction-pool]].
* stem:["ShouldPropagate"] indictes whether the transaction should be propagated
based on the `Propagate` field in the `ValidTransaction`` type as defined in Definition
link:#defn-valid-transaction[[defn-valid-transaction]], which is
returned by stem:[tt "TaggedTransactionQueue_validate_transaction"].
* stem:["Propagate"(T)] sends stem:[T] to all connected
peers of the Polkadot Host who are not already aware of stem:[T].
****

[#algo-maintain-transaction-pool]##[algo-maintain-transaction-pool]##Maintain-Transaction-Pool
===== Algorithm: Maintain Transaction Pool

TODO

[#sect-inherents]
==== Inherents

Inherents are unsigned extrinsic inserted into a block by the block author and
as a result are not stored in the transaction pool or gossiped across the
network. Instead they are generated by the Polkadot Host by passing the required
inherent data, as listed in Table link:#tabl-inherent-data[3.1], to the Runtime
method stem:[tt "BlockBuilder_inherent_extrinsics"] (Section
link:#defn-rt-builder-inherent-extrinsics[13.3.3.3]). The then returned
extrinsics should be included in the current block as explained in Algorithm
link:#algo-build-block[[algo-build-block]]. [To do: define uncles]

[#tabl-inherent-data]
[cols="1,3,6"]
|===
|Identifier |Value Type |Description

|timestap0
|unsigned 64-bit integer
|Unix epoch time (TODO: Reference definition)

|uncles00
|array of block headers
|Provides a list of potential uncle block headers (<<defn-block-header>>) for a given block
|===

[#defn-inherent-data]
===== Definition: Inherent Data
`Inherent-Data` is a hashtable (Definition
link:#defn-scale-list[[defn-scale-list]]), an array of key-value pairs
consisting of the inherent 8-byte identifier and its value, representing the
totality of inherent extrinsics included in each block. The entries of this hash
table which are listed in Table link:#tabl-inherent-data[3.1] are collected or
generated by the Polkadot Host and then handed to the Runtime for inclusion as
dercribed in Algorithm link:#algo-build-block[[algo-build-block]].

