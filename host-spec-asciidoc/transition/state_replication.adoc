[#sect-state-replication]
=== State Replication

Polkadot nodes replicate each other’s state by syncing the history of the
extrinsics. This, however, is only practical if a large set of transactions are
batched and synced at the time. The structure in which the transactions are
journaled and propagated is known as a block (of extrinsics) which is specified
in Section link_sect-block-format[3.3.1]. Like any other replicated state
machines, state inconsistency can occure between Polkadot replicas. Section
link_sect-managing-multiple-states[3.3.3] is giving an overview of how a
Polkadot Host node manages multiple variants of the state.

A Polkadot block consists a _block header_ (Section
link_sect-block-header[3.3.1.1]) and a _block body_ (Section
link_sect-block-body[3.3.1.3]). The _block body_ in turn is made up out of
_extrinsics_ , which represent the generalization of the concept of
_transactions_. _Extrinsics_ can contain any set of external data the underlying
chain wishes to validate and track.

The Block Body consists of an sequence of extrinsics, each encoded as a
byte array. The content of an extrinsic is completely opaque to the
Polkadot Host. As such, from the point of the Polkadot Host, and is
simply a SCALE encoded array of byte arrays. Formally:

[#defn-block-header]
===== Definition: Block Header
****
The *header of block B*, stem:[H_h(B)], is a 5-tuple containing the following
elements:

* *parent_hash:* formally indicated as stem:[H_p], is the 32-byte Blake2b hash
(Section link_sect-blake2[9.2]) of the SCALE encoded parent block header as
defined in Definition link_defn-block-header-hash++defn-block-header-hash]].
* *number:* formally indicated as stem:[H_i], is an integer, which represents
the index of the current block in the chain. It is equal to the number of the
ancestor blocks. The genesis state has number 0.
* *state_root:* formally indicated as stem:[H_r], is the root of the Merkle trie,
whose leaves implement the storage for the system.
* *extrinsics_root:* is the field which is reserved for the Runtime to validate
the integrity of the extrinsics composing the block body. For example, it can
hold the root hash of the Merkle trie which stores an ordered list of the
extrinsics being validated in this block. The [.sans-serif]#extrinsics_root# is
set by the runtime and its value is opaque to the Polkadot Host. This element is
formally referred to as stem:[H_e].
* *digest:* this field is used to store any chain-specific auxiliary data, which
could help the light clients interact with the block without the need of
accessing the full storage as well as consensus-related data including the block
signature. This field is indicated as stem:[H_d] and its detailed format is
defined in Definition link_defn-digest++defn-digest]]
****

[#defn-digest]
===== Definition: Header Digest
****
The header *digest* of block stem:[B] formally referred to by stem:[H_d (B)] is
an array of *digest items* stem:[H_d^i]’s, known as digest items of varying data
type (see Definition link_defn-varrying-data-type++defn-varrying-data-type]])
such that

[stem]
++++
H_d(B) := H_d^1, ..., H_d^n
++++

where each digest item can hold one of the following type identifiers:

[stem]
++++
H_d^n = {(2,bbb "B"_32),(4,(E_(id),bbb "B")),(5,(E_(id),bbb "B")),(6,(E_(id),bbb "B")):}
++++

Where stem:[E_(id)] is the unique consensus engine identifier defined in Section
link_defn-consensus-message-digest++defn-consensus-message-digest]] and stem:[bbb "B"]:

* Id _2_, the *Changes trie root*, contains the root of the Changes Trie at block stem:[B],
as described in Section link_sect-changes-trie[3.3.4]. Note that this is
future-reserved and currently *not* used in Polkadot.
* Id _4_, the *Consensus Message*, represents messages from the Runtime to the
consensus engine (see Section link_sect-consensus-message-digest[6.1.2]).
* Id _5_, the *Seal*, is the data produced by the consensus engine and proving the authorship
of the block producer. In particular, the Seal digest item must be the last item
in the digest array and must be stripped off by the Polkadot Host before the
block is submitted to any Runtime function including for validation. The Seal
must be added back to the digest afterward. The detail of the Seal digest item
is laid out in Definition link_defn-babe-seal++defn-babe-seal]].
* Id _6_, the *Pre-runtime* digest, represents messages from a consensus engine to the
Runtime (e.g. see Definition link_defn-babe-header++defn-babe-header]]).
****

[#defn-block-header-hash]
===== Definition: Header Hash
****
The *block header hash of block stem:[B]*, stem:[H_h(B)], is the hash of the
header of block stem:[$B$] encoded by simple codec:

[stem]
++++
H_h(B) := "Blake2b"("Enc"_(SC)("Head"(B)))
++++
****

[#sect-justified-block-header]
===== Justified Block Header

The Justified Block Header is provided by the consensus engine and
presented to the Polkadot Host, for the block to be appended to the
blockchain. It contains the following parts:

* *block_header* the complete block header as defined in Section
link_block++block]] and denoted by stem:["Head"(B)].
* *justification*: as defined by the consensus specification indicated by
stem:["Just"(B)] as defined in Definition
link_defn-grandpa-justification++defn-grandpa-justification]].
* *authority Ids*: This is the list of the Ids of authorities, which have voted
for the block to be stored and is formally referred to as stem:[A(B)]. An
authority Id is 256-bit.

[#defn-block-body]
===== Definition: Block Body
****
The *body of Block* stem:[B] represented as stem:["Body"(B)] is defined to be:

[stem]
++++
"Body"(B) := "Enc"_(SC)(E_1,...,E_n)
++++

Where each stem:[E_i in bbb "B"] is a SCALE encoded extrinsic.
****

[#sect-block-validation]
==== Importing and Validating Block

Block validation is the process by which a node asserts that a block is fit to
be added to the blockchain. This means that the block is consistent with the
current state of the system and transitions to a new valid state.

New blocks can be received by the Polkadot Host via other peers (see Section
link_sect-msg-block-request[4.8.2]) or from the Host’s own consensus engine
(see Section link_sect-block-production++sect-block-production]]). Both the
Runtime and the Polkadot Host then need to work together to assure block
validity. A block is deemed valid if the block author had authorship rights for
the slot in which the block was produce as well as if the transactions in the
block constitute a valid transition of states. The former criterion is validated
by the Polkadot Host according to the block production consensus protocol. The
latter can be verified by the Polkadot Host invoking entry into the Runtime as
defined in section link_sect-rte-core-execute-block[13.3.1.2] as a part of the
validation process. Any state changes created by this function on successful
execution are persisted.

The Polkadot Host implements the following procedure to assure the
validity of the block:

TODO: Spec algorithm.

[#sect-managing-multiple-states]
==== Managaing Multiple Variants of State

Unless a node is committed to only update its state according to the finalized
block (See Definition link_defn-finalized-block++defn-finalized-block]]), it is
inevitable for the node to store multiple variants of the state (one for each
block). This is, for example, necessary for nodes participating in the block
production and finalization.

While the state trie structure described in Section
link_sect-state-storage-trie-structure[2.1.3] facilitates and optimizes storing
and switching between multiple variants of the state storage, the Polkadot Host
does not specify how a node is required to accomplish this task. Instead, the
Polkadot Host is required to implement Set-State-At operation which behaves as
defined in Definition link_defn-set-state-at++defn-set-state-at]]:

[#defn-set-state-at]
===== Definition: Set State At Block
****
The function:

[stem]
++++
"Set-State-At"(B)
++++

in which stem:[B] is a block in the block tree (See Definition
link_defn-block-tree++defn-block-tree]]), sets the content of state storage
equal to the resulting state of executing all extrinsics contained in the branch
of the block tree from genesis till block B including those recorded in Block stem:[B].

For the definition of the state storage see Section
link_sect-state-storage[2.1].
****

[#sect-changes-trie]
==== Changes Trie

IMPORTANT: Changes Tries are still work-in-progress and are currently *not* used
in Polkadot. Additionally, the implementation of Changes Tries might change
considerably.

Polkadot focuses on light client friendliness and therefore implements
functionalities that allows identifying changes in the state of the blockchain
without the requirement to search through the entire chain. The *Changes Trie*
is a radix-16 tree data structure as defined in Definition
link_defn-radix-tree++defn-radix-tree]] and maintained by the Polkadot Host. It
stores different types of storage changes made by each individual block
separately.

The primary method for generating the Changes Trie is provided to the Runtime
with the Host API as described in Section
link_sect-ext-storage-changes-root[12.1.9]. The Runtime calls that function
shortly before finalizing the block, the Polkadot Host must then generate the
Changes Trie based on the storage changes which occured during block production
or execution. In order to provide this API function, it is imperative that the
Polkadot Host implements a mechanism to keep track of the changes created by
individual blocks, as mentioned in Sections link_sect-state-storage[2.1] and
link_sect-managing-multiple-states[3.3.3]. The Changes Trie stores three
different types of changes.

The Changes Trie itself is not part of the block, but a separately maintained
database by the Polkadot Host. The Merkle proof of the Changes Trie must be
included in the block digest as described in Definition
link_defn-digest++defn-digest]] and gets calculated as described in section
link_sect-merkl-proof[2.1.4]. The root calculation only considers pairs which
were generated on the individual block and does not consider pairs which were
generated at previous blocks.

NOTE: This seperately maintained database by the Polkadot Host is
intended to be used by "proof servers", where its implementation and behavior
has not been fully defined yet. This is considered future-reserved

As clarified in the individual sections of each type, not all of those types get
generated on every block. But if conditions apply, all those different types of
pairs get inserted into the same Changes Trie, therefore only one Changes Trie
Root gets generated for each block.

===== Definition: Inserted Key-Value Pairs
****
The *inserted key-value pair stored in the nodes of Changes Trie* is
formally defined as:

[stem]
++++
(K_C, V_C)
++++

Where stem:[K_C] is a SCALE-encoded tuple:

TODO: Rename Type_V_C and C_(value)

[stem]
++++
"Enc"_(SC)("Type"_(V_C), H_i(B_i),K)
++++

and

[stem]
++++
V_C = "Enc"_(SC)(C_(value))
++++

is a SCALE encoded byte array.

TODO: Reference varying datatype.

Furthermore, stem:[K] represents the changed storage key, stem:[H_i(B_i)] refers
to the block number at which this key is inserted into the Changes Trie (See
Definition link_defn-block-header++defn-block-header]]) and stem:["Type"_(V_C)]
is an index defining the type stem:[C_(value)] according to Table
link_table-changes-trie-key-types[3.2].

[stem]
++++
C_(value) = {(1,(e_i,...,e_k)),(2,(H_i(B_k),...,H_i(B_m))),(3,H_r("Child-Changes-Trie")):}
++++

where:

TODO: Reference

* _1_ is a list of extrinsics indices and stem:[e_n] refers to the index of the extrinsic within the block.
* _2_ is a list of block numbers.
* _3_ is the child changes trie.
****

[#sect-changes-trie-extrinsics-pairs]
===== Key to extrinsics pairs

This key-value pair stores changes which occurred in an individual block. Its
value is a SCALE encoded array containing the indices of the extrinsics that
caused any changes to the specified key. The key-value pair is defined as
(clarified in section link_sect-changes-trie[3.3.4]):

[stem]
++++
(1, H_i (B_i), K) -> (e_i, ..., e_k)
++++

The indices are unsigned 32-bit integers and their values are based on the order
in which each extrinsics appears in the block (indexing starts at 0). The
Polkadot Host generates those pairs for every changed key on each and every
block. Child storages have their own Changes Trie, as described in section
link_sect-changes-trie-child-trie-pair[3.3.4.3].

IMPORTANT: TODO - clarify special key value of `0xffffffff`

[#sect-changes-trie-block-pairs]
===== Key to block pairs

This key-value pair stores changes which occurred in a certain range of blocks.
Its value is a SCALE encoded array containing block numbers in which extrinsics
caused any changes to the specified key. The key-value pair is defined as
(clarified in section link_sect-changes-trie[3.3.4]):

[stem]
++++
(2, H_i (B_i), K) -> (H_i (B_k), ..., H_i (B_m))
++++

The block numbers are represented as unsigned 32-bit integers. There are
multiple "levels" of those pairs, and the Polkadot Host does *not* generate
those pairs on every block. The genesis state contains the key `:changes_trie`
where its unsigned 64-bit value is a tuple of two 32-bit integers:

* *interval* - The interval (in blocks) at which those pairs should be created.
If this value is less or equal to 1 it means that those pairs are not created at
all.
* *levels* - The maximum number of "levels" in the hierarchy. If this value is
0 it means that those pairs are not created at all.

For each level from 1 to _levels_, the Polkadot Host creates those pairs on
every -nth block, formally applied as:

TODO: Spec algorithm

For example, let’s say _interval_ is set at and is set at . This means there are
now three levels which get generated at three different occurrences:

. *Level 1* - Those pairs are generated at every stem:[4^1]-nth block, where the
pair value contains the block numbers of every block that changed the specified
storage key. This level only considers block numbers of the last four
(stem:[4^1]) blocks.
** Example: this level occurs at block 4, 8, 12, 16, 32, etc.
. *Level 2* - Those pairs are generated at every stem:[4^2]-nth block, where the
pair value contains the block numbers of every block that changed the specified
storage key. This level only considers block numbers of the last 16
(stem:[4^2]) blocks.
** Example: this level occurs at block 16, 32, 64, 128, 256, etc.
. *Level 3* - Those pairs are generated at every stem:[4^3]-nth block, where the
pair value contains the block numbers of every block that changed the specified
storage key. this level only considers block number of the last 64
(stem:[4^3]) blocks.
** Example: this level occurs at block 64, 128, 196, 256, 320, etc.

[#sect-changes-trie-child-trie-pair]
===== Key to Child Changes Trie pairs

The Polkadot Host generates a separate Changes Trie for each child storage,
using the same behavior and implementation as describe in section
link_sect-changes-trie-extrinsics-pairs[3.3.4.1]. Additionally, the changed
child storage key gets inserted into the primary, non-Child Changes Trie where
its value is a SCALE encoded byte array containing the Merkle root of the Child
Changes Trie. The key-value pair is defined as:

[stem]
++++
(3,H_i(B_i),K) -> H_r("Child-Changes-Trie")
++++

The Polkadot Host creates those pairs for every changes child key for each and
every block.
