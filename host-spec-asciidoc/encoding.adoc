[#sect-scale-codec]
=== SCALE Codec

The Polkadot Host uses _Simple Concatenated Aggregate Little-Endian” (SCALE)
codec_ to encode byte arrays as well as other data structures. SCALE provides a
canonical encoding to produce consistent hash values across their
implementation, including the Merkle hash proof for the State Storage.

[#defn-scale-byte-array]
==== Byte Array
****
The *SCALE codec* for *Byte array*, stem:[A], such that:

[stem]
++++
A := (b_1, b_2, ... b_n)
++++

such that stem:[n < 2^(536)] is a byte array referred to stem:["Enc"_("SC")(A)]
and defined as:

[stem]
++++
"Enc"_("SC")(A) := "Enc"_("SC")^("Len")(||A||)||A
++++

where stem:["Enc"_("SC")^("Len)] is defined in Definition
link:#defn-sc-len-encoding[[defn-sc-len-encoding]].
****

[#defn-scale-tuple]
==== Tuple
****
The *SCALE codec* for *Tuple*, stem:[$T$], such that:

[stem]
++++
T := (A_1,... A_n)
++++

Where stem:[A_i]’s are values of *different types*, is defined as:

[stem]
++++
"Enc"_("SC")(T) := "Enc"_("SC")(A_1)||"Enc"_("SC")(A_2)||...||"Enc"_("SC")(A_n)
++++

In case of a tuple (or a structure), the knowledge of the shape of data is not
encoded even though it is necessary for decoding. The decoder needs to derive
that information from the context where the encoding/decoding is happening.
****

[#defn-varrying-data-type]
==== Varying Datatype
****
We define a *varying data* type to be an ordered set of data types.

[stem]
++++
cc "T" = {T_1, ..., T_n}
++++

TODO: Maybe rephrase/restructure this?

A value stem:[A] of varying date type is a pair stem:[(A_("Type"),A_("Value"))]
where stem:[A_("Type") = T_i] for some stem:[T_i in cc "T"] and
stem:[A_("Value")] is its value of type stem:[T_i], which can be empty. We
define stem:["idx"(T_i) = i - 1], unless it is explicitly defined as another
value in the definition of a particular varying data type.

In particular, we define two specific varying data which are frequently used in
various part of Polkadot Protocol (TODO: reference).
****

[#defn-scale-variable-type]
===== Encoding
Scale coded for value stem:[A = (A_("Type"), A_("Value"))] of varying data type
stem:[cc "T" = {T_i, ... T_n}].

[stem]
++++
"Enc"_("SC")(A) := "Enc"_("SC")("idx"(A_("Type"))||"Enc"_("SC")(A_("Value")))
++++

Where stem:["idx"] is encoded in a fixed length integer determining the type of
stem:[A]. In particular, for the optional type defined in Definition
link:#defn-varrying-data-type[[defn-varrying-data-type]], we have:

[stem]
++++
"Enc"_("SC")(("None", phi)) := 0_(bbb "B"_1)
++++

SCALE codec does not encode the correspondence between the value of stem:[idx]
defined in Definition link:#defn-scale-variable-type[[defn-scale-variable-type]]
and the data type it represents; the decoder needs prior knowledge of such
correspondence to decode the data.

[#defn-option-type]
===== Option Type
****
The *Option* type is a varying data type of stem:[{"None",T_2}] which indicates if
data of stem:[T_2] type is available (referred to as _some_ state) or not
(referred to as _empty_, _none_ or _null_ state). The presence of type _none_,
indicated by stem:["idx"(T_("None")) = 0], implies that the data corresponding
to stem:[T_2] type is not available and contains no additional data. Where as
the presence of type stem:[T_2] indicated by stem:["idx"(T_2) = 1] implies that
the data is available.
****

[#defn-result-type]
===== Result Type
****
The *Result* type is a varying data type of stem:[{T_1, T_2}] which is used to
indicate if a certain operation or function was executed successfully (referred
to as "ok" state) or not (referred to as "error" state). stem:[T_1] implies
success, stem:[T_2] implies failure. Both types can either contain additional
data or are defined as empty type otherwise.
****

[#defn-scale-list]
==== Sequence
****
The *SCALE codec* for *sequence* stem:[S] such that:

[stem]
++++
S := A_1, ... A_n
++++

where stem:[A_i]’s are values of *the same type* (and the decoder is unable to
infer value of stem:[n] from the context) is defined as:

[stem]
++++
"Enc"_("SC")(S) := "Enc"_("SC")("Len")(||S||)|"Enc"_("SC")(A_2)|...|"Enc"_("SC")(A_n)
++++

where stem:["Enc"_("SC")^("Len")] is defined in Definition
link:#defn-sc-len-encoding[[defn-sc-len-encoding]].
****

==== Dictionary
****
SCALE codec for *dictionary* or *hashtable* D with key-value pairs stem:[(k_i,
v_i)]s such that:

[stem]
++++
D := {(k_1,v_1), ... (k_n, v_n)}
++++

is defined the SCALE codec of stem:[D] as a sequence of key value pairs (as
tuples):

[stem]
++++
"Enc"_("SC")(D) := "Enc"_("SC")^("Size")(||D||)|"Enc"_("SC")((k_1, v_1))|"Enc"_("SC")|...|((k_n, v_n))
++++

where stem:["Enc"_("SC")^("Size")] is encoded the same way as
stem:["Enc"_("SC")^("Len")] but argument stem:["Size"] refers to the number of
key-value pairs rather than the length.
****

==== Boolean
****
The *SCALE codec* for *boolean value* stem:[b] defined as a byte as follows:

[stem]
++++
"Enc"_("SC"): {"False","True"} -> bbb "B"_1\
b -> {(0,b="False"),(1,b="True"):}
++++
****

==== Decoding
****
stem:["Dec"_("SC")(d)]
refers to the decoding of a blob of data. Since the SCALE codec is not
self-describing, it’s up to the decoder to validate whether the blob of data can
be deserialized into the given type or datastructure.
****

[#defn-scale-fixed-length]
==== Fixed Length
****
The SCALE codec, stem:["Enc"_("SC")], for other types such as fixed length
integers not defined here otherwise, is equal to little endian encoding of those
values defined in Definition link:#defn-little-endian[[defn-little-endian]].
****

[#defn-scale-empty]
==== Empty
****
The SCALE codec, stem:["Enc"_("SC")], for an empty type is defined to a byte
array of zero length and depicted as stem:[phi].
****
