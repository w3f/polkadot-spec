"use strict";(self.webpackChunkspec_website=self.webpackChunkspec_website||[]).push([[620],{3905:(e,t,o)=>{o.d(t,{Zo:()=>p,kt:()=>m});var n=o(7294);function r(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function a(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function i(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?a(Object(o),!0).forEach((function(t){r(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):a(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function c(e,t){if(null==e)return{};var o,n,r=function(e,t){if(null==e)return{};var o,n,r={},a=Object.keys(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||(r[o]=e[o]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var l=n.createContext({}),s=function(e){var t=n.useContext(l),o=t;return e&&(o="function"==typeof e?e(t):i(i({},t),e)),o},p=function(e){var t=s(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var o=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),d=s(o),h=r,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||a;return o?n.createElement(m,i(i({ref:t},p),{},{components:o})):n.createElement(m,i({ref:t},p))}));function m(e,t){var o=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=o.length,i=new Array(a);i[0]=h;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c[d]="string"==typeof e?e:r,i[1]=c;for(var s=2;s<a;s++)i[s]=o[s];return n.createElement.apply(null,i)}return n.createElement.apply(null,o)}h.displayName="MDXCreateElement"},4837:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>c,toc:()=>s});var n=o(7462),r=(o(7294),o(3905));const a={title:"Polkadot Protocol"},i=void 0,c={unversionedId:"id-polkadot-protocol",id:"id-polkadot-protocol",title:"Polkadot Protocol",description:"This specification is Work-In-Progress and any content, structure, design and/or hyper/anchor-link is subject to change.",source:"@site/docs/id-polkadot-protocol.md",sourceDirName:".",slug:"/id-polkadot-protocol",permalink:"/id-polkadot-protocol",draft:!1,unlisted:!1,editUrl:"https://github.com/w3f/polkadot-spec/blob/main/src/docs/id-polkadot-protocol.md",tags:[],version:"current",frontMatter:{title:"Polkadot Protocol"},sidebar:"tutorialSidebar",next:{title:"Polkadot Host",permalink:"/part-polkadot-host"}},l={},s=[],p={toc:s},d="wrapper";function u(e){let{components:t,...o}=e;return(0,r.kt)(d,(0,n.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"This specification is ",(0,r.kt)("strong",{parentName:"p"},"Work-In-Progress")," and any content, structure, design and/or hyper/anchor-link ",(0,r.kt)("strong",{parentName:"p"},"is subject to change"),".")),(0,r.kt)("p",null,"Formally, Polkadot is a replicated sharded state machine designed to resolve the scalability and interoperability among blockchains. In Polkadot vocabulary, shards are called ",(0,r.kt)("em",{parentName:"p"},"parachains")," and Polkadot ",(0,r.kt)("em",{parentName:"p"},"relay chain")," is part of the protocol ensuring global consensus among all the parachains. The Polkadot relay chain protocol, henceforward called ",(0,r.kt)("em",{parentName:"p"},"Polkadot protocol"),", can itself be considered as a replicated state machine on its own. As such, the protocol can be specified by identifying the state machine and the replication strategy."),(0,r.kt)("p",null,"From a more technical point of view, the Polkadot protocol has been divided into two parts, the ",(0,r.kt)("a",{parentName:"p",href:"part-polkadot-runtime"},"Polkadot Runtime")," and the ",(0,r.kt)("a",{parentName:"p",href:"part-polkadot-host"},"Polkadot Host"),". The Runtime comprises the state transition logic for the Polkadot protocol and is designed and be upgradable via the consensus engine without requiring hard forks of the blockchain. The Polkadot Host provides the necessary functionality for the Runtime to execute its state transition logic, such as an execution environment, I/O, consensus and network interoperability between parachains. The Polkadot Host is planned to be stable and mostly static for the lifetime duration of the Polkadot protocol, the goal being that most changes to the protocol are primarily conducted by applying Runtime updates and not having to coordinate with network participants on manual software updates."))}u.isMDXComponent=!0}}]);