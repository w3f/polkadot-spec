[#sect-crypto-api]
== Crypto

Interfaces for working with crypto related types from within the runtime.

[#defn-key-type-id]
.<<defn-key-type-id, Key Type Identifier>>
====
Cryptographic keys are stored in separate key stores based on their intended use
case. The separate key stores are identified by a 4-byte ASCII *key type
identifier*. The following known types are available:

.Table of known key type identifiers
|===
|Id|Description

|acco |Key type for the controlling accounts
|babe |Key type for the Babe module
|gran |Key type for the Grandpa module
|imon |Key type for the ImOnline module
|audi |Key type for the AuthorityDiscovery module
|para |Key type for the Parachain Validator Key
|asgn |Key type for the Parachain Assignment Key
|===
====

[#defn-ecdsa-verify-error]
.<<defn-ecdsa-verify-error, ECDSA Verify Error>>
====
*EcdsaVerifyError* is a varying data type (<<defn-varrying-data-type>>) that
specifies the error type when using ECDSA recovery functionality. Following
values are possible:

.Table of error types in ECDSA recovery
|===
|Id|Description

|0 |Incorrect value of R or S
|1 |Incorrect value of V
|2 |Invalid signature
|===
====

=== Functions

==== `ext_crypto_ed25519_public_keys`

Returns all _ed25519_ public keys for the given key identifier from the keystore.

===== Version 1 - Prototype
----
(func $ext_crypto_ed25519_public_keys_version_1
	(param $key_type_id i32) (return i64))
----

Arguments::

* `key_type_id`: a 32-bit pointer to the key type identifier
(<<defn-key-type-id>>).
* `return`: a pointer-size (<<defn-runtime-pointer>>) to an SCALE encoded
256-bit public keys.

==== `ext_crypto_ed25519_generate`

Generates an _ed25519_ key for the given key type using an optional BIP-39 seed and stores
it in the keystore.

WARNING: Panics if the key cannot be generated, such as when an invalid key type
or invalid seed was provided.

===== Version 1 - Prototype
----
(func $ext_crypto_ed25519_generate_version_1
	(param $key_type_id i32) (param $seed i64) (return i32))
----

Arguments::

* `key_type_id`: a 32-bit pointer to the key type identifier
(<<defn-key-type-id>>).
* `seed`: a pointer-size (<<defn-runtime-pointer>>) indicating the SCALE encoded
_Option_ value (<<defn-option-type>>) containing the BIP-39 seed which must be
valid UTF8.
* `return`: a 32-bit pointer to the buffer containing the 256-bit public key.

==== `ext_crypto_ed25519_sign`

Signs the given message with the `ed25519` key that corresponds to the given public key
and key type in the keystore.

===== Version 1 - Prototype
----
(func $ext_crypto_ed25519_sign_version_1
	(param $key_type_id i32) (param $key i32) (param $msg i64) (return i64))
----

Arguments::

* `key_type_id`: a 32-bit pointer to the key type identifier
(<<defn-key-type-id>>).
* `key`: a 32-bit pointer to the buffer containing the 256-bit public key.
* `msg`: a pointer-size (<<defn-runtime-pointer>>) indicating the
message that is to be signed.
* `return`: a pointer-size (<<defn-runtime-pointer>>) indicating the SCALE
encoded _Option_ value (<<defn-option-type>>) containing the 64-byte signature.
This function returns if the public key cannot be found in the key store.

[#sect-ext-crypto-ed25519-verify]
==== `ext_crypto_ed25519_verify`

Verifies an _ed25519_ signature. Returns when the verification is either
successful or batched. If no batching verification extension is registered, this
function will fully verify the signature and return the result. If batching
verification is registered, this function will push the data to the batch and
return immediately. The caller can then get the result by calling
`ext_crypto_finish_batch_verify`
(<<sect-ext-crypto-finish-batch-verify>>).

The verification extension is explained more in detail in
(<<sect-ext-crypto-start-batch-verify>>).

===== Version 1 - Prototype
----
(func $ext_crypto_ed25519_verify_version_1
	(param $sig i32) (param $msg i64) (param $key i32) (return i32))
----

Arguments::

* `sig`: a 32-bit pointer to the buffer containing the 64-byte signature.
* `msg`: a pointer-size (<<defn-runtime-pointer>>) indicating the
message that is to be verified.
* `key`: a 32-bit pointer to the buffer containing the 256-bit public key.
* `return`: a i32 integer value equal to if the signature is valid or batched or
a value equal to if otherwise.

==== `ext_crypto_sr25519_public_keys`

Returns all _sr25519_ public keys for the given key id from the keystore.

===== Version 1 - Prototype
----
(func $ext_crypto_sr25519_public_keys_version_1
	(param $key_type_id i32) (return i64))
----

Arguments::

* `key_type_id`: a 32-bit pointer to the key type identifier
(<<defn-key-type-id>>).
* `return`: a pointer-size (<<defn-runtime-pointer>>) indicating the
SCALE encoded 256-bit public keys.

==== `ext_crypto_sr25519_generate`

Generates an _sr25519_ key for the given key type using an optional BIP-39 seed
and stores it in the keystore.

WARNING: Panics if the key cannot be generated, such as when an invalid key type
or invalid seed was provided.

===== Version 1 - Prototype
----
(func $ext_crypto_sr25519_generate_version_1
	(param $key_type_id i32) (param $seed i64) (return i32))
----

Arguments::

* `key_type_id`: a 32-bit pointer to the key identifier (<<defn-key-type-id>>).
* `seed`: a pointer-size (<<defn-runtime-pointer>>) indicating the SCALE encoded
_Option_ value (<<defn-option-type>>) containing the BIP-39 seed which must be
valid UTF8.
* `return`: a 32-bit pointer to the buffer containing the 256-bit public key.

==== `ext_crypto_sr25519_sign`

Signs the given message with the _sr25519_ key that corresponds to the given
public key and key type in the keystore.

===== Version 1 - Prototype
----
(func $ext_crypto_sr25519_sign_version_1
	(param $key_type_id i32) (param $key i32) (param $msg i64) (return i64))
----

Arguments::

* `key_type_id`: a 32-bit pointer to the key identifier (<<defn-key-type-id>>).
* `key`: a 32-bit pointer to the buffer containing the 256-bit public key.
* `msg`: a pointer-size (<<defn-runtime-pointer>>) indicating the
message that is to be signed.
* `return`: a pointer-size (<<defn-runtime-pointer>>) indicating the SCALE
encoded _Option_ value (<<defn-option-type>>) containing the 64-byte signature.
This function returns _None_ if the public key cannot be found in the key store.

[#sect-ext-crypto-sr25519-verify]
==== `ext_crypto_sr25519_verify`

Verifies an _sr25519_ signature. Only version 1 of this function supports
deprecated Schnorr signatures introduced by the _schnorrkel_ Rust library
version 0.1.1 and should only be used for backward compatibility.

Returns when the verification is either successful or batched. If no batching
verification extension is registered, this function will fully verify the
signature and return the result. If batching verification is registered, this
function will push the data to the batch and return immediately. The caller can
then get the result by calling `ext_crypto_finish_batch_verify`
(<<sect-ext-crypto-finish-batch-verify>>).

The verification extension is explained more in detail in
<<sect-ext-crypto-start-batch-verify>>.

===== Version 1 - Prototype
----
(func $ext_crypto_sr25519_verify_version_1
	(param $sig i32) (param $msg i64) (param $key i32) (return i32))
----

Arguments::

* `sig`: a 32-bit pointer to the buffer containing the 64-byte signature.
* `msg`: a pointer-size (<<defn-runtime-pointer>>) indicating the
message that is to be verified.
* `key`: a 32-bit pointer to the buffer containing the 256-bit public key.
* `return`: a i32 integer value equal to _1_ if the signature is valid or a
value equal to _0_ if otherwise.

===== Version 2 - Prototype
----
(func $ext_crypto_sr25519_verify_version_2
	(param $sig i32) (param $msg i64) (param $key i32) (return i32))
----

Arguments::

* `sig`: a 32-bit pointer to the buffer containing the 64-byte signature.
* `msg`: a pointer-size (<<defn-runtime-pointer>>) indicating the
message that is to be verified.
* `key`: a 32-bit pointer to the buffer containing the 256-bit public key.
* `return`: a i32 integer value equal to _1_ if the signature is valid or a
value equal to _0_ if otherwise.

==== `ext_crypto_ecdsa_public_keys`

Returns all _ecdsa_ public keys for the given key id from the keystore.

===== Version 1 - Prototype
----
(func $ext_crypto_ecdsa_public_key_version_1
	(param $key_type_id i64) (return i64))
----

Arguments::

* `key_type_id`: a 32-bit pointer to the key type identifier (<<defn-key-type-id>>).
* `return`: a pointer-size (<<defn-runtime-pointer>>) indicating the
SCALE encoded 33-byte compressed public keys.

==== `ext_crypto_ecdsa_generate`

Generates an _ecdsa_ key for the given key type using an optional BIP-39 seed
and stores it in the keystore.

WARNING: Panics if the key cannot be generated, such as when an invalid key type
or invalid seed was provided.

===== Version 1 - Prototype
----
(func $ext_crypto_ecdsa_generate_version_1
	(param $key_type_id i32) (param $seed i64) (return i32))
----

Arguments::

* `key_type_id`: a 32-bit pointer to the key identifier (<<defn-key-type-id>>).
* `seed`: a pointer-size (<<defn-runtime-pointer>>) indicating the SCALE encoded
_Option_ value (<<defn-option-type>>) containing the BIP-39 seed which must be
valid UTF8.
* `return`: a 32-bit pointer to the buffer containing the 33-byte compressed
public key.

==== `ext_crypto_ecdsa_sign`

Signs the given message with the _ecdsa_ key that corresponds to the given
public key and key type in the keystore.

===== Version 1 - Prototype
----
(func $ext_crypto_ecdsa_sign_version_1
	(param $key_type_id i32) (param $key i32) (param $msg i64) (return i64))
----

Arguments::

* `key_type_id`: a 32-bit pointer to the key identifier (<<defn-key-type-id>>).
* `key`: a 32-bit pointer to the buffer containing the 33-byte compressed public
key.
* `msg`: a pointer-size (<<defn-runtime-pointer>>) indicating the
message that is to be signed.
* `return`: a pointer-size (<<defn-runtime-pointer>>) indicating the SCALE
encoded _Option_ value (<<defn-option-type>>) containing the signature. The
signature is 65-bytes in size, where the first 512-bits represent the signature
and the other 8 bits represent the recovery ID. This function returns if the
public key cannot be found in the key store.

[#sect-ext-crypto-ecdsa-verify]
==== `ext_crypto_ecdsa_verify`

Verifies an _ecdsa_ signature. Returns when the verification is either
successful or batched. If no batching verification extension is registered, this
function will fully verify the signature and return the result. If batching
verification is registered, this function will push the data to the batch and
return immediately. The caller can then get the result by calling
`ext_crypto_finish_batch_verify` (<<sect-ext-crypto-finish-batch-verify>>).

The verification extension is explained more in detail in
<<sect-ext-crypto-start-batch-verify>>.

===== Version 1 - Prototype

This function allows the verification of non-standard, overflowing ECDSA signatures, an
implemenation specific mechanism of the Rust
https://github.com/paritytech/libsecp256k1[`libsecp256k1` library], specifically
the
https://docs.rs/libsecp256k1/0.7.0/libsecp256k1/struct.Signature.html#method.parse_overflowing[`parse_overflowing`]
function.

----
(func $ext_crypto_ecdsa_verify_version_1
	(param $sig i32) (param $msg i64) (param $key i32) (return i32))
----

Arguments::

* `sig`: a 32-bit pointer to the buffer containing the 65-byte signature. The
signature is 65-bytes in size, where the first 512-bits represent the signature
and the other 8 bits represent the recovery ID.
* `msg`: a pointer-size (<<defn-runtime-pointer>>) indicating the
message that is to be verified.
* `key`: a 32-bit pointer to the buffer containing the 33-byte compressed public
key.
* `return`: a i32 integer value equal _1_ to if the signature is valid or a
value equal to _0_ if otherwise.

===== Version 2 - Prototype

Does not allow the verification of non-standard, overflowing ECDSA signatures.

----
(func $ext_crypto_ecdsa_verify_version_2
	(param $sig i32) (param $msg i64) (param $key i32) (return i32))
----

Arguments::

* `sig`: a 32-bit pointer to the buffer containing the 65-byte signature. The
signature is 65-bytes in size, where the first 512-bits represent the signature
and the other 8 bits represent the recovery ID.
* `msg`: a pointer-size (<<defn-runtime-pointer>>) indicating the
message that is to be verified.
* `key`: a 32-bit pointer to the buffer containing the 33-byte compressed public
key.
* `return`: a i32 integer value equal _1_ to if the signature is valid or a
value equal to _0_ if otherwise.

==== `ext_crypto_secp256k1_ecdsa_recover`

Verify and recover a _secp256k1_ ECDSA signature.

===== Version 1 - Prototype

This function can handle non-standard, overflowing ECDSA signatures, an
implemenation specific mechanism of the Rust
https://github.com/paritytech/libsecp256k1[`libsecp256k1` library], specifically
the
https://docs.rs/libsecp256k1/0.7.0/libsecp256k1/struct.Signature.html#method.parse_overflowing[`parse_overflowing`]
function.

----
(func $ext_crypto_secp256k1_ecdsa_recover_version_1
	(param $sig i32) (param $msg i32) (return i64))
----

Arguments::

* `sig`: a 32-bit pointer to the buffer containing the 65-byte signature in RSV
format. V should be either or .
* `msg`: a 32-bit pointer to the buffer containing the 256-bit Blake2 hash of
the message.
* `return`: a pointer-size (<<defn-runtime-pointer>>) indicating the SCALE
encoded _Result_ (<<defn-result-type>>). On success it contains the 64-byte
recovered public key or an error type (<<defn-ecdsa-verify-error>>) on failure.

===== Version 2 - Prototype

Does not handle non-standard, overflowing ECDSA signatures.

----
(func $ext_crypto_secp256k1_ecdsa_recover_version_2
	(param $sig i32) (param $msg i32) (return i64))
----

Arguments::

* `sig`: a 32-bit pointer to the buffer containing the 65-byte signature in RSV
format. V should be either or .
* `msg`: a 32-bit pointer to the buffer containing the 256-bit Blake2 hash of
the message.
* `return`: a pointer-size (<<defn-runtime-pointer>>) indicating the SCALE
encoded _Result_ (<<defn-result-type>>). On success it contains the 64-byte
recovered public key or an error type (<<defn-ecdsa-verify-error>>) on failure.

==== `ext_crypto_secp256k1_ecdsa_recover_compressed`

Verify and recover a _secp256k1_ ECDSA signature.

===== Version 1 - Prototype

This function can handle non-standard, overflowing ECDSA signatures, an
implemenation specific mechanism of the Rust
https://github.com/paritytech/libsecp256k1[`libsecp256k1` library], specifically
the
https://docs.rs/libsecp256k1/0.7.0/libsecp256k1/struct.Signature.html#method.parse_overflowing[`parse_overflowing`]
function.

----
(func $ext_crypto_secp256k1_ecdsa_recover_compressed_version_1
	(param $sig i32) (param $msg i32) (return i64))
----

Arguments::

* `sig`: a 32-bit pointer to the buffer containing the 65-byte signature in RSV
format. V should be either `0/1` or `27/28`.
* `msg`: a 32-bit pointer to the buffer containing the 256-bit Blake2 hash of
the message.
* `return`: a pointer-size (<<defn-runtime-pointer>>) indicating the SCALE
encoded `Result` value (<<defn-result-type>>). On success it contains the
33-byte recovered public key in compressed form on success or an error type
(<<defn-ecdsa-verify-error>>) on failure.

===== Version 2 - Prototype

Does not handle non-standard, overflowing ECDSA signatures.

----
(func $ext_crypto_secp256k1_ecdsa_recover_compressed_version_2
	(param $sig i32) (param $msg i32) (return i64))
----

Arguments::

* `sig`: a 32-bit pointer to the buffer containing the 65-byte signature in RSV
format. V should be either `0/1` or `27/28`.
* `msg`: a 32-bit pointer to the buffer containing the 256-bit Blake2 hash of
the message.
* `return`: a pointer-size (<<defn-runtime-pointer>>) indicating the SCALE
encoded `Result` value (<<defn-result-type>>). On success it contains the
33-byte recovered public key in compressed form on success or an error type
(<<defn-ecdsa-verify-error>>) on failure.

[#sect-ext-crypto-start-batch-verify]
==== `ext_crypto_start_batch_verify`

Starts the verification extension. The extension is a separate background
process and is used to parallel-verify signatures which are pushed to the batch
with `ext_crypto_ed25519_verify` (<<sect-ext-crypto-ed25519-verify>>),
`ext_crypto_sr25519_verify` (<<sect-ext-crypto-sr25519-verify>>) or
`ext_crypto_ecdsa_verify` (<<sect-ext-crypto-ecdsa-verify>>). Verification will
start immediately and the Runtime can retrieve the result when calling
`ext_crypto_finish_batch_verify` (<<sect-ext-crypto-finish-batch-verify>>).

===== Version 1 - Prototype
----
(func $ext_crypto_start_batch_verify_version_1)
----

Arguments::

* None.

[#sect-ext-crypto-finish-batch-verify]
==== `ext_crypto_finish_batch_verify`

Finish verifying the batch of signatures since the last call to this function.
Blocks until all the signatures are verified.

WARNING: Panics if `ext_crypto_start_batch_verify`
(<<sect-ext-crypto-start-batch-verify>>) was not called.

===== Version 1 - Prototype
----
(func $ext_crypto_finish_batch_verify_version_1
	(return i32))
----

Arguments::

* `return`: an i32 integer value equal to _1_ if all the signatures are valid or
a value equal to _0_ if one or more of the signatures are invalid.
